==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/ansicolors.lua
==============================================================================
      -- ansicolors.lua v1.0.2 (2012-08)

      -- Copyright (c) 2009 Rob Hoelz <rob@hoelzro.net>
      -- Copyright (c) 2011 Enrique Garc√≠a Cota <enrique.garcia.cota@gmail.com>
      --
      -- Permission is hereby granted, free of charge, to any person obtaining a copy
      -- of this software and associated documentation files (the "Software"), to deal
      -- in the Software without restriction, including without limitation the rights
      -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      -- copies of the Software, and to permit persons to whom the Software is
      -- furnished to do so, subject to the following conditions:
      --
      -- The above copyright notice and this permission notice shall be included in
      -- all copies or substantial portions of the Software.
      --
      -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
      -- THE SOFTWARE.


      -- support detection
      local function isWindows()
   12   return type(package) == 'table' and type(package.config) == 'string' and package.config:sub(1,1) == '\\'
      end

    6 local supported = not isWindows()
    6 if isWindows() then supported = os.getenv("ANSICON") end

    6 local keys = {
        -- reset
    6   reset =      0,

        -- misc
    6   bright     = 1,
    6   dim        = 2,
    6   underline  = 4,
    6   blink      = 5,
    6   reverse    = 7,
    6   hidden     = 8,

        -- foreground colors
    6   black     = 30,
    6   red       = 31,
    6   green     = 32,
    6   yellow    = 33,
    6   blue      = 34,
    6   magenta   = 35,
    6   cyan      = 36,
    6   white     = 37,

        -- background colors
    6   blackbg   = 40,
    6   redbg     = 41,
    6   greenbg   = 42,
    6   yellowbg  = 43,
    6   bluebg    = 44,
    6   magentabg = 45,
    6   cyanbg    = 46,
    6   whitebg   = 47
      }

    6 local escapeString = string.char(27) .. '[%dm'
      local function escapeNumber(number)
****0   return escapeString:format(number)
      end

      local function escapeKeys(str)

****0   if not supported then return "" end

****0   local buffer = {}
        local number
****0   for word in str:gmatch("%w+") do
****0     number = keys[word]
****0     assert(number, "Unknown key: " .. word)
****0     table.insert(buffer, escapeNumber(number) )
        end

****0   return table.concat(buffer)
      end

      local function replaceCodes(str)
****0   str = string.gsub(str,"(%%{(.-)})", function(_, str) return escapeKeys(str) end )
****0   return str
      end

      -- public

      local function ansicolors( str )
****0   str = tostring(str or '')

****0   return replaceCodes('%{reset}' .. str .. '%{reset}')
      end


    6 return setmetatable({noReset = replaceCodes}, {__call = function (_, str) return ansicolors (str) end})

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/block.lua
==============================================================================
****0 local getfenv = require 'busted.compatibility'.getfenv
****0 local unpack = require 'busted.compatibility'.unpack
****0 local shuffle = require 'busted.utils'.shuffle

      local function sort(elements)
****0   table.sort(elements, function(t1, t2)
****0     if t1.name and t2.name then
****0       return t1.name < t2.name
          end
****0     return t2.name ~= nil
        end)
****0   return elements
      end

      return function(busted)
    4   local block = {}
    4   local root = busted.context.get()

    4   function block.reject(descriptor, element)
  306     element.env[descriptor] = function(...)
****0       error("'" .. descriptor .. "' not supported inside current context block", 2)
          end
        end

    4   function block.rejectAll(element)
   18     local env = getfenv(element.run)
   18     block.reject('randomize', element)
  324     for descriptor, _ in pairs(busted.executors) do
  306       if root.env[descriptor] and (env ~= _G and env[descriptor] or rawget(env, descriptor)) then
  288         block.reject(descriptor, element)
            end
          end
        end

        local function exec(descriptor, element)
****0     if not element.env then element.env = {} end
****0     block.rejectAll(element)
****0     local ret = { busted.safe(descriptor, element.run, element) }
****0     return unpack(ret)
        end

    4   function block.execAllOnce(descriptor, current, err)
   70     local parent = busted.context.parent(current)

   70     if parent then
   52       local success = block.execAllOnce(descriptor, parent)
   52       if not success then
****0         return success
            end
          end

   70     if not current[descriptor] then
   32       current[descriptor] = {}
          end
   70     local list = current[descriptor]
   70     if list.success ~= nil then
   38       return list.success
          end

   32     local success = true
   32     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = false
            end
          end

   32     list.success = success

   32     return success
        end

    4   function block.execAll(descriptor, current, propagate, err)
  106     local parent = busted.context.parent(current)

  106     if propagate and parent then
   52       local success, ancestor = block.execAll(descriptor, parent, propagate)
   52       if not success then
****0         return success, ancestor
            end
          end

  106     local list = current[descriptor] or {}

  106     local success = true
  106     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = nil
            end
          end
  106     return success, current
        end

    4   function block.dexecAll(descriptor, current, propagate, err)
  138     local parent = busted.context.parent(current)
  138     local list = current[descriptor] or {}

  138     local success = true
  138     for _, v in ipairs(list) do
****0       if not exec(descriptor, v):success() then
****0         if err then err(descriptor) end
****0         success = nil
            end
          end

  138     if propagate and parent then
   52       if not block.dexecAll(descriptor, parent, propagate) then
****0         success = nil
            end
          end
  138     return success
        end

    4   function block.lazySetup(element, err)
   18     return block.execAllOnce('lazy_setup', element, err)
        end

    4   function block.lazyTeardown(element, err)
   36     if element.lazy_setup and element.lazy_setup.success ~= nil then
   32       block.dexecAll('lazy_teardown', element, nil, err)
   32       element.lazy_setup.success = nil
          end
        end

    4   function block.setup(element, err)
   36       return block.execAll('strict_setup', element, nil, err)
        end

    4   function block.teardown(element, err)
   36       return block.dexecAll('strict_teardown', element, nil, err)
        end

    4   function block.execute(descriptor, element)
   32     if not element.env then element.env = {} end

   32     local randomize = busted.randomize
   32     local randomseed = busted.randomseed
   32     element.env.randomize = function(...)
****0       randomize = (select('#', ...) == 0 or ...)
****0       if randomize then
****0         randomseed = tonumber(({...})[1]) or tonumber(({...})[2]) or randomseed
            end
          end

   32     if busted.safe(descriptor, element.run, element):success() then
   32       if busted.sort then
****0         sort(busted.context.children(element))
   32       elseif randomize then
****0         element.randomseed = randomseed
****0         shuffle(busted.context.children(element), randomseed)
            end

   32       if block.setup(element) then
   32         busted.execute(element)
            end

   32       block.lazyTeardown(element)
   32       block.teardown(element)
          end
        end

    4   return block
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/compatibility.lua
==============================================================================
****0 return {
****0   getfenv = getfenv or function(f)
   18     f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
          local name, value
   18     local up = 0

          repeat
   32       up = up + 1
   32       name, value = debug.getupvalue(f, up)
   32     until name == '_ENV' or name == nil

   18     return name and value or _G
        end,

****0   setfenv = setfenv or function(f, t)
   10     f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
          local name
   10     local up = 0

          repeat
   10       up = up + 1
   10       name = debug.getupvalue(f, up)
   10     until name == '_ENV' or name == nil

   10     if name then
   10       debug.upvaluejoin(f, up, function() return name end, 1)
   10       debug.setupvalue(f, up, t)
          end

   10     if f ~= 0 then return f end
        end,

        loadstring = loadstring or load,
        unpack = table.unpack or unpack,

        exit = function(code, force)
    4     if not force and code ~= 0 and _VERSION:match('^Lua 5%.[12]$') then
****0       error()
    4     elseif code ~= 0 then
    4       code = 1
          end
    4     if _VERSION == 'Lua 5.1' and
****0       (type(jit) ~= 'table' or not jit.version or jit.version_num < 20000) then
            -- From Lua 5.1 manual:
            -- > The userdata itself is freed only in the next
            -- > garbage-collection cycle.
            -- Call collectgarbage() while collectgarbage('count')
            -- changes + 3 times, at least 3 times,
            -- at max 100 times (to prevent infinite loop).
****0       local times_const = 0
****0       for i = 1, 100 do
****0         local count_before = collectgarbage("count")
****0         collectgarbage()
****0         local count_after = collectgarbage("count")
****0         if count_after == count_before then
****0           times_const = times_const + 1
****0           if times_const > 3 then
                  break
                end
              else
****0           times_const = 0
              end
            end
          end
    4     os.exit(code, true)
        end,

        execute = require 'pl.utils'.execute,
      }

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/context.lua
==============================================================================
****0 local tablex = require 'pl.tablex'

      local function save()
   10   local g = {}
  380   for k,_ in next, _G, nil do
  370     g[k] = rawget(_G, k)
        end
   10   return {
   10     gmt = debug.getmetatable(_G),
   10     g = g,
   10     loaded = tablex.copy(package.loaded)
   10   }
      end

      local function restore(state)
   10   setmetatable(_G, state.gmt)
  380   for k,_ in next, _G, nil do
  370     rawset(_G, k, state.g[k])
        end
  954   for k,_ in pairs(package.loaded) do
  944     package.loaded[k] = state.loaded[k]
        end
      end

      return function()
****0   local context = {}

****0   local data = { descriptor = 'suite', attributes = {} }
****0   local parents = {}
****0   local children = {}
****0   local stack = {}
****0   local states = {}

****0   function context.ref()
****0     local ref = {}
****0     local ctx = data

          local function unwrap(element, levels)
****0       local levels = levels or 1
****0       local parent = element
****0       for i = 1, levels do
****0         parent = ref.parent(parent)
****0         if not parent then break end
            end
****0       if not element.env then element.env = {} end
****0       setmetatable(element.env, {
              __newindex = function(self, key, value)
****0           if not parent then
****0             _G[key] = value
                else
****0             if not parent.env then parent.env = {} end
****0             parent.env[key] = value
                end
              end
            })
          end

          local function push_state(current)
   50       local state = false
   50       if current.attributes.envmode == 'insulate' then
   10         state = save()
   40       elseif current.attributes.envmode == 'unwrap' then
****0         unwrap(current)
   40       elseif current.attributes.envmode == 'expose' then
****0         unwrap(current, 2)
            end
   50       table.insert(states, state)
          end

          local function pop_state(current)
   50       local state = table.remove(states)
   50       if current.attributes.envmode == 'expose' then
****0         states[#states] = states[#states] and save()
            end
   50       if state then
   10         restore(state)
            end
          end

****0     function ref.get(key)
  482       if not key then return ctx end
****0       return ctx[key]
          end

****0     function ref.set(key, value)
****0       ctx[key] = value
          end

****0     function ref.clear()
****0       data = { descriptor = 'suite', attributes = {} }
****0       parents = {}
****0       children = {}
****0       stack = {}
****0       states = {}
****0       ctx = data
          end

****0     function ref.attach(child)
   50       if not children[ctx] then children[ctx] = {} end
   50       parents[child] = ctx
   50       table.insert(children[ctx], child)
          end

****0     function ref.children(parent)
   40       return children[parent] or {}
          end

****0     function ref.parent(child)
 1854       return parents[child]
          end

****0     function ref.push(current)
  208       if not parents[current] and current ~= data then error('Detached child. Cannot push.') end
  208       if ctx ~= current then push_state(current) end
  208       table.insert(stack, ctx)
  208       ctx = current
          end

****0     function ref.pop()
  208       local current = ctx
  208       ctx = table.remove(stack)
  208       if ctx ~= current then pop_state(current) end
  208       if not ctx then error('Context stack empty. Cannot pop.') end
          end

****0     return ref
        end

****0   return context
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/core.lua
==============================================================================
****0 local getfenv = require 'busted.compatibility'.getfenv
****0 local setfenv = require 'busted.compatibility'.setfenv
****0 local unpack = require 'busted.compatibility'.unpack
****0 local path = require 'pl.path'
****0 local pretty = require 'pl.pretty'
****0 local system = require 'system'
****0 local throw = error

****0 local failureMt = {
        __index = {},
    2   __tostring = function(e) return tostring(e.message) end,
****0   __type = 'failure'
      }

****0 local failureMtNoString = {
        __index = {},
****0   __type = 'failure'
      }

****0 local pendingMt = {
        __index = {},
        __tostring = function(p) return p.message end,
****0   __type = 'pending'
      }

      local function errortype(obj)
    2   local mt = debug.getmetatable(obj)
    2   if mt == failureMt or mt == failureMtNoString then
    2     return 'failure'
****0   elseif mt == pendingMt then
****0     return 'pending'
        end
****0   return 'error'
      end

      local function hasToString(obj)
    4   return type(obj) == 'string' or (debug.getmetatable(obj) or {}).__tostring
      end

      local function isCallable(obj)
   10   return type(obj) == 'function' or (debug.getmetatable(obj) or {}).__call
      end

      return function()
****0   local mediator = require 'mediator'()

****0   local busted = {}
****0   busted.version = '2.0.0-0'

****0   local root = require 'busted.context'()
****0   busted.context = root.ref()

****0   local environment = require 'busted.environment'(busted.context)

****0   busted.api = {}
****0   busted.executors = {}
****0   local executors = {}
****0   local eattributes = {}

****0   busted.gettime = system.gettime
****0   busted.monotime = system.monotime
****0   busted.sleep = system.sleep
****0   busted.status = require 'busted.status'

****0   function busted.getTrace(element, level, msg)
          local function trimTrace(info)
****0       local index = info.traceback:find('\n%s*%[C]')
****0       info.traceback = info.traceback:sub(1, index)
****0       return info
          end
   42     level = level or  3

   42     local thisdir = path.dirname(debug.getinfo(1, 'Sl').source)
   42     local info = debug.getinfo(level, 'Sl')
   48     while info.what == 'C' or info.short_src:match('luassert[/\\].*%.lua$') or
   44           (info.source:sub(1,1) == '@' and thisdir == path.dirname(info.source)) do
    6       level = level + 1
    6       info = debug.getinfo(level, 'Sl')
          end

   42     info.traceback = debug.traceback('', level)
   42     info.message = msg

   42     local file = busted.getFile(element)
   42     return file and file.getTrace(file.name, info) or trimTrace(info)
        end

****0   function busted.rewriteMessage(element, message, trace)
    2     local file = busted.getFile(element)
    2     local msg = hasToString(message) and tostring(message)
    2     msg = msg or (message ~= nil and pretty.write(message) or 'Nil error')
    2     msg = (file and file.rewriteMessage and file.rewriteMessage(file.name, msg) or msg)

    2     local hasFileLine = msg:match('^[^\n]-:%d+: .*')
    2     if not hasFileLine then
****0       local trace = trace or busted.getTrace(element, 3, message)
****0       local fileline = trace.short_src .. ':' .. trace.currentline .. ': '
****0       msg = fileline .. msg
          end

    2     return msg
        end

****0   function busted.publish(...)
  166     return mediator:publish(...)
        end

****0   function busted.subscribe(...)
  124     return mediator:subscribe(...)
        end

****0   function busted.unsubscribe(...)
****0     return mediator:removeSubscriber(...)
        end

****0   function busted.getFile(element)
   44     local parent = busted.context.parent(element)

   68     while parent do
   68       if parent.file then
   10         local file = parent.file[1]
   10         return {
   10           name = file.name,
   10           getTrace = file.run.getTrace,
   10           rewriteMessage = file.run.rewriteMessage
   10         }
            end

   58       if parent.descriptor == 'file' then
   34         return {
   34           name = parent.name,
   34           getTrace = parent.run.getTrace,
   34           rewriteMessage = parent.run.rewriteMessage
   34         }
            end

   24       parent = busted.context.parent(parent)
          end

****0     return parent
        end

****0   function busted.fail(msg, level)
    2     local rawlevel = (type(level) ~= 'number' or level <= 0) and level
    2     local level = level or 1
    2     local _, emsg = pcall(throw, msg, rawlevel or level+2)
    2     local e = { message = emsg }
    2     setmetatable(e, hasToString(msg) and failureMt or failureMtNoString)
    2     throw(e, rawlevel or level+1)
        end

****0   function busted.pending(msg)
****0     local p = { message = msg }
****0     setmetatable(p, pendingMt)
****0     throw(p)
        end

****0   function busted.bindfenv(callable, var, value)
****0     local env = {}
****0     local f = (debug.getmetatable(callable) or {}).__call or callable
****0     setmetatable(env, { __index = getfenv(f) })
****0     env[var] = value
****0     setfenv(f, env)
        end

****0   function busted.wrap(callable)
   10     if isCallable(callable) then
            -- prioritize __call if it exists, like in files
   10       environment.wrap((debug.getmetatable(callable) or {}).__call or callable)
          end
        end

****0   function busted.safe(descriptor, run, element)
  208     busted.context.push(element)
          local trace, message
  208     local status = 'success'

  416     local ret = { xpcall(run, function(msg)
    2       status = errortype(msg)
    2       trace = busted.getTrace(element, 3, msg)
    2       message = busted.rewriteMessage(element, msg, trace)
  418     end) }

  208     if not ret[1] then
    2       if status == 'success' then
****0         status = 'error'
****0         trace = busted.getTrace(element, 3, ret[2])
****0         message = busted.rewriteMessage(element, ret[2], trace)
    2       elseif status == 'failure' and descriptor ~= 'it' then
              -- Only 'it' blocks can generate test failures. Failures in all
              -- other blocks are errors outside the test.
****0         status = 'error'
            end
            -- Note: descriptor may be different from element.descriptor when
            -- safe_publish is used (i.e. for test start/end). The safe_publish
            -- descriptor needs to be different for 'it' blocks so that we can
            -- detect that a 'failure' in a test start/end handler is not really
            -- a test failure, but rather an error outside the test, much like a
            -- failure in a support function (i.e. before_each/after_each or
            -- setup/teardown).
    2       busted.publish({ status, element.descriptor }, element, busted.context.parent(element), message, trace)
          end
  208     ret[1] = busted.status(status)

  208     busted.context.pop()
  208     return unpack(ret)
        end

****0   function busted.safe_publish(descriptor, channel, element, ...)
  108     local args = {...}
  108     local n = select('#', ...)
  108     if channel[2] == 'start' then
   54       element.starttick = busted.monotime()
   54       element.starttime = busted.gettime()
   54     elseif channel[2] == 'end' then
   54       element.endtime = busted.gettime()
   54       element.endtick = busted.monotime()
   54       element.duration = element.starttick and (element.endtick - element.starttick)
          end
  216     local status = busted.safe(descriptor, function()
  108       busted.publish(channel, element, unpack(args, 1, n))
  216     end, element)
  108     return status:success()
        end

****0   function busted.exportApi(key, value)
****0     busted.api[key] = value
        end

****0   function busted.export(key, value)
****0     busted.exportApi(key, value)
****0     environment.set(key, value)
        end

****0   function busted.hide(key, value)
****0     busted.api[key] = nil
****0     environment.set(key, nil)
        end

****0   function busted.register(descriptor, executor, attributes)
          local alias = nil
****0     if type(executor) == 'string' then
****0       alias = descriptor
****0       descriptor = executor
****0       executor = executors[descriptor]
****0       attributes = attributes or eattributes[descriptor]
****0       executors[alias] = executor
****0       eattributes[alias] = attributes
          else
****0       if executor ~= nil and not isCallable(executor) then
****0         attributes = executor
****0         executor = nil
            end
****0       executors[descriptor] = executor
****0       eattributes[descriptor] = attributes
          end

          local publisher = function(name, fn)
   50       if not fn and type(name) == 'function' then
****0         fn = name
****0         name = alias
            end

            local trace

   50       local ctx = busted.context.get()
   50       if busted.context.parent(ctx) then
   40         trace = busted.getTrace(ctx, 3, name)
            end

            local publish = function(f)
   50         busted.publish({ 'register', descriptor }, name, f, trace, attributes)
            end

   50       if fn then publish(fn) else return publish end
          end

****0     local edescriptor = alias or descriptor
****0     busted.executors[edescriptor] = publisher
****0     busted.export(edescriptor, publisher)

****0     busted.subscribe({ 'register', descriptor }, function(name, fn, trace, attributes)
   50       local ctx = busted.context.get()
   50       local plugin = {
   50         descriptor = descriptor,
   50         attributes = attributes or {},
   50         name = name,
   50         run = fn,
   50         trace = trace,
   50         starttick = nil,
   50         endtick = nil,
   50         starttime = nil,
   50         endtime = nil,
   50         duration = nil,
            }

   50       busted.context.attach(plugin)

   50       if not ctx[descriptor] then
   32         ctx[descriptor] = { plugin }
            else
   18         ctx[descriptor][#ctx[descriptor]+1] = plugin
            end
          end)
        end

****0   function busted.execute(current)
   36     if not current then current = busted.context.get() end
   86     for _, v in pairs(busted.context.children(current)) do
   50       local executor = executors[v.descriptor]
   50       if executor and not busted.skipAll then
  100         busted.safe(v.descriptor, function() executor(v) end, v)
            end
          end
        end

****0   return busted
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/environment.lua
==============================================================================
****0 local setfenv = require 'busted.compatibility'.setfenv

      return function(context)

****0   local environment = {}

        local function getEnv(self, key)
 1644     if not self then return nil end
****0     return
 1638       self.env and self.env[key] or
 1292       getEnv(context.parent(self), key) or
 1638       _G[key]
        end

        local function setEnv(self, key, value)
****0     if not self.env then self.env = {} end
****0     self.env[key] = value
        end

        local function __index(self, key)
  352     return getEnv(context.get(), key)
        end

        local function __newindex(self, key, value)
****0     setEnv(context.get(), key, value)
        end

****0   local env = setmetatable({}, { __index=__index, __newindex=__newindex })

****0   function environment.wrap(fn)
   10     return setfenv(fn, env)
        end

****0   function environment.set(key, value)
****0     local env = context.get('env')

****0     if not env then
****0       env = {}
****0       context.set('env', env)
          end

****0     env[key] = value
        end
****0   return environment
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/execute.lua
==============================================================================
    4 local shuffle = require 'busted.utils'.shuffle
    4 local urandom = require 'busted.utils'.urandom
    4 local tablex = require 'pl.tablex'

      local function sort(elements)
****0   table.sort(elements, function(t1, t2)
****0     if t1.name and t2.name then
****0       return t1.name < t2.name
          end
****0     return t2.name ~= nil
        end)
****0   return elements
      end

      return function(busted)
    4   local block = require 'busted.block'(busted)

        local function execute(runs, options)
    4     local root = busted.context.get()
    4     local children = tablex.copy(busted.context.children(root))

          local function suite_reset()
****0       local oldctx = busted.context.get()

****0       busted.context.clear()
****0       local ctx = busted.context.get()
****0       for k, v in pairs(oldctx) do
****0         ctx[k] = v
            end

****0       for _, child in ipairs(children) do
****0         for descriptor, _ in pairs(busted.executors) do
****0           child[descriptor] = nil
              end
****0         busted.context.attach(child)
            end

****0       busted.randomseed = tonumber(options.seed) or urandom() or os.time()
          end

    8     for i = 1, runs do
    4       if i > 1 then
****0         suite_reset()
****0         root = busted.context.get()
****0         busted.safe_publish('suite', { 'suite', 'reset' }, root, i, runs)
            end

    4       if options.sort then
****0         sort(busted.context.children(root))
    4       elseif options.shuffle then
****0         root.randomseed = busted.randomseed
****0         shuffle(busted.context.children(root), busted.randomseed)
            end

    4       local seed = (busted.randomize and busted.randomseed or nil)
    4       if busted.safe_publish('suite', { 'suite', 'start' }, root, i, runs, seed) then
    4         if block.setup(root) then
    4           busted.execute()
              end
    4         block.lazyTeardown(root)
    4         block.teardown(root)
            end
    4       busted.safe_publish('suite', { 'suite', 'end' }, root, i, runs)

    4       if busted.skipAll then
              break
            end
          end
        end

    4   return execute
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/init.lua
==============================================================================
      local function init(busted)
****0   local block = require 'busted.block'(busted)

        local file = function(file)
   10     busted.wrap(file.run)
   10     if busted.safe_publish('file', { 'file', 'start' }, file) then
   10       block.execute('file', file)
          end
   10     busted.safe_publish('file', { 'file', 'end' }, file)
        end

        local describe = function(describe)
   22     local parent = busted.context.parent(describe)
   22     if busted.safe_publish('describe', { 'describe', 'start' }, describe, parent) then
   22       block.execute('describe', describe)
          end
   22     busted.safe_publish('describe', { 'describe', 'end' }, describe, parent)
        end

        local it = function(element)
   18     local parent = busted.context.parent(element)
          local finally

   18     if not block.lazySetup(parent) then
            -- skip test if any setup failed
****0       return
          end

   18     if not element.env then element.env = {} end

   18     block.rejectAll(element)
   18     element.env.finally = function(fn) finally = fn end
   18     element.env.pending = busted.pending

   18     local pass, ancestor = block.execAll('before_each', parent, true)

   18     if pass then
   18       local status = busted.status('success')
   18       if busted.safe_publish('test', { 'test', 'start' }, element, parent) then
   18         status:update(busted.safe('it', element.run, element))
   18         if finally then
****0           block.reject('pending', element)
****0           status:update(busted.safe('finally', finally, element))
              end
            else
****0         status = busted.status('error')
            end
   18       busted.safe_publish('test', { 'test', 'end' }, element, parent, tostring(status))
          end

   18     block.dexecAll('after_each', ancestor, true)
        end

        local pending = function(element)
****0     local parent = busted.context.parent(element)
****0     local status = 'pending'
****0     if not busted.safe_publish('it', { 'test', 'start' }, element, parent) then
****0       status = 'error'
          end
****0     busted.safe_publish('it', { 'test', 'end' }, element, parent, status)
        end

****0   busted.register('file', file, { envmode = 'insulate' })

****0   busted.register('describe', describe)
****0   busted.register('insulate', 'describe', { envmode = 'insulate' })
****0   busted.register('expose', 'describe', { envmode = 'expose' })

****0   busted.register('it', it)

****0   busted.register('pending', pending)

****0   busted.register('before_each', { envmode = 'unwrap' })
****0   busted.register('after_each', { envmode = 'unwrap' })

****0   busted.register('lazy_setup', { envmode = 'unwrap' })
****0   busted.register('lazy_teardown', { envmode = 'unwrap' })
****0   busted.register('strict_setup', { envmode = 'unwrap' })
****0   busted.register('strict_teardown', { envmode = 'unwrap' })

****0   busted.register('setup', 'strict_setup')
****0   busted.register('teardown', 'strict_teardown')

****0   busted.register('context', 'describe')
****0   busted.register('spec', 'it')
****0   busted.register('test', 'it')

****0   busted.hide('file')

****0   local assert = require 'luassert'
****0   local spy    = require 'luassert.spy'
****0   local mock   = require 'luassert.mock'
****0   local stub   = require 'luassert.stub'
****0   local match  = require 'luassert.match'

****0   busted.export('assert', assert)
****0   busted.export('spy', spy)
****0   busted.export('mock', mock)
****0   busted.export('stub', stub)
****0   busted.export('match', match)

****0   busted.exportApi('publish', busted.publish)
****0   busted.exportApi('subscribe', busted.subscribe)
****0   busted.exportApi('unsubscribe', busted.unsubscribe)

****0   busted.exportApi('bindfenv', busted.bindfenv)
****0   busted.exportApi('fail', busted.fail)
****0   busted.exportApi('gettime', busted.gettime)
****0   busted.exportApi('monotime', busted.monotime)
****0   busted.exportApi('sleep', busted.sleep)
****0   busted.exportApi('parent', busted.context.parent)
****0   busted.exportApi('children', busted.context.children)
****0   busted.exportApi('version', busted.version)

****0   busted.bindfenv(assert, 'error', busted.fail)
****0   busted.bindfenv(assert.is_true, 'error', busted.fail)

****0   return busted
      end

****0 return setmetatable({}, {
        __call = function(self, busted)
****0     init(busted)

****0     return setmetatable(self, {
            __index = function(self, key)
  122         return busted.api[key]
            end,

            __newindex = function(self, key, value)
****0         error('Attempt to modify busted')
            end
          })
        end
      })

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/languages/en.lua
==============================================================================
    4 local s = require('say')

    4 s:set_namespace('en')

      -- 'Pending: test.lua @ 12 \n description
    4 s:set('output.pending', 'Pending')
    4 s:set('output.failure', 'Failure')
    4 s:set('output.error', 'Error')
    4 s:set('output.success', 'Success')

    4 s:set('output.pending_plural', 'pending')
    4 s:set('output.failure_plural', 'failures')
    4 s:set('output.error_plural', 'errors')
    4 s:set('output.success_plural', 'successes')

    4 s:set('output.pending_zero', 'pending')
    4 s:set('output.failure_zero', 'failures')
    4 s:set('output.error_zero', 'errors')
    4 s:set('output.success_zero', 'successes')

    4 s:set('output.pending_single', 'pending')
    4 s:set('output.failure_single', 'failure')
    4 s:set('output.error_single', 'error')
    4 s:set('output.success_single', 'success')

    4 s:set('output.seconds', 'seconds')

    4 s:set('output.no_test_files_match', 'No test files found matching Lua pattern: %s')
    4 s:set('output.file_not_found', 'Cannot find file or directory: %s')

      -- definitions following are not used within the 'say' namespace
    4 return {
    4   failure_messages = {
    4     'You have %d busted specs',
    4     'Your specs are busted',
    4     'Your code is bad and you should feel bad',
    4     'Your code is in the Danger Zone',
    4     'Strange game. The only way to win is not to test',
    4     'My grandmother wrote better specs on a 3 86',
    4     'Every time there\'s a failure, drink another beer',
          'Feels bad man'
    4   },
    4   success_messages = {
    4     'Aww yeah, passing specs',
    4     'Doesn\'t matter, had specs',
    4     'Feels good, man',
    4     'Great success',
          'Tests pass, drink another beer',
    4   }
    4 }

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/files/lua.lua
==============================================================================
    4 local path = require 'pl.path'

    4 local ret = {}

      local getTrace = function(filename, info)
   42   local index = info.traceback:find('\n%s*%[C]')
   42   info.traceback = info.traceback:sub(1, index)
   42   return info
      end

      ret.match = function(busted, filename)
   12   return path.extension(filename) == '.lua'
      end

      ret.load = function(busted, filename)
   12   local file, err = loadfile(filename)
   12   if not file then
    2     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
        end
   12   return file, getTrace
      end

    4 return ret

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/files/moonscript.lua
==============================================================================
    4 local path = require 'pl.path'

    8 local ok, moonscript, line_tables, util = pcall(function()
    4   return require 'moonscript', require 'moonscript.line_tables', require 'moonscript.util'
      end)

    4 local _cache = {}

      -- find the line number of `pos` chars into fname
      local lookup_line = function(fname, pos)
****0   if not _cache[fname] then
****0     local f = io.open(fname)
****0     _cache[fname] = f:read('*a')
****0     f:close()
        end

****0   return util.pos_to_line(_cache[fname], pos)
      end

      local rewrite_linenumber = function(fname, lineno)
****0   local tbl = line_tables['@' .. fname]
****0   if fname and tbl then
****0     for i = lineno, 0 ,-1 do
****0       if tbl[i] then
****0         return lookup_line(fname, tbl[i])
            end
          end
        end

****0   return lineno
      end

      local rewrite_filename = function(filename)
        -- sometimes moonscript gives files like [string "./filename.moon"], so
        -- we'll chop it up to only get the filename.
****0   return filename:match('string "(.+)"') or filename
      end

      local rewrite_traceback = function(fname, trace)
        local rewrite_one = function(line, pattern, sub)
****0     if line == nil then return '' end

****0     local fname, lineno = line:match(pattern)

****0     if fname and lineno then
****0       fname = rewrite_filename(fname)
****0       local new_lineno = rewrite_linenumber(fname, tonumber(lineno))
****0       if new_lineno then
****0         line = line:gsub(sub:format(tonumber(lineno)), sub:format(tonumber(new_lineno)))
            end
          end

****0     return line
        end

****0   local lines = {}
****0   local j = 0

****0   for line in trace:gmatch('[^\r\n]+') do
****0     j = j + 1
****0     line = rewrite_one(line, '%s*(.-):(%d+): ', ':%d:')
****0     line = rewrite_one(line, '<(.*):(%d+)>', ':%d>')
****0     lines[j] = line
        end

****0   return '\n' .. table.concat(lines, trace:match('[\r\n]+')) .. '\n'
      end

    4 local ret = {}

      local getTrace = function(filename, info)
****0   local index = info.traceback:find('\n%s*%[C]')
****0   info.traceback = info.traceback:sub(1, index)

****0   info.short_src = rewrite_filename(info.short_src)
****0   info.traceback = rewrite_traceback(filename, info.traceback)
****0   info.linedefined = rewrite_linenumber(filename, info.linedefined)
****0   info.currentline = rewrite_linenumber(filename, info.currentline)

****0   return info
      end

      local rewriteMessage = function(filename, message)
****0   local fname, line, msg = message:match('^([^\n]-):(%d+): (.*)')
****0   if not fname then
****0     return message
        end

****0   fname = rewrite_filename(fname)
****0   line = rewrite_linenumber(fname, tonumber(line))

****0   return fname .. ':' .. tostring(line) .. ': ' .. msg
      end

      ret.match = function(busted, filename)
****0   return ok and path.extension(filename) == '.moon'
      end

      ret.load = function(busted, filename)
****0   local file, err = moonscript.loadfile(filename)
****0   if not file then
****0     busted.publish({ 'error', 'file' }, { descriptor = 'file', name = filename }, nil, err, {})
        end
****0   return file, getTrace, rewriteMessage
      end

    4 return ret

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/filter_loader.lua
==============================================================================
      return function()
        local function filter(busted, options)
          local getFullName = function(name)
   18       local parent = busted.context.get()
   18       local names = { name }

   52       while parent and (parent.name or parent.descriptor) and
   52             parent.descriptor ~= 'file' do
   34         table.insert(names, 1, parent.name or parent.descriptor)
   34         parent = busted.context.parent(parent)
            end

   18       return table.concat(names, ' ')
          end

          local hasTag = function(name, tag)
****0       local found = name:find('#' .. tag)
****0       return (found ~= nil)
          end

          local filterExcludeTags = function(name)
   40       for i, tag in pairs(options.excludeTags) do
****0         if hasTag(name, tag) then
****0           return nil, false
              end
            end
   40       return nil, true
          end

          local filterTags = function(name)
   18       local fullname = getFullName(name)
   18       for i, tag in pairs(options.tags) do
****0         if hasTag(fullname, tag) then
****0           return nil, true
              end
            end
   18       return nil, (#options.tags == 0)
          end

          local filterOutNames = function(name)
   40       for _, filter in pairs(options.filterOut) do
****0         if getFullName(name):find(filter) ~= nil then
****0           return nil, false
              end
            end
   40       return nil, true
          end

          local filterNames = function(name)
   18       for _, filter in pairs(options.filter) do
****0         if getFullName(name):find(filter) ~= nil then
****0           return nil, true
              end
            end
   18       return nil, (#options.filter == 0)
          end

          local printTestName = function(element, parent, status)
****0       if not (options.suppressPending and status == 'pending') then
****0         local fullname = getFullName()
****0         local trace = element.trace
****0         if trace and trace.what == 'Lua' then
****0           fullname = trace.short_src .. ':' .. trace.currentline .. ': ' .. fullname
              end
****0         print(fullname)
            end
****0       return nil, false
          end

          local ignoreAll = function()
****0       return nil, false
          end

    4     local noop = function() end
          local stubOut = function(descriptor, name, fn, ...)
****0       if fn == noop then
****0         return nil, true
            end
****0       busted.publish({ 'register', descriptor }, name, noop, ...)
****0       return nil, false
          end

          local skipOnError = function()
****0       return nil, not busted.skipAll
          end

          local applyFilter = function(descriptors, name, fn)
   32       if options[name] and options[name] ~= '' then
   56         for _, descriptor in ipairs(descriptors) do
   40           busted.subscribe({ 'register', descriptor }, fn, { priority = 1 })
              end
            end
          end

          local applyDescFilter = function(descriptors, name, fn)
****0       if options[name] and options[name] ~= '' then
****0         for _, descriptor in ipairs(descriptors) do
****0           local f = function(...) return fn(descriptor, ...) end
****0           busted.subscribe({ 'register', descriptor }, f, { priority = 1 })
              end
            end
          end

    4     if options.list then
****0       busted.subscribe({ 'suite', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'suite', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'file', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'file', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'describe', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'describe', 'end' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'test', 'start' }, ignoreAll, { priority = 1 })
****0       busted.subscribe({ 'test', 'end' }, printTestName, { priority = 1 })
****0       applyDescFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'list', stubOut)
****0       applyDescFilter({ 'lazy_setup', 'lazy_teardown' }, 'list', stubOut)
****0       applyDescFilter({ 'strict_setup', 'strict_teardown' }, 'list', stubOut)
****0       applyDescFilter({ 'it', 'pending' }, 'list', stubOut)
          end

    4     applyFilter({ 'lazy_setup', 'lazy_teardown' }, 'nokeepgoing', skipOnError)
    4     applyFilter({ 'strict_setup', 'strict_teardown' }, 'nokeepgoing', skipOnError)
    4     applyFilter({ 'setup', 'teardown', 'before_each', 'after_each' }, 'nokeepgoing', skipOnError)
    4     applyFilter({ 'file', 'describe', 'it', 'pending' }, 'nokeepgoing', skipOnError)

          -- The following filters are applied in reverse order
    4     applyFilter({ 'it', 'pending' }            , 'filter'     , filterNames      )
    4     applyFilter({ 'describe', 'it', 'pending' }, 'filterOut'  , filterOutNames   )
    4     applyFilter({ 'it', 'pending' }            , 'tags'       , filterTags       )
    4     applyFilter({ 'describe', 'it', 'pending' }, 'excludeTags', filterExcludeTags)
        end

****0   return filter
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/output_handler_loader.lua
==============================================================================
****0 local path = require 'pl.path'
****0 local hasMoon, moonscript = pcall(require, 'moonscript')
****0 local utils = require 'busted.utils'

      return function()
        local loadOutputHandler = function(busted, output, options)
          local handler

    4     utils.copy_interpreter_args(options.arguments)
    8     local success, err = pcall(function()
    4       if output:match('%.lua$') then
****0         handler = dofile(path.normpath(output))
    4       elseif hasMoon and output:match('%.moon$') then
****0         handler = moonscript.dofile(path.normpath(output))
            else
    4         handler = require('busted.outputHandlers.' .. output)
            end
          end)

    4     if not success and err:match("module '.-' not found:") then
****0       success, err = pcall(function() handler = require(output) end)
          end

    4     if not success then
****0       busted.publish({ 'error', 'output' }, { descriptor = 'output', name = output }, nil, err, {})
****0       handler = require('busted.outputHandlers.' .. options.defaultOutput)
          end

    4     if options.enableSound then
****0       require 'busted.outputHandlers.sound'(options)
          end

    4     handler(options):subscribe(options)
        end

****0   return loadOutputHandler
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/test_file_loader.lua
==============================================================================
    4 local s = require 'say'

      return function(busted, loaders)
    4   local path = require 'pl.path'
    4   local dir = require 'pl.dir'
    4   local tablex = require 'pl.tablex'
    4   local fileLoaders = {}

   12   for _, v in pairs(loaders) do
    8     local loader = require('busted.modules.files.'..v)
    8     fileLoaders[#fileLoaders+1] = loader
        end

        local getTestFiles = function(rootFile, patterns, options)
          local fileList

    4     if path.isfile(rootFile) then
****0       fileList = { rootFile }
    4     elseif path.isdir(rootFile) then
    4       local getfiles = options.recursive and dir.getallfiles or dir.getfiles
    4       fileList = getfiles(rootFile)

    8       fileList = tablex.filter(fileList, function(filename)
  132         local basename = path.basename(filename)
  132         for _, patt in ipairs(options.excludes) do
****0           if patt ~= '' and basename:find(patt) then
****0             return nil
                end
              end
  252         for _, patt in ipairs(patterns) do
  132           if basename:find(patt) then
   12             return true
                end
              end
  120         return #patterns == 0
            end)

    8       fileList = tablex.filter(fileList, function(filename)
   12         if path.is_windows then
****0           return not filename:find('%\\%.%w+.%w+', #rootFile)
              else
   12           return not filename:find('/%.%w+.%w+', #rootFile)
              end
            end)
          else
****0       busted.publish({ 'error' }, {}, nil, s('output.file_not_found'):format(rootFile), {})
****0       fileList = {}
          end

    4     table.sort(fileList)
    4     return fileList
        end

        local getAllTestFiles = function(rootFiles, patterns, options)
    4     local fileList = {}
    8     for _, root in ipairs(rootFiles) do
    4       tablex.insertvalues(fileList, getTestFiles(root, patterns, options))
          end
    4     return fileList
        end

        -- runs a testfile, loading its tests
        local loadTestFile = function(busted, filename)
   12     for _, v in pairs(fileLoaders) do
   12       if v.match(busted, filename) then
   12         return v.load(busted, filename)
            end
          end
        end

        local loadTestFiles = function(rootFiles, patterns, options)
    4     local fileList = getAllTestFiles(rootFiles, patterns, options)

   16     for i, fileName in ipairs(fileList) do
   12       local testFile, getTrace, rewriteMessage = loadTestFile(busted, fileName)

   12       if testFile then
   20         local file = setmetatable({
   10           getTrace = getTrace,
   10           rewriteMessage = rewriteMessage
   10         }, {
   10           __call = testFile
              })

   10         busted.executors.file(fileName, file)
            end
          end

    4     if #fileList == 0 then
****0       local pattern = patterns[1]
****0       if #patterns > 1 then
****0         pattern = '\n\t' .. table.concat(patterns, '\n\t')
            end
****0       busted.publish({ 'error' }, {}, nil, s('output.no_test_files_match'):format(pattern), {})
          end

    4     return fileList
        end

    4   return loadTestFiles, loadTestFile, getAllTestFiles
      end


==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/outputHandlers/base.lua
==============================================================================
      return function()
    4   local busted = require 'busted'
    4   local handler = {
    4     successes = {},
    4     successesCount = 0,
    4     pendings = {},
    4     pendingsCount = 0,
    4     failures = {},
    4     failuresCount = 0,
    4     errors = {},
    4     errorsCount = 0,
    4     inProgress = {}
        }

        handler.cancelOnPending = function(element, parent, status)
   54     return not ((element.descriptor == 'pending' or status == 'pending') and handler.options.suppressPending)
        end

        handler.subscribe = function(handler, options)
    4     require('busted.languages.en')
    4     handler.options = options

    4     if options.language ~= 'en' then
****0       require('busted.languages.' .. options.language)
          end

    4     busted.subscribe({ 'suite', 'reset' }, handler.baseSuiteReset, { priority = 1 })
    4     busted.subscribe({ 'suite', 'start' }, handler.baseSuiteStart, { priority = 1 })
    4     busted.subscribe({ 'suite', 'end' }, handler.baseSuiteEnd, { priority = 1 })
    4     busted.subscribe({ 'test', 'start' }, handler.baseTestStart, { priority = 1, predicate = handler.cancelOnPending })
    4     busted.subscribe({ 'test', 'end' }, handler.baseTestEnd, { priority = 1, predicate = handler.cancelOnPending })
    4     busted.subscribe({ 'pending' }, handler.basePending, { priority = 1, predicate = handler.cancelOnPending })
    4     busted.subscribe({ 'failure', 'it' }, handler.baseTestFailure, { priority = 1 })
    4     busted.subscribe({ 'error', 'it' }, handler.baseTestError, { priority = 1 })
    4     busted.subscribe({ 'failure' }, handler.baseError, { priority = 1 })
    4     busted.subscribe({ 'error' }, handler.baseError, { priority = 1 })
        end

        handler.getFullName = function(context)
   20     local parent = busted.parent(context)
   20     local names = { (context.name or context.descriptor) }

   54     while parent and (parent.name or parent.descriptor) and
   52           parent.descriptor ~= 'file' do

   34       table.insert(names, 1, parent.name or parent.descriptor)
   34       parent = busted.parent(parent)
          end

   20     return table.concat(names, ' ')
        end

        handler.format = function(element, parent, message, debug, isError)
          local function copyElement(e)
   20       local copy = {}
  216       for k,v in next, e do
  196         if type(v) ~= 'function' and k ~= 'env' then
  160           copy[k] = v
              end
            end
   20       return copy
          end

   20     local formatted = {
   20       trace = debug or element.trace,
   20       element = copyElement(element),
   20       name = handler.getFullName(element),
   20       message = message,
   20       randomseed = parent and parent.randomseed,
   20       isError = isError
          }
   20     formatted.element.trace = element.trace or debug

   20     return formatted
        end

        handler.getDuration = function()
    4     if not handler.endTick or not handler.startTick then
****0       return 0
          end

    4     return handler.endTick - handler.startTick
        end

        handler.baseSuiteStart = function(suite)
    4     handler.startTick = suite.starttick
    4     handler.startTime = suite.starttime
    4     return nil, true
        end

        handler.baseSuiteReset = function()
****0     handler.successes = {}
****0     handler.successesCount = 0
****0     handler.pendings = {}
****0     handler.pendingsCount = 0
****0     handler.failures = {}
****0     handler.failuresCount = 0
****0     handler.errors = {}
****0     handler.errorsCount = 0
****0     handler.inProgress = {}

****0     return nil, true
        end

        handler.baseSuiteEnd = function(suite)
    4     handler.endTick = suite.endtick
    4     handler.endTime = suite.endtime
    4     return nil, true
        end

        handler.baseTestStart = function(element, parent)
   18     handler.inProgress[tostring(element)] = {}
   18     return nil, true
        end

        handler.baseTestEnd = function(element, parent, status, debug)
          local insertTable

   18     if status == 'success' then
   16       insertTable = handler.successes
   16       handler.successesCount = handler.successesCount + 1
    2     elseif status == 'pending' then
****0       insertTable = handler.pendings
****0       handler.pendingsCount = handler.pendingsCount + 1
    2     elseif status == 'failure' then
            -- failure already saved in failure handler
    2       handler.failuresCount = handler.failuresCount + 1
    2       return nil, true
****0     elseif status == 'error' then
            -- error count already incremented and saved in error handler
****0       insertTable = handler.errors
****0       return nil, true
          end

   16     local formatted = handler.format(element, parent, element.message, debug)

   16     local id = tostring(element)
   16     if handler.inProgress[id] then
   16       for k, v in pairs(handler.inProgress[id]) do
****0         formatted[k] = v
            end

   16       handler.inProgress[id] = nil
          end

   16     table.insert(insertTable, formatted)

   16     return nil, true
        end

        handler.basePending = function(element, parent, message, debug)
****0     local id = tostring(element)
****0     handler.inProgress[id].message = message
****0     handler.inProgress[id].trace = debug
****0     return nil, true
        end

        handler.baseTestFailure = function(element, parent, message, debug)
    2     table.insert(handler.failures, handler.format(element, parent, message, debug))
    2     return nil, true
        end

        handler.baseTestError = function(element, parent, message, debug)
****0     handler.errorsCount = handler.errorsCount + 1
****0     table.insert(handler.errors, handler.format(element, parent, message, debug, true))
****0     return nil, true
        end

        handler.baseError = function(element, parent, message, debug)
    4     if element.descriptor ~= 'it' then
    2       handler.errorsCount = handler.errorsCount + 1
    2       table.insert(handler.errors, handler.format(element, parent, message, debug, true))
          end

    4     return nil, true
        end

    4   return handler
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/outputHandlers/utfTerminal.lua
==============================================================================
    4 local s = require 'say'
    4 local pretty = require 'pl.pretty'
    4 local io = io

      local colors

    4 if package.config:sub(1,1) == '\\' and not os.getenv("ANSICON") then
        -- Disable colors on Windows.
****0   colors = setmetatable({}, {__index = function() return function(s) return s end end})
      else
    4   colors = require 'term.colors'
      end

      return function(options)
    4   local busted = require 'busted'
    4   local handler = require 'busted.outputHandlers.base'()

    4   local successDot = colors.green('‚óè')
    4   local failureDot = colors.red('‚óº')
    4   local errorDot   = colors.magenta('‚ú±')
    4   local pendingDot = colors.yellow('‚óå')

        local pendingDescription = function(pending)
****0     local name = pending.name

****0     local string = colors.yellow(s('output.pending')) .. ' ‚Üí ' ..
****0       colors.cyan(pending.trace.short_src) .. ' @ ' ..
****0       colors.cyan(pending.trace.currentline)  ..
****0       '\n' .. colors.bright(name)

****0     if type(pending.message) == 'string' then
****0       string = string .. '\n' .. pending.message
****0     elseif pending.message ~= nil then
****0       string = string .. '\n' .. pretty.write(pending.message)
          end

****0     return string
        end

        local failureMessage = function(failure)
    4     local string = failure.randomseed and ('Random seed: ' .. failure.randomseed .. '\n') or ''
    4     if type(failure.message) == 'string' then
    4       string = string .. failure.message
****0     elseif failure.message == nil then
****0       string = string .. 'Nil error'
          else
****0       string = string .. pretty.write(failure.message)
          end

    4     return string
        end

        local failureDescription = function(failure, isError)
    4     local string = colors.red(s('output.failure')) .. ' ‚Üí '
    4     if isError then
    2       string = colors.magenta(s('output.error')) .. ' ‚Üí '
          end

    4     if not failure.element.trace or not failure.element.trace.short_src then
    2       string = string ..
    4         colors.cyan(failureMessage(failure)) .. '\n' ..
    4         colors.bright(failure.name)
          else
    2       string = string ..
    2         colors.cyan(failure.element.trace.short_src) .. ' @ ' ..
    2         colors.cyan(failure.element.trace.currentline) .. '\n' ..
    4         colors.bright(failure.name) .. '\n' ..
    4         failureMessage(failure)
          end

    4     if options.verbose and failure.trace and failure.trace.traceback then
****0       string = string .. '\n' .. failure.trace.traceback
          end

    4     return string
        end

        local statusString = function()
    4     local successString = s('output.success_plural')
    4     local failureString = s('output.failure_plural')
    4     local pendingString = s('output.pending_plural')
    4     local errorString = s('output.error_plural')

    4     local sec = handler.getDuration()
    4     local successes = handler.successesCount
    4     local pendings = handler.pendingsCount
    4     local failures = handler.failuresCount
    4     local errors = handler.errorsCount

    4     if successes == 0 then
****0       successString = s('output.success_zero')
    4     elseif successes == 1 then
****0       successString = s('output.success_single')
          end

    4     if failures == 0 then
    2       failureString = s('output.failure_zero')
    2     elseif failures == 1 then
    2       failureString = s('output.failure_single')
          end

    4     if pendings == 0 then
    4       pendingString = s('output.pending_zero')
****0     elseif pendings == 1 then
****0       pendingString = s('output.pending_single')
          end

    4     if errors == 0 then
    2       errorString = s('output.error_zero')
    2     elseif errors == 1 then
    2       errorString = s('output.error_single')
          end

    4     local formattedTime = ('%.6f'):format(sec):gsub('([0-9])0+$', '%1')

    4     return colors.green(successes) .. ' ' .. successString .. ' / ' ..
    4       colors.red(failures) .. ' ' .. failureString .. ' / ' ..
    4       colors.magenta(errors) .. ' ' .. errorString .. ' / ' ..
    4       colors.yellow(pendings) .. ' ' .. pendingString .. ' : ' ..
    4       colors.bright(formattedTime) .. ' ' .. s('output.seconds')
        end

        handler.testEnd = function(element, parent, status, debug)
   18     if not options.deferPrint then
   18       local string = successDot

   18       if status == 'pending' then
****0         string = pendingDot
   18       elseif status == 'failure' then
    2         string = failureDot
   16       elseif status == 'error' then
****0         string = errorDot
            end

   18       io.write(string)
   18       io.flush()
          end

   18     return nil, true
        end

        handler.suiteStart = function(suite, count, total)
    4     local runString = (total > 1 and '\nRepeating all tests (run %u of %u) . . .\n\n' or '')
    4     io.write(runString:format(count, total))
    4     io.flush()

    4     return nil, true
        end

        handler.suiteEnd = function(suite, count, total)
    4     print('')
    4     print(statusString())

    4     for i, pending in pairs(handler.pendings) do
****0       print('')
****0       print(pendingDescription(pending))
          end

    6     for i, err in pairs(handler.failures) do
    2       print('')
    2       print(failureDescription(err))
          end

    6     for i, err in pairs(handler.errors) do
    2       print('')
    2       print(failureDescription(err, true))
          end

    4     return nil, true
        end

        handler.error = function(element, parent, message, debug)
    2     io.write(errorDot)
    2     io.flush()

    2     return nil, true
        end

    4   busted.subscribe({ 'test', 'end' }, handler.testEnd, { predicate = handler.cancelOnPending })
    4   busted.subscribe({ 'suite', 'start' }, handler.suiteStart)
    4   busted.subscribe({ 'suite', 'end' }, handler.suiteEnd)
    4   busted.subscribe({ 'error', 'file' }, handler.error)
    4   busted.subscribe({ 'failure', 'file' }, handler.error)
    4   busted.subscribe({ 'error', 'describe' }, handler.error)
    4   busted.subscribe({ 'failure', 'describe' }, handler.error)

    4   return handler
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/runner.lua
==============================================================================
      -- Busted command-line runner

****0 local path = require 'pl.path'
****0 local tablex = require 'pl.tablex'
****0 local term = require 'term'
****0 local utils = require 'busted.utils'
****0 local exit = require 'busted.compatibility'.exit
****0 local loadstring = require 'busted.compatibility'.loadstring
****0 local loaded = false

      return function(options)
****0   if loaded then return function() end else loaded = true end

****0   local isatty = io.type(io.stdout) == 'file' and term.isatty(io.stdout)
****0   options = tablex.update(require 'busted.options', options or {})
****0   options.output = options.output or (isatty and 'utfTerminal' or 'plainTerminal')

****0   local busted = require 'busted.core'()

****0   local cli = require 'busted.modules.cli'(options)
****0   local filterLoader = require 'busted.modules.filter_loader'()
****0   local helperLoader = require 'busted.modules.helper_loader'()
****0   local outputHandlerLoader = require 'busted.modules.output_handler_loader'()

****0   local luacov = require 'busted.modules.luacov'()

****0   require 'busted'(busted)

****0   local level = 2
****0   local info = debug.getinfo(level, 'Sf')
****0   local source = info.source
****0   local fileName = source:sub(1,1) == '@' and source:sub(2) or nil
****0   local forceExit = fileName == nil

        -- Parse the cli arguments
****0   local appName = path.basename(fileName or 'busted')
****0   cli:set_name(appName)
****0   local cliArgs, err = cli:parse(arg)
****0   if not cliArgs then
****0     io.stderr:write(err .. '\n')
****0     exit(1, forceExit)
        end

****0   if cliArgs.version then
          -- Return early if asked for the version
****0     print(busted.version)
****0     exit(0, forceExit)
        end

        -- Load current working directory
****0   local _, err = path.chdir(path.normpath(cliArgs.directory))
****0   if err then
****0     io.stderr:write(appName .. ': error: ' .. err .. '\n')
****0     exit(1, forceExit)
        end

        -- If coverage arg is passed in, load LuaCovsupport
****0   if cliArgs.coverage then
****0     local ok, err = luacov()
    4     if not ok then
****0       io.stderr:write(appName .. ': error: ' .. err .. '\n')
****0       exit(1, forceExit)
          end
        end

        -- If auto-insulate is disabled, re-register file without insulation
    4   if not cliArgs['auto-insulate'] then
****0     busted.register('file', 'file', {})
        end

        -- If lazy is enabled, make lazy setup/teardown the default
    4   if cliArgs.lazy then
****0     busted.register('setup', 'lazy_setup')
****0     busted.register('teardown', 'lazy_teardown')
        end

        -- Add additional package paths based on lpath and cpath cliArgs
    4   if #cliArgs.lpath > 0 then
    4     package.path = (cliArgs.lpath .. ';' .. package.path):gsub(';;',';')
        end

    4   if #cliArgs.cpath > 0 then
    4     package.cpath = (cliArgs.cpath .. ';' .. package.cpath):gsub(';;',';')
        end

        -- Load and execute commands given on the command-line
    4   if cliArgs.e then
    4     for k,v in ipairs(cliArgs.e) do
****0       loadstring(v)()
          end
        end

        -- watch for test errors and failures
    4   local failures = 0
    4   local errors = 0
    4   local quitOnError = not cliArgs['keep-going']

    8   busted.subscribe({ 'error', 'output' }, function(element, parent, message)
****0     io.stderr:write(appName .. ': error: Cannot load output library: ' .. element.name .. '\n' .. message .. '\n')
****0     return nil, true
        end)

    8   busted.subscribe({ 'error', 'helper' }, function(element, parent, message)
****0     io.stderr:write(appName .. ': error: Cannot load helper script: ' .. element.name .. '\n' .. message .. '\n')
****0     return nil, true
        end)

    8   busted.subscribe({ 'error' }, function(element, parent, message)
    2     errors = errors + 1
    2     busted.skipAll = quitOnError
    2     return nil, true
        end)

    8   busted.subscribe({ 'failure' }, function(element, parent, message)
    2     if element.descriptor == 'it' then
    2       failures = failures + 1
          else
****0       errors = errors + 1
          end
    2     busted.skipAll = quitOnError
    2     return nil, true
        end)

        -- Set up randomization options
    4   busted.sort = cliArgs['sort-tests']
    4   busted.randomize = cliArgs['shuffle-tests']
    4   busted.randomseed = tonumber(cliArgs.seed) or utils.urandom() or os.time()

        -- Set up output handler to listen to events
    8   outputHandlerLoader(busted, cliArgs.output, {
    4     defaultOutput = options.output,
    4     enableSound = cliArgs['enable-sound'],
    4     verbose = cliArgs.verbose,
    4     suppressPending = cliArgs['suppress-pending'],
    4     language = cliArgs.lang,
    4     deferPrint = cliArgs['defer-print'],
    4     arguments = cliArgs.Xoutput,
        })

        -- Pre-load the LuaJIT 'ffi' module if applicable
    4   local isJit = (tostring(assert):match('builtin') ~= nil)
    4   if isJit then
          -- pre-load the ffi module, such that it becomes part of the environment
          -- and Busted will not try to GC and reload it. The ffi is not suited
          -- for that and will occasionally segfault if done so.
****0     local ffi = require "ffi"

          -- Now patch ffi.cdef to only be called once with each definition, as it
          -- will error on re-registering.
****0     local old_cdef = ffi.cdef
****0     local exists = {}
          ffi.cdef = function(def)
****0       if exists[def] then return end
****0       exists[def] = true
****0       return old_cdef(def)
          end
        end

        -- Set up helper script
    4   if cliArgs.helper and cliArgs.helper ~= '' then
****0     helperLoader(busted, cliArgs.helper, {
            verbose = cliArgs.verbose,
            language = cliArgs.lang,
****0       arguments = cliArgs.Xhelper
          })
        end

        -- Load tag and test filters
    8   filterLoader(busted, {
    4     tags = cliArgs.tags,
    4     excludeTags = cliArgs['exclude-tags'],
    4     filter = cliArgs.filter,
    4     filterOut = cliArgs['filter-out'],
    4     list = cliArgs.list,
    4     nokeepgoing = not cliArgs['keep-going'],
    4     suppressPending = cliArgs['suppress-pending'],
        })

    4   if cliArgs.ROOT then
          -- Load test directories/files
    4     local rootFiles = cliArgs.ROOT
    4     local patterns = cliArgs.pattern
    4     local testFileLoader = require 'busted.modules.test_file_loader'(busted, cliArgs.loaders)
    8     testFileLoader(rootFiles, patterns, {
    4       excludes = cliArgs['exclude-pattern'],
    4       verbose = cliArgs.verbose,
    4       recursive = cliArgs['recursive'],
    4     })
        else
          -- Running standalone, use standalone loader
****0     local testFileLoader = require 'busted.modules.standalone_loader'(busted)
****0     testFileLoader(info, { verbose = cliArgs.verbose })
        end

    4   local runs = cliArgs['repeat']
    4   local execute = require 'busted.execute'(busted)
    8   execute(runs, {
    4     seed = cliArgs.seed,
    4     shuffle = cliArgs['shuffle-files'],
    4     sort = cliArgs['sort-files'],
        })

    4   busted.publish({ 'exit' })

    4   if options.standalone or failures > 0 or errors > 0 then
    4     exit(failures + errors, forceExit)
        end
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/status.lua
==============================================================================
      local function get_status(status)
  244   local smap = {
  244     ['success'] = 'success',
  244     ['pending'] = 'pending',
  244     ['failure'] = 'failure',
  244     ['error'] = 'error',
  244     ['true'] = 'success',
  244     ['false'] = 'failure',
  244     ['nil'] = 'error',
        }
  244   return smap[tostring(status)] or 'error'
      end

      return function(inital_status)
  226   local objstat = get_status(inital_status)
  226   local obj = {
  366     success = function(self) return (objstat == 'success') end,
  226     pending = function(self) return (objstat == 'pending') end,
  226     failure = function(self) return (objstat == 'failure') end,
  226     error   = function(self) return (objstat == 'error') end,

          get = function(self)
****0       return objstat
          end,

          set = function(self, status)
****0       objstat = get_status(status)
          end,

          update = function(self, status)
            -- prefer current failure/error status over new status
   18       status = get_status(status)
   18       if objstat == 'success' or (objstat == 'pending' and status ~= 'success') then
   18         objstat = status
            end
          end
        }

  452   return setmetatable(obj, {
  226     __index = {},
  262     __tostring = function(self) return objstat end
        })
      end

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/busted/utils.lua
==============================================================================
****0 return {
        copy_interpreter_args = function(arguments)
          -- copy non-positive command-line args auto-inserted by Lua interpreter
    4     if arguments and _G.arg then
    4       local i = 0
   20       while _G.arg[i] do
   16         arguments[i] = _G.arg[i]
   16         i = i - 1
            end
          end
        end,

        split = require 'pl.utils'.split,

        shuffle = function(t, seed)
****0     if seed then math.randomseed(seed) end
****0     local n = #t
****0     while n >= 2 do
****0       local k = math.random(n)
****0       t[n], t[k] = t[k], t[n]
****0       n = n - 1
          end
****0     return t
        end,

        urandom = function()
    4     local f = io.open('/dev/urandom', 'rb')
    4     if not f then return nil end
    4     local s = f:read(4) f:close()
    4     local bytes = {s:byte(1, 4)}
    4     local value = 0
   20     for _, v in ipairs(bytes) do
   16       value = value * 256 + v
          end
    4     return value
        end,
      }

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/luassert/assert.lua
==============================================================================
****0 local s = require 'say'
****0 local astate = require 'luassert.state'
****0 local util = require 'luassert.util'
****0 local unpack = require 'luassert.compatibility'.unpack
      local obj   -- the returned module table
****0 local level_mt = {}

      -- list of namespaces
****0 local namespace = require 'luassert.namespaces'

      local function geterror(assertion_message, failure_message, args)
    2   if util.hastostring(failure_message) then
****0     failure_message = tostring(failure_message)
    2   elseif failure_message ~= nil then
****0     failure_message = astate.format_argument(failure_message)
        end
    2   local message = s(assertion_message, obj:format(args))
    2   if message and failure_message then
****0     message = failure_message .. "\n" .. message
        end
    2   return message or failure_message
      end

****0 local __state_meta = {

        __call = function(self, ...)
   18     local keys = util.extract_keys("assertion", self.tokens)

          local assertion

   50     for _, key in ipairs(keys) do
   32       assertion = namespace.assertion[key] or assertion
          end

   18     if assertion then
   50       for _, key in ipairs(keys) do
   32         if namespace.modifier[key] then
   14           namespace.modifier[key].callback(self)
              end
            end

   18       local arguments = {...}
   18       arguments.n = select('#', ...) -- add argument count for trailing nils
   18       local val, retargs = assertion.callback(self, arguments, util.errorlevel())

   18       if not val == self.mod then
    2         local message = assertion.positive_message
    2         if not self.mod then
****0           message = assertion.negative_message
              end
    2         local err = geterror(message, rawget(self,"failure_message"), arguments)
    2         error(err or "assertion failed!", util.errorlevel())
            end

   16       if retargs then
****0         return unpack(retargs)
            end
   16       return ...
          else
****0       local arguments = {...}
****0       arguments.n = select('#', ...)
****0       self.tokens = {}

****0       for _, key in ipairs(keys) do
****0         if namespace.modifier[key] then
****0           namespace.modifier[key].callback(self, arguments, util.errorlevel())
              end
            end
          end

****0     return self
        end,

        __index = function(self, key)
   64     for token in key:lower():gmatch('[^_]+') do
   32       table.insert(self.tokens, token)
          end

   32     return self
        end
      }

****0 obj = {
   18   state = function() return setmetatable({mod=true, tokens={}}, __state_meta) end,

        -- registers a function in namespace
        register = function(self, nspace, name, callback, positive_message, negative_message)
****0     local lowername = name:lower()
****0     if not namespace[nspace] then
****0       namespace[nspace] = {}
          end
****0     namespace[nspace][lowername] = {
            callback = callback,
            name = lowername,
            positive_message=positive_message,
****0       negative_message=negative_message
          }
        end,

        -- unregisters a function in a namespace
        unregister = function(self, nspace, name)
****0     local lowername = name:lower()
****0     if not namespace[nspace] then
****0       namespace[nspace] = {}
          end
****0     namespace[nspace][lowername] = nil
        end,

        -- registers a formatter
        -- a formatter takes a single argument, and converts it to a string, or returns nil if it cannot format the argument
        add_formatter = function(self, callback)
****0     astate.add_formatter(callback)
        end,

        -- unregisters a formatter
        remove_formatter = function(self, fmtr)
****0     astate.remove_formatter(fmtr)
        end,

        format = function(self, args)
          -- args.n specifies the number of arguments in case of 'trailing nil' arguments which get lost
    2     local nofmt = args.nofmt or {}  -- arguments in this list should not be formatted
    2     local fmtargs = args.fmtargs or {} -- additional arguments to be passed to formatter
    6     for i = 1, (args.n or #args) do -- cannot use pairs because table might have nils
    4       if not nofmt[i] then
    4         local val = args[i]
    4         local valfmt = astate.format_argument(val, nil, fmtargs[i])
    4         if valfmt == nil then valfmt = tostring(val) end -- no formatter found
    4         args[i] = valfmt
            end
          end
    2     return args
        end,

        set_parameter = function(self, name, value)
****0     astate.set_parameter(name, value)
        end,
        
        get_parameter = function(self, name)
   16     return astate.get_parameter(name)
        end,  
        
        add_spy = function(self, spy)
****0     astate.add_spy(spy)
        end,
        
        snapshot = function(self)
****0     return astate.snapshot()
        end,
        
        level = function(self, level)
****0     return setmetatable({
****0         level = level
****0       }, level_mt)
        end,
        
        -- returns the level if a level-value, otherwise nil
        get_level = function(self, level)
****0     if getmetatable(level) ~= level_mt then
****0       return nil -- not a valid error-level
          end
****0     return level.level
        end,
      }

****0 local __meta = {

        __call = function(self, bool, message, level, ...)
   14     if not bool then
****0       local err_level = (self:get_level(level) or 1) + 1
****0       error(message or "assertion failed!", err_level)
          end
   14     return bool , message , level , ...
        end,

        __index = function(self, key)
   18     return rawget(self, key) or self.state()[key]
        end,

      }

****0 return setmetatable(obj, __meta)

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/luassert/assertions.lua
==============================================================================
      -- module will not return anything, only register assertions with the main assert engine

      -- assertions take 2 parameters;
      -- 1) state
      -- 2) arguments list. The list has a member 'n' with the argument count to check for trailing nils
      -- 3) level The level of the error position relative to the called function
      -- returns; boolean; whether assertion passed

****0 local assert = require('luassert.assert')
****0 local astate = require ('luassert.state')
****0 local util = require ('luassert.util')
****0 local s = require('say')

      local function format(val)
****0   return astate.format_argument(val) or tostring(val)
      end

      local function set_failure_message(state, message)
   18   if message ~= nil then
****0     state.failure_message = message
        end
      end

      local function unique(state, arguments, level)
****0   local list = arguments[1]
        local deep
****0   local argcnt = arguments.n
****0   if type(arguments[2]) == "boolean" or (arguments[2] == nil and argcnt > 2) then
****0     deep = arguments[2]
****0     set_failure_message(state, arguments[3])
        else
****0     if type(arguments[3]) == "boolean" then
****0       deep = arguments[3]
          end
****0     set_failure_message(state, arguments[2])
        end
****0   for k,v in pairs(list) do
****0     for k2, v2 in pairs(list) do
****0       if k ~= k2 then
****0         if deep and util.deepcompare(v, v2, true) then
****0           return false
              else
****0           if v == v2 then
****0             return false
                end
              end
            end
          end
        end
****0   return true
      end

      local function near(state, arguments, level)
****0   local level = (level or 1) + 1
****0   local argcnt = arguments.n
****0   assert(argcnt > 2, s("assertion.internal.argtolittle", { "near", 3, tostring(argcnt) }), level)
****0   local expected = tonumber(arguments[1])
****0   local actual = tonumber(arguments[2])
****0   local tolerance = tonumber(arguments[3])
****0   local numbertype = "number or object convertible to a number"
****0   assert(expected, s("assertion.internal.badargtype", { 1, "near", numbertype, format(arguments[1]) }), level)
****0   assert(actual, s("assertion.internal.badargtype", { 2, "near", numbertype, format(arguments[2]) }), level)
****0   assert(tolerance, s("assertion.internal.badargtype", { 3, "near", numbertype, format(arguments[3]) }), level)
        -- switch arguments for proper output message
****0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
****0   arguments[3] = tolerance
****0   arguments.nofmt = arguments.nofmt or {}
****0   arguments.nofmt[3] = true
****0   set_failure_message(state, arguments[4])
****0   return (actual >= expected - tolerance and actual <= expected + tolerance)
      end

      local function matches(state, arguments, level)
****0   local level = (level or 1) + 1
****0   local argcnt = arguments.n
****0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "matches", 2, tostring(argcnt) }), level)
****0   local pattern = arguments[1]
        local actual = nil
****0   if util.hastostring(arguments[2]) or type(arguments[2]) == "number" then
****0     actual = tostring(arguments[2])
        end
        local err_message
****0   local init_arg_num = 3
****0   for i=3,argcnt,1 do
****0     if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
****0       if i == 3 then init_arg_num = init_arg_num + 1 end
****0       err_message = util.tremove(arguments, i)
            break
          end
        end
****0   local init = arguments[3]
****0   local plain = arguments[4]
****0   local stringtype = "string or object convertible to a string"
****0   assert(type(pattern) == "string", s("assertion.internal.badargtype", { 1, "matches", "string", type(arguments[1]) }), level)
****0   assert(actual, s("assertion.internal.badargtype", { 2, "matches", stringtype, format(arguments[2]) }), level)
****0   assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)
        -- switch arguments for proper output message
****0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
****0   set_failure_message(state, err_message)
        local retargs
        local ok
****0   if plain then
****0     ok = (actual:find(pattern, init, plain) ~= nil)
****0     retargs = ok and { pattern } or {}
        else
****0     retargs = { actual:match(pattern, init) }
****0     ok = (retargs[1] ~= nil)
        end
****0   return ok, retargs
      end

      local function equals(state, arguments, level)
    8   local level = (level or 1) + 1
    8   local argcnt = arguments.n
    8   assert(argcnt > 1, s("assertion.internal.argtolittle", { "equals", 2, tostring(argcnt) }), level)
    8   local result =  arguments[1] == arguments[2]
        -- switch arguments for proper output message
    8   util.tinsert(arguments, 1, util.tremove(arguments, 2))
    8   set_failure_message(state, arguments[3])
    8   return result
      end

      local function same(state, arguments, level)
    6   local level = (level or 1) + 1
    6   local argcnt = arguments.n
    6   assert(argcnt > 1, s("assertion.internal.argtolittle", { "same", 2, tostring(argcnt) }), level)
    6   if type(arguments[1]) == 'table' and type(arguments[2]) == 'table' then
    6     local result, crumbs = util.deepcompare(arguments[1], arguments[2], true)
          -- switch arguments for proper output message
    6     util.tinsert(arguments, 1, util.tremove(arguments, 2))
    6     arguments.fmtargs = arguments.fmtargs or {}
    6     arguments.fmtargs[1] = { crumbs = crumbs }
    6     arguments.fmtargs[2] = { crumbs = crumbs }
    6     set_failure_message(state, arguments[3])
    6     return result
        end
****0   local result = arguments[1] == arguments[2]
        -- switch arguments for proper output message
****0   util.tinsert(arguments, 1, util.tremove(arguments, 2))
****0   set_failure_message(state, arguments[3])
****0   return result
      end

      local function truthy(state, arguments, level)
****0   set_failure_message(state, arguments[2])
****0   return arguments[1] ~= false and arguments[1] ~= nil
      end

      local function falsy(state, arguments, level)
****0   return not truthy(state, arguments, level)
      end

      local function has_error(state, arguments, level)
****0   local level = (level or 1) + 1
****0   local retargs = util.shallowcopy(arguments)
****0   local func = arguments[1]
****0   local err_expected = arguments[2]
****0   local failure_message = arguments[3]
****0   assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error", "function or callable object", type(func) }), level)
****0   local ok, err_actual = pcall(func)
****0   if type(err_actual) == 'string' then
          -- remove 'path/to/file:line: ' from string
****0     err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
        end
****0   retargs[1] = err_actual
****0   arguments.nofmt = {}
****0   arguments.n = 2
****0   arguments[1] = (ok and '(no error)' or err_actual)
****0   arguments[2] = (err_expected == nil and '(error)' or err_expected)
****0   arguments.nofmt[1] = ok
****0   arguments.nofmt[2] = (err_expected == nil)
****0   set_failure_message(state, failure_message)

****0   if ok or err_expected == nil then
****0     return not ok, retargs
        end
****0   if type(err_expected) == 'string' then
          -- err_actual must be (convertible to) a string
****0     if util.hastostring(err_actual) then
****0       err_actual = tostring(err_actual)
****0       retargs[1] = err_actual
          end
****0     if type(err_actual) == 'string' then
****0       return err_expected == err_actual, retargs
          end
****0   elseif type(err_expected) == 'number' then
****0     if type(err_actual) == 'string' then
****0       return tostring(err_expected) == tostring(tonumber(err_actual)), retargs
          end
        end
****0   return same(state, {err_expected, err_actual, ["n"] = 2}), retargs
      end

      local function error_matches(state, arguments, level)
****0   local level = (level or 1) + 1
****0   local retargs = util.shallowcopy(arguments)
****0   local argcnt = arguments.n
****0   local func = arguments[1]
****0   local pattern = arguments[2]
****0   assert(argcnt > 1, s("assertion.internal.argtolittle", { "error_matches", 2, tostring(argcnt) }), level)
****0   assert(util.callable(func), s("assertion.internal.badargtype", { 1, "error_matches", "function or callable object", type(func) }), level)
****0   assert(pattern == nil or type(pattern) == "string", s("assertion.internal.badargtype", { 2, "error", "string", type(pattern) }), level)

        local failure_message
****0   local init_arg_num = 3
****0   for i=3,argcnt,1 do
****0     if arguments[i] and type(arguments[i]) ~= "boolean" and not tonumber(arguments[i]) then
****0       if i == 3 then init_arg_num = init_arg_num + 1 end
****0       failure_message = util.tremove(arguments, i)
            break
          end
        end
****0   local init = arguments[3]
****0   local plain = arguments[4]
****0   assert(init == nil or tonumber(init), s("assertion.internal.badargtype", { init_arg_num, "matches", "number", type(arguments[3]) }), level)

****0   local ok, err_actual = pcall(func)
****0   if type(err_actual) == 'string' then
          -- remove 'path/to/file:line: ' from string
****0     err_actual = err_actual:gsub('^.-:%d+: ', '', 1)
        end
****0   retargs[1] = err_actual
****0   arguments.nofmt = {}
****0   arguments.n = 2
****0   arguments[1] = (ok and '(no error)' or err_actual)
****0   arguments[2] = pattern
****0   arguments.nofmt[1] = ok
****0   arguments.nofmt[2] = false
****0   set_failure_message(state, failure_message)

****0   if ok then return not ok, retargs end
****0   if err_actual == nil and pattern == nil then
****0     return true, {}
        end

        -- err_actual must be (convertible to) a string
****0   if util.hastostring(err_actual) then
****0     err_actual = tostring(err_actual)
****0     retargs[1] = err_actual
        end
****0   if type(err_actual) == 'string' then
          local ok
          local retargs_ok
****0     if plain then
****0       retargs_ok = { pattern }
****0       ok = (err_actual:find(pattern, init, plain) ~= nil)
          else
****0       retargs_ok = { err_actual:match(pattern, init) }
****0       ok = (retargs_ok[1] ~= nil)
          end
****0     if ok then retargs = retargs_ok end
****0     return ok, retargs
        end

****0   return false, retargs
      end

      local function is_true(state, arguments, level)
    4   util.tinsert(arguments, 2, true)
    4   set_failure_message(state, arguments[3])
    4   return arguments[1] == arguments[2]
      end

      local function is_false(state, arguments, level)
****0   util.tinsert(arguments, 2, false)
****0   set_failure_message(state, arguments[3])
****0   return arguments[1] == arguments[2]
      end

      local function is_type(state, arguments, level, etype)
****0   util.tinsert(arguments, 2, "type " .. etype)
****0   arguments.nofmt = arguments.nofmt or {}
****0   arguments.nofmt[2] = true
****0   set_failure_message(state, arguments[3])
****0   return arguments.n > 1 and type(arguments[1]) == etype
      end

      local function returned_arguments(state, arguments, level)
****0   arguments[1] = tostring(arguments[1])
****0   arguments[2] = tostring(arguments.n - 1)
****0   arguments.nofmt = arguments.nofmt or {}
****0   arguments.nofmt[1] = true
****0   arguments.nofmt[2] = true
****0   if arguments.n < 2 then arguments.n = 2 end
****0   return arguments[1] == arguments[2]
      end

      local function set_message(state, arguments, level)
****0   state.failure_message = arguments[1]
      end

****0 local function is_boolean(state, arguments, level)  return is_type(state, arguments, level, "boolean")  end
****0 local function is_number(state, arguments, level)   return is_type(state, arguments, level, "number")   end
****0 local function is_string(state, arguments, level)   return is_type(state, arguments, level, "string")   end
****0 local function is_table(state, arguments, level)    return is_type(state, arguments, level, "table")    end
****0 local function is_nil(state, arguments, level)      return is_type(state, arguments, level, "nil")      end
****0 local function is_userdata(state, arguments, level) return is_type(state, arguments, level, "userdata") end
****0 local function is_function(state, arguments, level) return is_type(state, arguments, level, "function") end
****0 local function is_thread(state, arguments, level)   return is_type(state, arguments, level, "thread")   end

****0 assert:register("modifier", "message", set_message)
****0 assert:register("assertion", "true", is_true, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "false", is_false, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "boolean", is_boolean, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "number", is_number, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "string", is_string, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "table", is_table, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "nil", is_nil, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "userdata", is_userdata, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "function", is_function, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "thread", is_thread, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "returned_arguments", returned_arguments, "assertion.returned_arguments.positive", "assertion.returned_arguments.negative")

****0 assert:register("assertion", "same", same, "assertion.same.positive", "assertion.same.negative")
****0 assert:register("assertion", "matches", matches, "assertion.matches.positive", "assertion.matches.negative")
****0 assert:register("assertion", "match", matches, "assertion.matches.positive", "assertion.matches.negative")
****0 assert:register("assertion", "near", near, "assertion.near.positive", "assertion.near.negative")
****0 assert:register("assertion", "equals", equals, "assertion.equals.positive", "assertion.equals.negative")
****0 assert:register("assertion", "equal", equals, "assertion.equals.positive", "assertion.equals.negative")
****0 assert:register("assertion", "unique", unique, "assertion.unique.positive", "assertion.unique.negative")
****0 assert:register("assertion", "error", has_error, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "errors", has_error, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "error_matches", error_matches, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "error_match", error_matches, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "matches_error", error_matches, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "match_error", error_matches, "assertion.error.positive", "assertion.error.negative")
****0 assert:register("assertion", "truthy", truthy, "assertion.truthy.positive", "assertion.truthy.negative")
****0 assert:register("assertion", "falsy", falsy, "assertion.falsy.positive", "assertion.falsy.negative")

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/luassert/formatters/init.lua
==============================================================================
      -- module will not return anything, only register formatters with the main assert engine
****0 local assert = require('luassert.assert')

****0 local colors = setmetatable({
    8   none = function(c) return c end
****0 },{ __index = function(self, key)
****0   local ok, term = pcall(require, 'term')
****0   local isatty = io.type(io.stdout) == 'file' and ok and term.isatty(io.stdout)
****0   if not ok or not isatty or not term.colors then
****0     return function(c) return c end
        end
        return function(c)
****0     for token in key:gmatch("[^%.]+") do
****0       c = term.colors[token](c)
          end
****0     return c
        end
      end
      })

      local function fmt_string(arg)
****0   if type(arg) == "string" then
****0     return string.format("(string) '%s'", arg)
        end
      end

      -- A version of tostring which formats numbers more precisely.
      local function tostr(arg)
   56   if type(arg) ~= "number" then
   56     return tostring(arg)
        end

****0   if arg ~= arg then
****0     return "NaN"
****0   elseif arg == 1/0 then
****0     return "Inf"
****0   elseif arg == -1/0 then
****0     return "-Inf"
        end

****0   local str = string.format("%.20g", arg)

****0   if math.type and math.type(arg) == "float" and not str:find("[%.,]") then
          -- Number is a float but looks like an integer.
          -- Insert ".0" after first run of digits.
****0     str = str:gsub("%d+", "%0.0", 1)
        end

****0   return str
      end

      local function fmt_number(arg)
****0   if type(arg) == "number" then
****0     return string.format("(number) %s", tostr(arg))
        end
      end

      local function fmt_boolean(arg)
****0   if type(arg) == "boolean" then
****0     return string.format("(boolean) %s", tostring(arg))
        end
      end

      local function fmt_nil(arg)
****0   if type(arg) == "nil" then
****0     return "(nil)"
        end
      end

****0 local type_priorities = {
        number = 1,
        boolean = 2,
        string = 3,
        table = 4,
        ["function"] = 5,
        userdata = 6,
****0   thread = 7
      }

      local function is_in_array_part(key, length)
   68   return type(key) == "number" and 1 <= key and key <= length and math.floor(key) == key
      end

      local function get_sorted_keys(t)
   12   local keys = {}
   12   local nkeys = 0

   40   for key in pairs(t) do
   28     nkeys = nkeys + 1
   28     keys[nkeys] = key
        end

   12   local length = #t

        local function key_comparator(key1, key2)
   34     local type1, type2 = type(key1), type(key2)
   34     local priority1 = is_in_array_part(key1, length) and 0 or type_priorities[type1] or 8
   34     local priority2 = is_in_array_part(key2, length) and 0 or type_priorities[type2] or 8

   34     if priority1 == priority2 then
   34       if type1 == "string" or type1 == "number" then
   34         return key1 < key2
****0       elseif type1 == "boolean" then
****0         return key1  -- put true before false
            end
          else
****0       return priority1 < priority2
          end
        end

   12   table.sort(keys, key_comparator)
   12   return keys, nkeys
      end

      local function fmt_table(arg, fmtargs)
    4   if type(arg) ~= "table" then
****0     return
        end

    4   local tmax = assert:get_parameter("TableFormatLevel")
    4   local showrec = assert:get_parameter("TableFormatShowRecursion")
    4   local errchar = assert:get_parameter("TableErrorHighlightCharacter") or ""
    4   local errcolor = assert:get_parameter("TableErrorHighlightColor") or "none"
    4   local crumbs = fmtargs and fmtargs.crumbs or {}
    4   local cache = {}
        local type_desc

    4   if getmetatable(arg) == nil then
    4     type_desc = "(" .. tostring(arg) .. ") "
****0   elseif not pcall(setmetatable, arg, getmetatable(arg)) then
          -- cannot set same metatable, so it is protected, skip id
****0     type_desc = "(table) "
        else
          -- unprotected metatable, temporary remove the mt
****0     local mt = getmetatable(arg)
****0     setmetatable(arg, nil)
****0     type_desc = "(" .. tostring(arg) .. ") "
****0     setmetatable(arg, mt)
        end

        local function ft(t, l, with_crumbs)
   12     if showrec and cache[t] and cache[t] > 0 then
****0       return "{ ... recursive }"
          end

   12     if next(t) == nil then
****0       return "{ }"
          end

   12     if l > tmax and tmax >= 0 then
****0       return "{ ... more }"
          end

   12     local result = "{"
   12     local keys, nkeys = get_sorted_keys(t)

   12     cache[t] = (cache[t] or 0) + 1
   12     local crumb = crumbs[#crumbs - l + 1]

   40     for i = 1, nkeys do
   28       local k = keys[i]
   28       local v = t[k]
   28       local use_crumbs = with_crumbs and k == crumb

   28       if type(v) == "table" then
    8         v = ft(v, l + 1, use_crumbs)
   20       elseif type(v) == "string" then
   16         v = "'"..v.."'"
            end

   28       local ch = use_crumbs and errchar or ""
   28       local indent = string.rep(" ",l * 2 - ch:len())
   28       local mark = (ch:len() == 0 and "" or colors[errcolor](ch))
   28       result = result .. string.format("\n%s%s[%s] = %s", indent, mark, tostr(k), tostr(v))
          end

   12     cache[t] = cache[t] - 1

   12     return result .. " }"
        end

    4   return type_desc .. ft(arg, 1, true)
      end

      local function fmt_function(arg)
    4   if type(arg) == "function" then
****0     local debug_info = debug.getinfo(arg)
****0     return string.format("%s @ line %s in %s", tostring(arg), tostring(debug_info.linedefined), tostring(debug_info.source))
        end
      end

      local function fmt_userdata(arg)
    4   if type(arg) == "userdata" then
****0     return string.format("(userdata) '%s'", tostring(arg))
        end
      end

      local function fmt_thread(arg)
    4   if type(arg) == "thread" then
****0     return string.format("(thread) '%s'", tostring(arg))
        end
      end

****0 assert:add_formatter(fmt_string)
****0 assert:add_formatter(fmt_number)
****0 assert:add_formatter(fmt_boolean)
****0 assert:add_formatter(fmt_nil)
****0 assert:add_formatter(fmt_table)
****0 assert:add_formatter(fmt_function)
****0 assert:add_formatter(fmt_userdata)
****0 assert:add_formatter(fmt_thread)
      -- Set default table display depth for table formatter
****0 assert:set_parameter("TableFormatLevel", 3)
****0 assert:set_parameter("TableFormatShowRecursion", false)
****0 assert:set_parameter("TableErrorHighlightCharacter", "*")
****0 assert:set_parameter("TableErrorHighlightColor", "none")

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/luassert/modifiers.lua
==============================================================================
      -- module will not return anything, only register assertions/modifiers with the main assert engine
****0 local assert = require('luassert.assert')

      local function is(state)
   14   return state
      end

      local function is_not(state)
****0   state.mod = not state.mod
****0   return state
      end

****0 assert:register("modifier", "is", is)
****0 assert:register("modifier", "are", is)
****0 assert:register("modifier", "was", is)
****0 assert:register("modifier", "has", is)
****0 assert:register("modifier", "does", is)
****0 assert:register("modifier", "not", is_not)
****0 assert:register("modifier", "no", is_not)

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/luassert/state.lua
==============================================================================
      -- maintains a state of the assert engine in a linked-list fashion
      -- records; formatters, parameters, spies and stubs

****0 local state_mt = {
        __call = function(self)
****0     self:revert()
        end
      }

****0 local spies_mt = { __mode = "kv" }

****0 local nilvalue = {} -- unique ID to refer to nil values for parameters

      -- will hold the current state
      local current

      -- exported module table
****0 local state = {}

      ------------------------------------------------------
      -- Reverts to a (specific) snapshot.
      -- @param self (optional) the snapshot to revert to. If not provided, it will revert to the last snapshot.
      state.revert = function(self)
****0   if not self then
          -- no snapshot given, so move 1 up
****0     self = current
****0     if not self.previous then
            -- top of list, no previous one, nothing to do
****0       return
          end
        end
****0   if getmetatable(self) ~= state_mt then error("Value provided is not a valid snapshot", 2) end
        
****0   if self.next then
****0     self.next:revert()
        end
        -- revert formatters in 'last'
****0   self.formatters = {}
        -- revert parameters in 'last'
****0   self.parameters = {}
        -- revert spies/stubs in 'last'
****0   for s,_ in pairs(self.spies) do
****0     self.spies[s] = nil
****0     s:revert()
        end
****0   setmetatable(self, nil) -- invalidate as a snapshot
****0   current = self.previous
****0   current.next = nil
      end

      ------------------------------------------------------
      -- Creates a new snapshot.
      -- @return snapshot table
      state.snapshot = function()
****0   local s = current
****0   local new = setmetatable ({
          formatters = {},
          parameters = {},
          spies = setmetatable({}, spies_mt),
          previous = current,
          revert = state.revert,
****0   }, state_mt)
****0   if current then current.next = new end
****0   current = new
****0   return current
      end


      --  FORMATTERS
      state.add_formatter = function(callback)
****0   table.insert(current.formatters, 1, callback)
      end

      state.remove_formatter = function(callback, s)
****0   s = s or current
****0   for i, v in ipairs(s.formatters) do
****0     if v == callback then
****0       table.remove(s.formatters, i)
            break
          end
        end
        -- wasn't found, so traverse up 1 state
****0   if s.previous then
****0     state.remove_formatter(callback, s.previous)
        end
      end

      state.format_argument = function(val, s, fmtargs)
    4   s = s or current
   16   for _, fmt in ipairs(s.formatters) do
   16     local valfmt = fmt(val, fmtargs)
   16     if valfmt ~= nil then return valfmt end
        end
        -- nothing found, check snapshot 1 up in list
****0   if s.previous then
****0     return state.format_argument(val, s.previous, fmtargs)
        end
****0   return nil -- end of list, couldn't format
      end


      --  PARAMETERS
      state.set_parameter = function(name, value)
****0   if value == nil then value = nilvalue end
****0   current.parameters[name] = value
      end

      state.get_parameter = function(name, s)
   16   s = s or current
   16   local val = s.parameters[name]
   16   if val == nil and s.previous then
          -- not found, so check 1 up in list
****0     return state.get_parameter(name, s.previous)
        end
   16   if val ~= nilvalue then
   16     return val
        end
****0   return nil
      end

      --  SPIES / STUBS
      state.add_spy = function(spy)
****0   current.spies[spy] = true
      end

****0 state.snapshot()  -- create initial state

****0 return state

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/luassert/util.lua
==============================================================================
****0 local util = {}
****0 function util.deepcompare(t1,t2,ignore_mt,cycles,thresh1,thresh2)
   39   local ty1 = type(t1)
   39   local ty2 = type(t2)
        -- non-table types can be directly compared
   39   if ty1 ~= 'table' or ty2 ~= 'table' then return t1 == t2 end
   25   local mt1 = debug.getmetatable(t1)
   25   local mt2 = debug.getmetatable(t2)
        -- would equality be determined by metatable __eq?
   25   if mt1 and mt1 == mt2 and mt1.__eq then
          -- then use that unless asked not to
****0     if not ignore_mt then return t1 == t2 end
        else -- we can skip the deep comparison below if t1 and t2 share identity
   25     if rawequal(t1, t2) then return true end
        end

        -- handle recursive tables
   25   cycles = cycles or {{},{}}
   25   thresh1, thresh2 = (thresh1 or 1), (thresh2 or 1)
   25   cycles[1][t1] = (cycles[1][t1] or 0)
   25   cycles[2][t2] = (cycles[2][t2] or 0)
   25   if cycles[1][t1] == 1 or cycles[2][t2] == 1 then
****0     thresh1 = cycles[1][t1] + 1
****0     thresh2 = cycles[2][t2] + 1
        end
   25   if cycles[1][t1] > thresh1 and cycles[2][t2] > thresh2 then
****0     return true
        end

   25   cycles[1][t1] = cycles[1][t1] + 1
   25   cycles[2][t2] = cycles[2][t2] + 1

   54   for k1,v1 in next, t1 do
   33     local v2 = t2[k1]
   33     if v2 == nil then
****0       return false, {k1}
          end

   33     local same, crumbs = util.deepcompare(v1,v2,nil,cycles,thresh1,thresh2)
   33     if not same then
    4       crumbs = crumbs or {}
    4       table.insert(crumbs, k1)
    4       return false, crumbs
          end
        end
   44   for k2,_ in next, t2 do
          -- only check whether each element has a t1 counterpart, actual comparison
          -- has been done in first loop above
   23     if t1[k2] == nil then return false, {k2} end
        end

   21   cycles[1][t1] = cycles[1][t1] - 1
   21   cycles[2][t2] = cycles[2][t2] - 1

   21   return true
      end

****0 function util.shallowcopy(t)
****0   if type(t) ~= "table" then return t end
****0   local copy = {}
****0   for k,v in next, t do
****0     copy[k] = v
        end
****0   return copy
      end

****0 function util.deepcopy(t, deepmt, cache)
****0   local spy = require 'luassert.spy'
****0   if type(t) ~= "table" then return t end
****0   local copy = {}

        -- handle recursive tables
****0   local cache = cache or {}
****0   if cache[t] then return cache[t] end
****0   cache[t] = copy

****0   for k,v in next, t do
****0     copy[k] = (spy.is_spy(v) and v or util.deepcopy(v, deepmt, cache))
        end
****0   if deepmt then
****0     debug.setmetatable(copy, util.deepcopy(debug.getmetatable(t, nil, cache)))
        else
****0     debug.setmetatable(copy, debug.getmetatable(t))
        end
****0   return copy
      end

      -----------------------------------------------
      -- Copies arguments as a list of arguments
      -- @param args the arguments of which to copy
      -- @return the copy of the arguments
****0 function util.copyargs(args)
****0   local copy = {}
****0   local match = require 'luassert.match'
****0   local spy = require 'luassert.spy'
****0   for k,v in pairs(args) do
****0     copy[k] = ((match.is_matcher(v) or spy.is_spy(v)) and v or util.deepcopy(v))
        end
****0   return { vals = copy, refs = util.shallowcopy(args) }
      end

      -----------------------------------------------
      -- Finds matching arguments in a saved list of arguments
      -- @param argslist list of arguments from which to search
      -- @param args the arguments of which to find a match
      -- @return the matching arguments if a match is found, otherwise nil
****0 function util.matchargs(argslist, args)
        local function matches(t1, t2, t1refs)
****0     local match = require 'luassert.match'
****0     for k1,v1 in pairs(t1) do
****0       local v2 = t2[k1]
****0       if match.is_matcher(v1) then
****0         if not v1(v2) then return false end
****0       elseif match.is_matcher(v2) then
****0         if match.is_ref_matcher(v2) then v1 = t1refs[k1] end
****0         if not v2(v1) then return false end
****0       elseif (v2 == nil or not util.deepcompare(v1,v2)) then
****0         return false
            end
          end
****0     for k2,v2 in pairs(t2) do
            -- only check wether each element has a t1 counterpart, actual comparison
            -- has been done in first loop above
****0       local v1 = t1[k2]
****0       if v1 == nil then
              -- no t1 counterpart, so try to compare using matcher
****0         if match.is_matcher(v2) then
****0           if not v2(v1) then return false end
              else
****0           return false
              end
            end
          end
****0     return true
        end
****0   for k,v in ipairs(argslist) do
****0     if matches(v.vals, args, v.refs) then
****0       return v
          end
        end
****0   return nil
      end

      -----------------------------------------------
      -- table.insert() replacement that respects nil values.
      -- The function will use table field 'n' as indicator of the
      -- table length, if not set, it will be added.
      -- @param t table into which to insert
      -- @param pos (optional) position in table where to insert. NOTE: not optional if you want to insert a nil-value!
      -- @param val value to insert
      -- @return No return values
****0 function util.tinsert(...)
        -- check optional POS value
   18   local args = {...}
   18   local c = select('#',...)
   18   local t = args[1]
   18   local pos = args[2]
   18   local val = args[3]
   18   if c < 3 then
****0     val = pos
****0     pos = nil
        end
        -- set length indicator n if not present (+1)
   18   t.n = (t.n or #t) + 1
   18   if not pos then
****0     pos = t.n
   18   elseif pos > t.n then
          -- out of our range
****0     t[pos] = val
****0     t.n = pos
        end
        -- shift everything up 1 pos
   32   for i = t.n, pos + 1, -1 do
   14     t[i]=t[i-1]
        end
        -- add element to be inserted
   18   t[pos] = val
      end
      -----------------------------------------------
      -- table.remove() replacement that respects nil values.
      -- The function will use table field 'n' as indicator of the
      -- table length, if not set, it will be added.
      -- @param t table from which to remove
      -- @param pos (optional) position in table to remove
      -- @return No return values
****0 function util.tremove(t, pos)
        -- set length indicator n if not present (+1)
   14   t.n = t.n or #t
   14   if not pos then
****0     pos = t.n
   14   elseif pos > t.n then
****0     local removed = t[pos]
          -- out of our range
****0     t[pos] = nil
****0     return removed
        end
   14   local removed = t[pos]
        -- shift everything up 1 pos
   28   for i = pos, t.n do
   14     t[i]=t[i+1]
        end
        -- set size, clean last
   14   t[t.n] = nil
   14   t.n = t.n - 1
   14   return removed
      end

      -----------------------------------------------
      -- Checks an element to be callable.
      -- The type must either be a function or have a metatable
      -- containing an '__call' function.
      -- @param object element to inspect on being callable or not
      -- @return boolean, true if the object is callable
****0 function util.callable(object)
****0   return type(object) == "function" or type((debug.getmetatable(object) or {}).__call) == "function"
      end
      -----------------------------------------------
      -- Checks an element has tostring.
      -- The type must either be a string or have a metatable
      -- containing an '__tostring' function.
      -- @param object element to inspect on having tostring or not
      -- @return boolean, true if the object has tostring
****0 function util.hastostring(object)
    2   return type(object) == "string" or type((debug.getmetatable(object) or {}).__tostring) == "function"
      end

      -----------------------------------------------
      -- Find the first level, not defined in the same file as the caller's
      -- code file to properly report an error.
      -- @param level the level to use as the caller's source file
      -- @return number, the level of which to report an error
****0 function util.errorlevel(level)
   20   local level = (level or 1) + 1 -- add one to get level of the caller
   20   local info = debug.getinfo(level)
   20   local source = (info or {}).source
   20   local file = source
   40   while file and (file == source or source == "=(tail call)") do
   20     level = level + 1
   20     info = debug.getinfo(level)
   20     source = (info or {}).source
        end
   20   if level > 1 then level = level - 1 end -- deduct call to errorlevel() itself
   20   return level
      end

      -----------------------------------------------
      -- Extract modifier and namespace keys from list of tokens.
      -- @param nspace the namespace from which to match tokens
      -- @param tokens list of tokens to search for keys
      -- @return table, list of keys that were extracted
****0 function util.extract_keys(nspace, tokens)
   18   local namespace = require 'luassert.namespaces'

        -- find valid keys by coalescing tokens as needed, starting from the end
   18   local keys = {}
   18   local key = nil
   18   local i = #tokens
   50   while i > 0 do
   32     local token = tokens[i]
   32     key = key and (token .. '_' .. key) or token

          -- find longest matching key in the given namespace
   32     local longkey = i > 1 and (tokens[i-1] .. '_' .. key) or nil
   32     while i > 1 and longkey and namespace[nspace][longkey] do
****0       key = longkey
****0       i = i - 1
****0       token = tokens[i]
****0       longkey = (token .. '_' .. key)
          end

   32     if namespace.modifier[key] or namespace[nspace][key] then
   32       table.insert(keys, 1, key)
   32       key = nil
          end
   32     i = i - 1
        end

        -- if there's anything left we didn't recognize it
   18   if key then
****0     error("luassert: unknown modifier/" .. nspace .. ": '" .. key .."'", util.errorlevel(2))
        end

   18   return keys
      end

****0 return util

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/mediator.lua
==============================================================================
      local function getUniqueId(obj)
  124   return tonumber(tostring(obj):match(':%s*[0xX]*(%x+)'), 16)
      end

      local function Subscriber(fn, options)
  124   local sub = {
  124     options = options or {},
  124     fn = fn,
  124     channel = nil,
          update = function(self, options)
****0       if options then
****0         self.fn = options.fn or self.fn
****0         self.options = options.options or self.options
            end
          end
        }
  124   sub.id = getUniqueId(sub)
  124   return sub
      end

      -- Channel class and functions --

      local function Channel(namespace, parent)
  100   return {
  100     stopped = false,
  100     namespace = namespace,
  100     callbacks = {},
  100     channels = {},
  100     parent = parent,

          addSubscriber = function(self, fn, options)
  124       local callback = Subscriber(fn, options)
  124       local priority = (#self.callbacks + 1)

  124       options = options or {}

  124       if options.priority and
   80         options.priority >= 0 and
   80         options.priority < priority
            then
   60           priority = options.priority
            end

  124       table.insert(self.callbacks, priority, callback)

  124       return callback
          end,

          getSubscriber = function(self, id)
****0       for i=1, #self.callbacks do
****0         local callback = self.callbacks[i]
****0         if callback.id == id then return { index = i, value = callback } end
            end
            local sub
****0       for _, channel in pairs(self.channels) do
****0         sub = channel:getSubscriber(id)
****0         if sub then break end
            end
****0       return sub
          end,

          setPriority = function(self, id, priority)
****0       local callback = self:getSubscriber(id)

****0       if callback.value then
****0         table.remove(self.callbacks, callback.index)
****0         table.insert(self.callbacks, priority, callback.value)
            end
          end,

          addChannel = function(self, namespace)
  100       self.channels[namespace] = Channel(namespace, self)
  100       return self.channels[namespace]
          end,

          hasChannel = function(self, namespace)
****0       return namespace and self.channels[namespace] and true
          end,

          getChannel = function(self, namespace)
  556       return self.channels[namespace] or self:addChannel(namespace)
          end,

          removeSubscriber = function(self, id)
****0       local callback = self:getSubscriber(id)

****0       if callback and callback.value then
****0         for _, channel in pairs(self.channels) do
****0           channel:removeSubscriber(id)
              end

****0         return table.remove(self.callbacks, callback.index)
            end
          end,

          publish = function(self, result, ...)
  592       for i = 1, #self.callbacks do
  248         local callback = self.callbacks[i]

              -- if it doesn't have a predicate, or it does and it's true then run it
  248         if not callback.options.predicate or callback.options.predicate(...) then
                 -- just take the first result and insert it into the result table
  248           local value, continue = callback.fn(...)

  248           if value then table.insert(result, value) end
  248           if not continue then return result end
              end
            end

  344       if parent then
  228         return parent:publish(result, ...)
            else
  116         return result
            end
          end
  100   }
      end

      -- Mediator class and functions --

****0 local Mediator = setmetatable(
      {
        Channel = Channel,
****0   Subscriber = Subscriber
      },
      {
        __call = function (fn, options)
****0     return {
            channel = Channel('root'),

            getChannel = function(self, channelNamespace)
  290         local channel = self.channel

  846         for i=1, #channelNamespace do
  556           channel = channel:getChannel(channelNamespace[i])
              end

  290         return channel
            end,

            subscribe = function(self, channelNamespace, fn, options)
  124         return self:getChannel(channelNamespace):addSubscriber(fn, options)
            end,

            getSubscriber = function(self, id, channelNamespace)
****0         return self:getChannel(channelNamespace):getSubscriber(id)
            end,

            removeSubscriber = function(self, id, channelNamespace)
****0         return self:getChannel(channelNamespace):removeSubscriber(id)
            end,

            publish = function(self, channelNamespace, ...)
  166         return self:getChannel(channelNamespace):publish({}, ...)
            end
          }
        end
      })
****0 return Mediator

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/pl/List.lua
==============================================================================
      --- Python-style list class.
      --
      -- **Please Note**: methods that change the list will return the list.
      -- This is to allow for method chaining, but please note that `ls = ls:sort()`
      -- does not mean that a new copy of the list is made. In-place (mutable) methods
      -- are marked as returning 'the list' in this documentation.
      --
      -- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}
      --
      -- See <a href="http://www.python.org/doc/current/tut/tut.html">http://www.python.org/doc/current/tut/tut.html</a>, section 5.1
      --
      -- **Note**: The comments before some of the functions are from the Python docs
      -- and contain Python code.
      --
      -- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.
      --
      -- Dependencies: `pl.utils`, `pl.tablex`, `pl.class`
      -- @classmod pl.List
      -- @pragma nostrip

    4 local tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort
    4 local setmetatable, getmetatable,type,tostring,string = setmetatable,getmetatable,type,tostring,string
    4 local tablex = require 'pl.tablex'
    4 local filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues
    4 local tsub = tablex.sub
    4 local utils = require 'pl.utils'
    4 local class = require 'pl.class'

    4 local array_tostring,split,assert_arg,function_arg = utils.array_tostring,utils.split,utils.assert_arg,utils.function_arg
    4 local normalize_slice = tablex._normalize_slice

      -- metatable for our list and map objects has already been defined..
    4 local Multimap = utils.stdmt.MultiMap
    4 local List = utils.stdmt.List

      local iter

    4 class(nil,nil,List)

      -- we want the result to be _covariant_, i.e. t must have type of obj if possible
      local function makelist (t,obj)
****0     local klass = List
****0     if obj then
****0         klass = getmetatable(obj)
          end
****0     return setmetatable(t,klass)
      end

      local function simple_table(t)
****0     return type(t) == 'table' and not getmetatable(t) and #t > 0
      end

    4 function List._create (src)
****0     if simple_table(src) then return src end
      end

    4 function List:_init (src)
****0     if self == src then return end -- existing table used as self!
****0     if src then
****0         for v in iter(src) do
****0             tinsert(self,v)
              end
          end
      end

      --- Create a new list. Can optionally pass a table;
      -- passing another instance of List will cause a copy to be created;
      -- this will return a plain table with an appropriate metatable.
      -- we pass anything which isn't a simple table to iterate() to work out
      -- an appropriate iterator
      -- @see List.iterate
      -- @param[opt] t An optional list-like table
      -- @return a new List
      -- @usage ls = List();  ls = List {1,2,3,4}
      -- @function List.new

    4 List.new = List

      --- Make a copy of an existing list.
      -- The difference from a plain 'copy constructor' is that this returns
      -- the actual List subtype.
    4 function List:clone()
****0     local ls = makelist({},self)
****0     ls:extend(self)
****0     return ls
      end

      --- Add an item to the end of the list.
      -- @param i An item
      -- @return the list
    4 function List:append(i)
****0     tinsert(self,i)
****0     return self
      end

    4 List.push = tinsert

      --- Extend the list by appending all the items in the given list.
      -- equivalent to 'a[len(a):] = L'.
      -- @tparam List L Another List
      -- @return the list
    4 function List:extend(L)
****0     assert_arg(1,L,'table')
****0     for i = 1,#L do tinsert(self,L[i]) end
****0     return self
      end

      --- Insert an item at a given position. i is the index of the
      -- element before which to insert.
      -- @int i index of element before whichh to insert
      -- @param x A data item
      -- @return the list
    4 function List:insert(i, x)
****0     assert_arg(1,i,'number')
****0     tinsert(self,i,x)
****0     return self
      end

      --- Insert an item at the begining of the list.
      -- @param x a data item
      -- @return the list
    4 function List:put (x)
****0     return self:insert(1,x)
      end

      --- Remove an element given its index.
      -- (equivalent of Python's del s[i])
      -- @int i the index
      -- @return the list
    4 function List:remove (i)
****0     assert_arg(1,i,'number')
****0     tremove(self,i)
****0     return self
      end

      --- Remove the first item from the list whose value is given.
      -- (This is called 'remove' in Python; renamed to avoid confusion
      -- with table.remove)
      -- Return nil if there is no such item.
      -- @param x A data value
      -- @return the list
    4 function List:remove_value(x)
****0     for i=1,#self do
****0         if self[i]==x then tremove(self,i) return self end
          end
****0     return self
       end

      --- Remove the item at the given position in the list, and return it.
      -- If no index is specified, a:pop() returns the last item in the list.
      -- The item is also removed from the list.
      -- @int[opt] i An index
      -- @return the item
    4 function List:pop(i)
****0     if not i then i = #self end
****0     assert_arg(1,i,'number')
****0     return tremove(self,i)
      end

    4 List.get = List.pop

      --- Return the index in the list of the first item whose value is given.
      -- Return nil if there is no such item.
      -- @function List:index
      -- @param x A data value
      -- @int[opt=1] idx where to start search
      -- @return the index, or nil if not found.

    4 local tfind = tablex.find
    4 List.index = tfind

      --- Does this list contain the value?
      -- @param x A data value
      -- @return true or false
    4 function List:contains(x)
****0     return tfind(self,x) and true or false
      end

      --- Return the number of times value appears in the list.
      -- @param x A data value
      -- @return number of times x appears
    4 function List:count(x)
****0     local cnt=0
****0     for i=1,#self do
****0         if self[i]==x then cnt=cnt+1 end
          end
****0     return cnt
      end

      --- Sort the items of the list, in place.
      -- @func[opt='<'] cmp an optional comparison function
      -- @return the list
    4 function List:sort(cmp)
****0     if cmp then cmp = function_arg(1,cmp) end
****0     tsort(self,cmp)
****0     return self
      end

      --- Return a sorted copy of this list.
      -- @func[opt='<'] cmp an optional comparison function
      -- @return a new list
    4 function List:sorted(cmp)
****0     return List(self):sort(cmp)
      end

      --- Reverse the elements of the list, in place.
      -- @return the list
    4 function List:reverse()
****0     local t = self
****0     local n = #t
****0     for i = 1,n/2 do
****0         t[i],t[n] = t[n],t[i]
****0         n = n - 1
          end
****0     return self
      end

      --- Return the minimum and the maximum value of the list.
      -- @return minimum value
      -- @return maximum value
    4 function List:minmax()
****0     local vmin,vmax = 1e70,-1e70
****0     for i = 1,#self do
****0         local v = self[i]
****0         if v < vmin then vmin = v end
****0         if v > vmax then vmax = v end
          end
****0     return vmin,vmax
      end

      --- Emulate list slicing.  like  'list[first:last]' in Python.
      -- If first or last are negative then they are relative to the end of the list
      -- eg. slice(-2) gives last 2 entries in a list, and
      -- slice(-4,-2) gives from -4th to -2nd
      -- @param first An index
      -- @param last An index
      -- @return a new List
    4 function List:slice(first,last)
****0     return tsub(self,first,last)
      end

      --- Empty the list.
      -- @return the list
    4 function List:clear()
****0     for i=1,#self do tremove(self) end
****0     return self
      end

    4 local eps = 1.0e-10

      --- Emulate Python's range(x) function.
      -- Include it in List table for tidiness
      -- @int start A number
      -- @int[opt] finish A number greater than start; if absent,
      -- then start is 1 and finish is start
      -- @int[opt=1] incr an increment (may be less than 1)
      -- @return a List from start .. finish
      -- @usage List.range(0,3) == List{0,1,2,3}
      -- @usage List.range(4) = List{1,2,3,4}
      -- @usage List.range(5,1,-1) == List{5,4,3,2,1}
    4 function List.range(start,finish,incr)
****0     if not finish then
****0         finish = start
****0         start = 1
          end
****0     if incr then
****0     assert_arg(3,incr,'number')
****0     if math.ceil(incr) ~= incr then finish = finish + eps end
          else
****0         incr = 1
          end
****0     assert_arg(1,start,'number')
****0     assert_arg(2,finish,'number')
****0     local t = List()
****0     for i=start,finish,incr do tinsert(t,i) end
****0     return t
      end

      --- list:len() is the same as #list.
    4 function List:len()
****0     return #self
      end

      -- Extended operations --

      --- Remove a subrange of elements.
      -- equivalent to 'del s[i1:i2]' in Python.
      -- @int i1 start of range
      -- @int i2 end of range
      -- @return the list
    4 function List:chop(i1,i2)
****0     return tremovevalues(self,i1,i2)
      end

      --- Insert a sublist into a list
      -- equivalent to 's[idx:idx] = list' in Python
      -- @int idx index
      -- @tparam List list list to insert
      -- @return the list
      -- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})
    4 function List:splice(idx,list)
****0     assert_arg(1,idx,'number')
****0     idx = idx - 1
****0     local i = 1
****0     for v in iter(list) do
****0         tinsert(self,i+idx,v)
****0         i = i + 1
          end
****0     return self
      end

      --- General slice assignment s[i1:i2] = seq.
      -- @int i1  start index
      -- @int i2  end index
      -- @tparam List seq a list
      -- @return the list
    4 function List:slice_assign(i1,i2,seq)
****0     assert_arg(1,i1,'number')
****0     assert_arg(1,i2,'number')
****0     i1,i2 = normalize_slice(self,i1,i2)
****0     if i2 >= i1 then self:chop(i1,i2) end
****0     self:splice(i1,seq)
****0     return self
      end

      --- Concatenation operator.
      -- @within metamethods
      -- @tparam List L another List
      -- @return a new list consisting of the list with the elements of the new list appended
    4 function List:__concat(L)
****0     assert_arg(1,L,'table')
****0     local ls = self:clone()
****0     ls:extend(L)
****0     return ls
      end

      --- Equality operator ==.  True iff all elements of two lists are equal.
      -- @within metamethods
      -- @tparam List L another List
      -- @return true or false
    4 function List:__eq(L)
****0     if #self ~= #L then return false end
****0     for i = 1,#self do
****0         if self[i] ~= L[i] then return false end
          end
****0     return true
      end

      --- Join the elements of a list using a delimiter.
      -- This method uses tostring on all elements.
      -- @string[opt=''] delim a delimiter string, can be empty.
      -- @return a string
    4 function List:join (delim)
****0     delim = delim or ''
****0     assert_arg(1,delim,'string')
****0     return concat(array_tostring(self),delim)
      end

      --- Join a list of strings. <br>
      -- Uses `table.concat` directly.
      -- @function List:concat
      -- @string[opt=''] delim a delimiter
      -- @return a string
    4 List.concat = concat

      local function tostring_q(val)
****0     local s = tostring(val)
****0     if type(val) == 'string' then
****0         s = '"'..s..'"'
          end
****0     return s
      end

      --- How our list should be rendered as a string. Uses join().
      -- @within metamethods
      -- @see List:join
    4 function List:__tostring()
****0     return '{'..self:join(',',tostring_q)..'}'
      end

      --- Call the function on each element of the list.
      -- @func fun a function or callable object
      -- @param ... optional values to pass to function
    4 function List:foreach (fun,...)
****0     fun = function_arg(1,fun)
****0     for i = 1,#self do
****0         fun(self[i],...)
          end
      end

      local function lookup_fun (obj,name)
****0     local f = obj[name]
****0     if not f then error(type(obj).." does not have method "..name,3) end
****0     return f
      end

      --- Call the named method on each element of the list.
      -- @string name the method name
      -- @param ... optional values to pass to function
    4 function List:foreachm (name,...)
****0     for i = 1,#self do
****0         local obj = self[i]
****0         local f = lookup_fun(obj,name)
****0         f(obj,...)
          end
      end

      --- Create a list of all elements which match a function.
      -- @func fun a boolean function
      -- @param[opt] arg optional argument to be passed as second argument of the predicate
      -- @return a new filtered list.
    4 function List:filter (fun,arg)
****0     return makelist(filter(self,fun,arg),self)
      end

      --- Split a string using a delimiter.
      -- @string s the string
      -- @string[opt] delim the delimiter (default spaces)
      -- @return a List of strings
      -- @see pl.utils.split
    4 function List.split (s,delim)
****0     assert_arg(1,s,'string')
****0     return makelist(split(s,delim))
      end

      --- Apply a function to all elements.
      -- Any extra arguments will be passed to the function.
      -- @func fun a function of at least one argument
      -- @param ... arbitrary extra arguments.
      -- @return a new list: {f(x) for x in self}
      -- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}
      -- @see pl.tablex.imap
    4 function List:map (fun,...)
****0     return makelist(imap(fun,self,...),self)
      end

      --- Apply a function to all elements, in-place.
      -- Any extra arguments are passed to the function.
      -- @func fun A function that takes at least one argument
      -- @param ... arbitrary extra arguments.
      -- @return the list.
    4 function List:transform (fun,...)
****0     transform(fun,self,...)
****0     return self
      end

      --- Apply a function to elements of two lists.
      -- Any extra arguments will be passed to the function
      -- @func fun a function of at least two arguments
      -- @tparam List ls another list
      -- @param ... arbitrary extra arguments.
      -- @return a new list: {f(x,y) for x in self, for x in arg1}
      -- @see pl.tablex.imap2
    4 function List:map2 (fun,ls,...)
****0     return makelist(imap2(fun,self,ls,...),self)
      end

      --- apply a named method to all elements.
      -- Any extra arguments will be passed to the method.
      -- @string name name of method
      -- @param ... extra arguments
      -- @return a new list of the results
      -- @see pl.seq.mapmethod
    4 function List:mapm (name,...)
****0     local res = {}
****0     for i = 1,#self do
****0       local val = self[i]
****0       local fn = lookup_fun(val,name)
****0       res[i] = fn(val,...)
          end
****0     return makelist(res,self)
      end

      local function composite_call (method,f)
          return function(self,...)
****0         return self[method](self,f,...)
          end
      end

    4 function List.default_map_with(T)
          return function(self,name)
              local m
****0         if T then
****0             local f = lookup_fun(T,name)
****0             m = composite_call('map',f)
              else
****0             m = composite_call('mapn',name)
              end
****0         getmetatable(self)[name] = m -- and cache..
****0         return m
          end
      end

    4 List.default_map = List.default_map_with

      --- 'reduce' a list using a binary function.
      -- @func fun a function of two arguments
      -- @return result of the function
      -- @see pl.tablex.reduce
    4 function List:reduce (fun)
****0     return reduce(fun,self)
      end

      --- Partition a list using a classifier function.
      -- The function may return nil, but this will be converted to the string key '<nil>'.
      -- @func fun a function of at least one argument
      -- @param ... will also be passed to the function
      -- @treturn MultiMap a table where the keys are the returned values, and the values are Lists
      -- of values where the function returned that key.
      -- @see pl.MultiMap
    4 function List:partition (fun,...)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for i = 1,#self do
****0         local val = self[i]
****0         local klass = fun(val,...)
****0         if klass == nil then klass = '<nil>' end
****0         if not res[klass] then res[klass] = List() end
****0         res[klass]:append(val)
          end
****0     return setmetatable(res,Multimap)
      end

      --- return an iterator over all values.
    4 function List:iter ()
****0     return iter(self)
      end

      --- Create an iterator over a seqence.
      -- This captures the Python concept of 'sequence'.
      -- For tables, iterates over all values with integer indices.
      -- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function
      -- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==> 1,10,22,55
      -- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==> h e l p
    4 function List.iterate(seq)
****0     if type(seq) == 'string' then
****0         local idx = 0
****0         local n = #seq
****0         local sub = string.sub
              return function ()
****0             idx = idx + 1
****0             if idx > n then return nil
                  else
****0                 return sub(seq,idx,idx)
                  end
              end
****0     elseif type(seq) == 'table' then
****0         local idx = 0
****0         local n = #seq
              return function()
****0             idx = idx + 1
****0             if idx > n then return nil
                  else
****0                 return seq[idx]
                  end
              end
****0     elseif type(seq) == 'function' then
****0         return seq
****0     elseif type(seq) == 'userdata' and io.type(seq) == 'file' then
****0         return seq:lines()
          end
      end
    4 iter = List.iterate

    4 return List


==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/pl/class.lua
==============================================================================
      --- Provides a reuseable and convenient framework for creating classes in Lua.
      -- Two possible notations:
      --
      --    B = class(A)
      --    class.B(A)
      --
      -- The latter form creates a named class within the current environment. Note
      -- that this implicitly brings in `pl.utils` as a dependency.
      --
      -- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}
      -- @module pl.class

      local error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =
****0     _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type
      local compat

      -- this trickery is necessary to prevent the inheritance of 'super' and
      -- the resulting recursive call problems.
      local function call_ctor (c,obj,...)
****0     local init = rawget(c,'_init')
****0     local parent_with_init = rawget(c,'_parent_with_init')

****0     if parent_with_init then
****0         if not init then -- inheriting an init
****0             init = rawget(parent_with_init, '_init')
****0             parent_with_init = rawget(parent_with_init, '_parent_with_init')
              end
****0         if parent_with_init then -- super() points to one above whereever _init came from
****0             rawset(obj,'super',function(obj,...)
****0                 call_ctor(parent_with_init,obj,...)
                  end)
              end
          else
              -- Without this, calling super() where none exists will sometimes loop and stack overflow
****0         rawset(obj,'super',nil)
          end

****0     local res = init(obj,...)
****0     if parent_with_init then -- If this execution of call_ctor set a super, unset it
****0         rawset(obj,'super',nil)
          end

****0     return res
      end

      --- initializes an __instance__ upon creation.
      -- @function class:_init
      -- @param ... parameters passed to the constructor
      -- @usage local Cat = class()
      -- function Cat:_init(name)
      --   --self:super(name)   -- call the ancestor initializer if needed
      --   self.name = name
      -- end
      --
      -- local pussycat = Cat("pussycat")
      -- print(pussycat.name)  --> pussycat

      --- checks whether an __instance__ is derived from some class.
      -- Works the other way around as `class_of`. It has two ways of using;
      -- 1) call with a class to check against, 2) call without params.
      -- @function instance:is_a
      -- @param some_class class to check against, or `nil` to return the class
      -- @return `true` if `instance` is derived from `some_class`, or if `some_class == nil` then
      -- it returns the class table of the instance
      -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
      -- if pussycat:is_a(Cat) then
      --   -- it's true, it is a Lion, but also a Cat
      -- end
      --
      -- if pussycat:is_a() == Lion then
      --   -- It's true
      -- end
      local function is_a(self,klass)
****0     if klass == nil then
              -- no class provided, so return the class this instance is derived from
****0         return getmetatable(self)
          end
****0     local m = getmetatable(self)
****0     if not m then return false end --*can't be an object!
****0     while m do
****0         if m == klass then return true end
****0         m = rawget(m,'_base')
          end
****0     return false
      end

      --- checks whether an __instance__ is derived from some class.
      -- Works the other way around as `is_a`.
      -- @function some_class:class_of
      -- @param some_instance instance to check against
      -- @return `true` if `some_instance` is derived from `some_class`
      -- @usage local pussycat = Lion()  -- assuming Lion derives from Cat
      -- if Cat:class_of(pussycat) then
      --   -- it's true
      -- end
      local function class_of(klass,obj)
****0     if type(klass) ~= 'table' or not rawget(klass,'is_a') then return false end
****0     return klass.is_a(obj,klass)
      end

      --- cast an object to another class.
      -- It is not clever (or safe!) so use carefully.
      -- @param some_instance the object to be changed
      -- @function some_class:cast
      local function cast (klass, obj)
****0     return setmetatable(obj,klass)
      end


      local function _class_tostring (obj)
****0     local mt = obj._class
****0     local name = rawget(mt,'_name')
****0     setmetatable(obj,nil)
****0     local str = tostring(obj)
****0     setmetatable(obj,mt)
****0     if name then str = name ..str:gsub('table','') end
****0     return str
      end

      local function tupdate(td,ts,dont_override)
****0     for k,v in pairs(ts) do
****0         if not dont_override or td[k] == nil then
****0             td[k] = v
              end
          end
      end

      local function _class(base,c_arg,c)
          -- the class `c` will be the metatable for all its objects,
          -- and they will look up their methods in it.
    4     local mt = {}   -- a metatable for the class to support __call and _handler
          -- can define class by passing it a plain table of methods
    4     local plain = type(base) == 'table' and not getmetatable(base)
    4     if plain then
****0         c = base
****0         base = c._base
          else
    4         c = c or {}
          end

    4     if type(base) == 'table' then
              -- our new class is a shallow copy of the base class!
              -- but be careful not to wipe out any methods we have been given at this point!
****0         tupdate(c,base,plain)
****0         c._base = base
              -- inherit the 'not found' handler, if present
****0         if rawget(c,'_handler') then mt.__index = c._handler end
    4     elseif base ~= nil then
****0         error("must derive from a table type",3)
          end

    4     c.__index = c
    4     setmetatable(c,mt)
    4     if not plain then
    4         if base and rawget(base,'_init') then c._parent_with_init = base end -- For super and inherited init
    4         c._init = nil
          end

    4     if base and rawget(base,'_class_init') then
****0         base._class_init(c,c_arg)
          end

          -- expose a ctor which can be called by <classname>(<args>)
          mt.__call = function(class_tbl,...)
              local obj
****0         if rawget(c,'_create') then obj = c._create(...) end
****0         if not obj then obj = {} end
****0         setmetatable(obj,c)

****0         if rawget(c,'_init') or rawget(c,'_parent_with_init') then -- constructor exists
****0             local res = call_ctor(c,obj,...)
****0             if res then -- _if_ a ctor returns a value, it becomes the object...
****0                 obj = res
****0                 setmetatable(obj,c)
                  end
              end

****0         if base and rawget(base,'_post_init') then
****0             base._post_init(obj)
              end

****0         return obj
          end
          -- Call Class.catch to set a handler for methods/properties not found in the class!
          c.catch = function(self, handler)
****0         if type(self) == "function" then
                  -- called using . instead of :
****0             handler = self
              end
****0         c._handler = handler
****0         mt.__index = handler
          end
    4     c.is_a = is_a
    4     c.class_of = class_of
    4     c.cast = cast
    4     c._class = c

    4     if not rawget(c,'__tostring') then
    4         c.__tostring = _class_tostring
          end

    4     return c
      end

      --- create a new class, derived from a given base class.
      -- Supporting two class creation syntaxes:
      -- either `Name = class(base)` or `class.Name(base)`.
      -- The first form returns the class directly and does not set its `_name`.
      -- The second form creates a variable `Name` in the current environment set
      -- to the class, and also sets `_name`.
      -- @function class
      -- @param base optional base class
      -- @param c_arg optional parameter to class constructor
      -- @param c optional table to be used as class
      local class
****0 class = setmetatable({},{
          __call = function(fun,...)
    4         return _class(...)
          end,
          __index = function(tbl,key)
****0         if key == 'class' then
****0             io.stderr:write('require("pl.class").class is deprecated. Use require("pl.class")\n')
****0             return class
              end
****0         compat = compat or require 'pl.compat'
****0         local env = compat.getfenv(2)
              return function(...)
****0             local c = _class(...)
****0             c._name = key
****0             rawset(env,key,c)
****0             return c
              end
          end
      })

****0 class.properties = class()

****0 function class.properties._class_init(klass)
          klass.__index = function(t,key)
              -- normal class lookup!
****0         local v = klass[key]
****0         if v then return v end
              -- is it a getter?
****0         v = rawget(klass,'get_'..key)
****0         if v then
****0             return v(t)
              end
              -- is it a field?
****0         return rawget(t,'_'..key)
          end
          klass.__newindex = function (t,key,value)
              -- if there's a setter, use that, otherwise directly set table
****0         local p = 'set_'..key
****0         local setter = klass[p]
****0         if setter then
****0             setter(t,value)
              else
****0             rawset(t,key,value)
              end
          end
      end


****0 return class


==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/pl/dir.lua
==============================================================================
      --- Listing files in directories and creating/removing directory paths.
      --
      -- Dependencies: `pl.utils`, `pl.path`
      --
      -- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
      -- @module pl.dir

    4 local utils = require 'pl.utils'
    4 local path = require 'pl.path'
    4 local is_windows = path.is_windows
    4 local ldir = path.dir
    4 local mkdir = path.mkdir
    4 local rmdir = path.rmdir
    4 local sub = string.sub
    4 local os,pcall,ipairs,pairs,require,setmetatable = os,pcall,ipairs,pairs,require,setmetatable
    4 local remove = os.remove
    4 local append = table.insert
    4 local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

    4 local exists, isdir = path.exists, path.isdir
    4 local sep = path.sep

    4 local dir = {}

      local function makelist(l)
    4     return setmetatable(l, require('pl.List'))
      end

      local function assert_dir (n,val)
    4     assert_arg(n,val,'string',path.isdir,'not a directory',4)
      end

      local function filemask(mask)
  132     mask = utils.escape(path.normcase(mask))
  132     return '^'..mask:gsub('%%%*','.*'):gsub('%%%?','.')..'$'
      end

      --- Test whether a file name matches a shell pattern.
      -- Both parameters are case-normalized if operating system is
      -- case-insensitive.
      -- @string filename A file name.
      -- @string pattern A shell pattern. The only special characters are
      -- `'*'` and `'?'`: `'*'` matches any sequence of characters and
      -- `'?'` matches any single character.
      -- @treturn bool
      -- @raise dir and mask must be strings
    4 function dir.fnmatch(filename,pattern)
****0     assert_string(1,filename)
****0     assert_string(2,pattern)
****0     return path.normcase(filename):find(filemask(pattern)) ~= nil
      end

      --- Return a list of all file names within an array which match a pattern.
      -- @tab filenames An array containing file names.
      -- @string pattern A shell pattern.
      -- @treturn List(string) List of matching file names.
      -- @raise dir and mask must be strings
    4 function dir.filter(filenames,pattern)
****0     assert_arg(1,filenames,'table')
****0     assert_string(2,pattern)
****0     local res = {}
****0     local mask = filemask(pattern)
****0     for i,f in ipairs(filenames) do
****0         if path.normcase(f):find(mask) then append(res,f) end
          end
****0     return makelist(res)
      end

      local function _listfiles(dirname,filemode,match)
****0     local res = {}
****0     local check = utils.choose(filemode,path.isfile,path.isdir)
****0     if not dirname then dirname = '.' end
****0     for f in ldir(dirname) do
****0         if f ~= '.' and f ~= '..' then
****0             local p = path.join(dirname,f)
****0             if check(p) and (not match or match(f)) then
****0                 append(res,p)
                  end
              end
          end
****0     return makelist(res)
      end

      --- return a list of all files in a directory which match a shell pattern.
      -- @string dirname A directory. If not given, all files in current directory are returned.
      -- @string mask  A shell pattern. If not given, all files are returned.
      -- @treturn {string} list of files
      -- @raise dirname and mask must be strings
    4 function dir.getfiles(dirname,mask)
****0     assert_dir(1,dirname)
****0     if mask then assert_string(2,mask) end
          local match
****0     if mask then
****0         mask = filemask(mask)
              match = function(f)
****0             return path.normcase(f):find(mask)
              end
          end
****0     return _listfiles(dirname,true,match)
      end

      --- return a list of all subdirectories of the directory.
      -- @string dirname A directory
      -- @treturn {string} a list of directories
      -- @raise dir must be a a valid directory
    4 function dir.getdirectories(dirname)
****0     assert_dir(1,dirname)
****0     return _listfiles(dirname,false)
      end

      local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

      local function execute_command(cmd,parms)
****0    if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
****0    local err = path.is_windows and ' > ' or ' 2> '
****0     cmd = cmd..' '..parms..err..utils.quote_arg(cmd_tmpfile)
****0     local ret = utils.execute(cmd)
****0     if not ret then
****0         local err = (utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
****0         remove(cmd_tmpfile)
****0         return false,err
          else
****0         remove(cmd_tmpfile)
****0         return true
          end
      end

      local function find_ffi_copyfile ()
****0     if not ffi_checked then
****0         ffi_checked = true
              local res
****0         res,alien = pcall(require,'alien')
****0         if not res then
****0             alien = nil
****0             res, ffi = pcall(require,'ffi')
              end
****0         if not res then
****0             ffi = nil
****0             return
              end
          else
****0         return
          end
****0     if alien then
              -- register the Win32 CopyFile and MoveFile functions
****0         local kernel = alien.load('kernel32.dll')
****0         CopyFile = kernel.CopyFileA
****0         CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
****0         MoveFile = kernel.MoveFileA
****0         MoveFile:types{'string','string',ret='int',abi='stdcall'}
****0         GetLastError = kernel.GetLastError
****0         GetLastError:types{ret ='int', abi='stdcall'}
****0     elseif ffi then
****0         ffi.cdef [[
                  int CopyFileA(const char *src, const char *dest, int iovr);
                  int MoveFileA(const char *src, const char *dest);
                  int GetLastError();
****0         ]]
****0         CopyFile = ffi.C.CopyFileA
****0         MoveFile = ffi.C.MoveFileA
****0         GetLastError = ffi.C.GetLastError
          end
****0     win32_errors = {
              ERROR_FILE_NOT_FOUND    =         2,
              ERROR_PATH_NOT_FOUND    =         3,
              ERROR_ACCESS_DENIED    =          5,
              ERROR_WRITE_PROTECT    =          19,
              ERROR_BAD_UNIT         =          20,
              ERROR_NOT_READY        =          21,
              ERROR_WRITE_FAULT      =          29,
              ERROR_READ_FAULT       =          30,
              ERROR_SHARING_VIOLATION =         32,
              ERROR_LOCK_VIOLATION    =         33,
              ERROR_HANDLE_DISK_FULL  =         39,
              ERROR_BAD_NETPATH       =         53,
              ERROR_NETWORK_BUSY      =         54,
              ERROR_DEV_NOT_EXIST     =         55,
              ERROR_FILE_EXISTS       =         80,
              ERROR_OPEN_FAILED       =         110,
              ERROR_INVALID_NAME      =         123,
              ERROR_BAD_PATHNAME      =         161,
              ERROR_ALREADY_EXISTS    =         183,
          }
      end

      local function two_arguments (f1,f2)
****0     return utils.quote_arg(f1)..' '..utils.quote_arg(f2)
      end

      local function file_op (is_copy,src,dest,flag)
****0     if flag == 1 and path.exists(dest) then
****0         return false,"cannot overwrite destination"
          end
****0     if is_windows then
              -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
****0         find_ffi_copyfile()
              -- fallback if there's no Alien, just use DOS commands *shudder*
              -- 'rename' involves a copy and then deleting the source.
****0         if not CopyFile then
****0             if path.is_windows then
****0                 src = src:gsub("/","\\")
****0                 dest = dest:gsub("/","\\")
                  end
****0             local res, err = execute_command('copy',two_arguments(src,dest))
****0             if not res then return false,err end
****0             if not is_copy then
****0                 return execute_command('del',utils.quote_arg(src))
                  end
****0             return true
              else
****0             if path.isdir(dest) then
****0                 dest = path.join(dest,path.basename(src))
                  end
                  local ret
****0             if is_copy then ret = CopyFile(src,dest,flag)
****0             else ret = MoveFile(src,dest) end
****0             if ret == 0 then
****0                 local err = GetLastError()
****0                 for name,value in pairs(win32_errors) do
****0                     if value == err then return false,name end
                      end
****0                 return false,"Error #"..err
****0             else return true
                  end
              end
          else -- for Unix, just use cp for now
****0         return execute_command(is_copy and 'cp' or 'mv',
****0             two_arguments(src,dest))
          end
      end

      --- copy a file.
      -- @string src source file
      -- @string dest destination file or directory
      -- @bool flag true if you want to force the copy (default)
      -- @treturn bool operation succeeded
      -- @raise src and dest must be strings
    4 function dir.copyfile (src,dest,flag)
****0     assert_string(1,src)
****0     assert_string(2,dest)
****0     flag = flag==nil or flag
****0     return file_op(true,src,dest,flag and 0 or 1)
      end

      --- move a file.
      -- @string src source file
      -- @string dest destination file or directory
      -- @treturn bool operation succeeded
      -- @raise src and dest must be strings
    4 function dir.movefile (src,dest)
****0     assert_string(1,src)
****0     assert_string(2,dest)
****0     return file_op(false,src,dest,0)
      end

      local function _dirfiles(dirname,attrib)
****0     local dirs = {}
****0     local files = {}
****0     for f in ldir(dirname) do
****0         if f ~= '.' and f ~= '..' then
****0             local p = path.join(dirname,f)
****0             local mode = attrib(p,'mode')
****0             if mode=='directory' then
****0                 append(dirs,f)
                  else
****0                 append(files,f)
                  end
              end
          end
****0     return makelist(dirs), makelist(files)
      end


      --- return an iterator which walks through a directory tree starting at root.
      -- The iterator returns (root,dirs,files)
      -- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
      -- to get the actual full path)
      -- If bottom_up is false (or not present), then the entries at the current level are returned
      -- before we go deeper. This means that you can modify the returned list of directories before
      -- continuing.
      -- This is a clone of os.walk from the Python libraries.
      -- @string root A starting directory
      -- @bool bottom_up False if we start listing entries immediately.
      -- @bool follow_links follow symbolic links
      -- @return an iterator returning root,dirs,files
      -- @raise root must be a directory
    4 function dir.walk(root,bottom_up,follow_links)
****0     assert_dir(1,root)
          local attrib
****0     if path.is_windows or not follow_links then
****0         attrib = path.attrib
          else
****0         attrib = path.link_attrib
          end

****0     local to_scan = { root }
****0     local to_return = {}
          local iter = function()
****0         while #to_scan > 0 do
****0             local current_root = table.remove(to_scan)
****0             local dirs,files = _dirfiles(current_root, attrib)
****0             for _, d in ipairs(dirs) do
****0                 table.insert(to_scan, current_root..path.sep..d)
                  end
****0             if not bottom_up then
****0                 return current_root, dirs, files
                  else
****0                 table.insert(to_return, { current_root, dirs, files })
                  end
              end
****0         if #to_return > 0 then
****0             return utils.unpack(table.remove(to_return))
              end
          end

****0     return iter
      end

      --- remove a whole directory tree.
      -- Symlinks in the tree will be deleted without following them.
      -- @string fullpath A directory path (must be an actual directory, not a symlink)
      -- @return true or nil
      -- @return error if failed
      -- @raise fullpath must be a string
    4 function dir.rmtree(fullpath)
****0     assert_dir(1,fullpath)
****0     if path.islink(fullpath) then return false,'will not follow symlink' end
****0     for root,dirs,files in dir.walk(fullpath,true) do
****0         if path.islink(root) then
                  -- sub dir is a link, remove link, do not follow
****0             if is_windows then
                      -- Windows requires using "rmdir". Deleting the link like a file
                      -- will instead delete all files from the target directory!!
****0                 local res, err = rmdir(root)
****0                 if not res then return nil,err .. ": " .. root end
                  else
****0                 local res, err = remove(root)
****0                 if not res then return nil,err .. ": " .. root end
                  end
              else
****0             for i,f in ipairs(files) do
****0                 local res, err = remove(path.join(root,f))
****0                 if not res then return nil,err .. ": " .. path.join(root,f) end
                  end
****0             local res, err = rmdir(root)
****0             if not res then return nil,err .. ": " .. root end
              end
          end
****0     return true
      end


      do
        local dirpat
    4   if path.is_windows then
****0       dirpat = '(.+)\\[^\\]+$'
        else
    4       dirpat = '(.+)/[^/]+$'
        end

        local _makepath
    4   function _makepath(p)
            -- windows root drive case
****0       if p:find '^%a:[\\]*$' then
****0           return true
            end
****0       if not path.isdir(p) then
****0           local subp = p:match(dirpat)
****0           if subp then
****0             local ok, err = _makepath(subp)
****0             if not ok then return nil, err end
                end
****0           return mkdir(p)
            else
****0           return true
            end
        end

        --- create a directory path.
        -- This will create subdirectories as necessary!
        -- @string p A directory path
        -- @return true on success, nil + errormsg on failure
        -- @raise failure to create
    4   function dir.makepath (p)
****0       assert_string(1,p)
****0       if path.is_windows then
****0           p = p:gsub("/", "\\")
            end
****0       return _makepath(path.abspath(p))
        end
      end

      --- clone a directory tree. Will always try to create a new directory structure
      -- if necessary.
      -- @string path1 the base path of the source tree
      -- @string path2 the new base path for the destination
      -- @func file_fun an optional function to apply on all files
      -- @bool verbose an optional boolean to control the verbosity of the output.
      --  It can also be a logging function that behaves like print()
      -- @return true, or nil
      -- @return error message, or list of failed directory creations
      -- @return list of failed file operations
      -- @raise path1 and path2 must be strings
      -- @usage clonetree('.','../backup',copyfile)
    4 function dir.clonetree (path1,path2,file_fun,verbose)
****0     assert_string(1,path1)
****0     assert_string(2,path2)
****0     if verbose == true then verbose = print end
****0     local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
****0     local faildirs,failfiles = {},{}
****0     if not isdir(path1) then return raise 'source is not a valid directory' end
****0     path1 = abspath(normcase(path1))
****0     path2 = abspath(normcase(path2))
****0     if verbose then verbose('normalized:',path1,path2) end
          -- particularly NB that the new path isn't fully contained in the old path
****0     if path1 == path2 then return raise "paths are the same" end
****0     local _,i2 = path2:find(path1,1,true)
****0     if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
****0         return raise 'destination is a subdirectory of the source'
          end
****0     local cp = path.common_prefix (path1,path2)
****0     local idx = #cp
****0     if idx == 0 then -- no common path, but watch out for Windows paths!
****0         if path1:sub(2,2) == ':' then idx = 3 end
          end
****0     for root,dirs,files in dir.walk(path1) do
****0         local opath = path2..root:sub(idx)
****0         if verbose then verbose('paths:',opath,root) end
****0         if not isdir(opath) then
****0             local ret = dir.makepath(opath)
****0             if not ret then append(faildirs,opath) end
****0             if verbose then verbose('creating:',opath,ret) end
              end
****0         if file_fun then
****0             for i,f in ipairs(files) do
****0                 local p1 = join(root,f)
****0                 local p2 = join(opath,f)
****0                 local ret = file_fun(p1,p2)
****0                 if not ret then append(failfiles,p2) end
****0                 if verbose then
****0                     verbose('files:',p1,p2,ret)
                      end
                  end
              end
          end
****0     return true,faildirs,failfiles
      end


      -- each entry of the stack is an array with three items:
      -- 1. the name of the directory
      -- 2. the lfs iterator function
      -- 3. the lfs iterator userdata
      local function treeiter(iterstack)
  180     local diriter = iterstack[#iterstack]
  180     if not diriter then
    4       return -- done
          end

  176     local dirname = diriter[1]
  176     local entry = diriter[2](diriter[3])
  176     if not entry then
   12       table.remove(iterstack)
   12       return treeiter(iterstack) -- tail-call to try next
          end

  164     if entry ~= "." and entry ~= ".." then
  140         entry = dirname .. sep .. entry
  140         if exists(entry) then  -- Just in case a symlink is broken.
  140             local is_dir = isdir(entry)
  140             if is_dir then
    8                 table.insert(iterstack, { entry, ldir(entry) })
                  end
  140             return entry, is_dir
              end
          end

   24     return treeiter(iterstack) -- tail-call to try next
      end


      --- return an iterator over all entries in a directory tree
      -- @string d a directory
      -- @return an iterator giving pathname and mode (true for dir, false otherwise)
      -- @raise d must be a non-empty string
    4 function dir.dirtree( d )
    4     assert( d and d ~= "", "directory parameter is missing or empty" )

    4     local last = sub ( d, -1 )
    4     if last == sep or last == '/' then
****0         d = sub( d, 1, -2 )
          end

    4     local iterstack = { {d, ldir(d)} }

    4     return treeiter, iterstack
      end


      --- Recursively returns all the file starting at _path_. It can optionally take a shell pattern and
      -- only returns files that match _shell_pattern_. If a pattern is given it will do a case insensitive search.
      -- @string start_path  A directory. If not given, all files in current directory are returned.
      -- @string shell_pattern A shell pattern. If not given, all files are returned.
      -- @treturn List(string) containing all the files found recursively starting at _path_ and filtered by _shell_pattern_.
      -- @raise start_path must be a directory
    4 function dir.getallfiles( start_path, shell_pattern )
    4     assert_dir(1,start_path)
    4     shell_pattern = shell_pattern or "*"

    4     local files = {}
    4     local normcase = path.normcase
  144     for filename, mode in dir.dirtree( start_path ) do
  140         if not mode then
  132             local mask = filemask( shell_pattern )
  132             if normcase(filename):find( mask ) then
  132                 files[#files + 1] = filename
                  end
              end
          end

    4     return makelist(files)
      end

    4 return dir

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/pl/path.lua
==============================================================================
      --- Path manipulation and file queries.
      --
      -- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
      --
      -- NOTE: the functions assume the paths being dealt with to originate
      -- from the OS the application is running on. Windows drive letters are not
      -- to be used when running on a Unix system for example. The one exception
      -- is Windows paths to allow both forward and backward slashes (since Lua
      -- also accepts those)
      --
      -- Dependencies: `pl.utils`, `lfs`
      -- @module pl.path

      -- imports and locals
****0 local _G = _G
****0 local sub = string.sub
****0 local getenv = os.getenv
****0 local tmpnam = os.tmpname
****0 local package = package
****0 local append, concat, remove = table.insert, table.concat, table.remove
****0 local utils = require 'pl.utils'
****0 local assert_string,raise = utils.assert_string,utils.raise

****0 local res,lfs = _G.pcall(_G.require,'lfs')
****0 if not res then
****0     error("pl.path requires LuaFileSystem")
      end

****0 local attrib = lfs.attributes
****0 local currentdir = lfs.currentdir
****0 local link_attrib = lfs.symlinkattributes

****0 local path = {}

      local function err_func(name, param, err, code)
****0   local ret = ("%s failed"):format(tostring(name))
****0   if param ~= nil then
****0     ret = ret .. (" for '%s'"):format(tostring(param))
        end
****0   ret = ret .. (": %s"):format(tostring(err))
****0   if code ~= nil then
****0     ret = ret .. (" (code %s)"):format(tostring(code))
        end
****0   return ret
      end

      --- Lua iterator over the entries of a given directory.
      -- Implicit link to [`luafilesystem.dir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function dir
****0 path.dir = lfs.dir

      --- Creates a directory.
      -- Implicit link to [`luafilesystem.mkdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function mkdir
      path.mkdir = function(d)
****0   local ok, err, code = lfs.mkdir(d)
****0   if not ok then
****0     return ok, err_func("mkdir", d, err, code), code
        end
****0   return ok, err, code
      end

      --- Removes a directory.
      -- Implicit link to [`luafilesystem.rmdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function rmdir
      path.rmdir = function(d)
****0   local ok, err, code = lfs.rmdir(d)
****0   if not ok then
****0     return ok, err_func("rmdir", d, err, code), code
        end
****0   return ok, err, code
      end

      --- Gets attributes.
      -- Implicit link to [`luafilesystem.attributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function attrib
      path.attrib = function(d, r)
****0   local ok, err, code = attrib(d, r)
****0   if not ok then
****0     return ok, err_func("attrib", d, err, code), code
        end
****0   return ok, err, code
      end

      --- Get the working directory.
      -- Implicit link to [`luafilesystem.currentdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function currentdir
      path.currentdir = function()
****0   local ok, err, code = currentdir()
****0   if not ok then
****0     return ok, err_func("currentdir", nil, err, code), code
        end
****0   return ok, err, code
      end

      --- Gets symlink attributes.
      -- Implicit link to [`luafilesystem.symlinkattributes`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function link_attrib
      path.link_attrib = function(d, r)
****0   local ok, err, code = link_attrib(d, r)
****0   if not ok then
****0     return ok, err_func("link_attrib", d, err, code), code
        end
****0   return ok, err, code
      end

      --- Changes the working directory.
      -- On Windows, if a drive is specified, it also changes the current drive. If
      -- only specifying the drive, it will only switch drive, but not modify the path.
      -- Implicit link to [`luafilesystem.chdir`](https://keplerproject.github.io/luafilesystem/manual.html#reference)
      -- @function chdir
      path.chdir = function(d)
****0   local ok, err, code = lfs.chdir(d)
****0   if not ok then
****0     return ok, err_func("chdir", d, err, code), code
        end
****0   return ok, err, code
      end

      --- is this a directory?
      -- @string P A file path
****0 function path.isdir(P)
  148     assert_string(1,P)
  148     if P:match("\\$") then
****0         P = P:sub(1,-2)
          end
  148     return attrib(P,'mode') == 'directory'
      end

      --- is this a file?
      -- @string P A file path
****0 function path.isfile(P)
    4     assert_string(1,P)
    4     return attrib(P,'mode') == 'file'
      end

      -- is this a symbolic link?
      -- @string P A file path
****0 function path.islink(P)
****0     assert_string(1,P)
****0     if link_attrib then
****0         return link_attrib(P,'mode')=='link'
          else
****0         return false
          end
      end

      --- return size of a file.
      -- @string P A file path
****0 function path.getsize(P)
****0     assert_string(1,P)
****0     return attrib(P,'size')
      end

      --- does a path exist?
      -- @string P A file path
      -- @return the file path if it exists (either as file, directory, socket, etc), nil otherwise
****0 function path.exists(P)
  140     assert_string(1,P)
  140     return attrib(P,'mode') ~= nil and P
      end

      --- Return the time of last access as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getatime(P)
****0     assert_string(1,P)
****0     return attrib(P,'access')
      end

      --- Return the time of last modification as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getmtime(P)
****0     assert_string(1,P)
****0     return attrib(P,'modification')
      end

      ---Return the system's ctime as the number of seconds since the epoch.
      -- @string P A file path
****0 function path.getctime(P)
****0     assert_string(1,P)
****0     return path.attrib(P,'change')
      end


      local function at(s,i)
 3310     return sub(s,i,i)
      end

****0 path.is_windows = utils.is_windows

      local sep, other_sep, seps
      -- constant sep is the directory separator for this platform.
      -- constant dirsep is the separator in the PATH environment variable
****0 if path.is_windows then
****0     path.sep = '\\'; other_sep = '/'
****0     path.dirsep = ';'
****0     seps = { ['/'] = true, ['\\'] = true }
      else
****0     path.sep = '/'
****0     path.dirsep = ':'
****0     seps = { ['/'] = true }
      end
****0 sep = path.sep

      --- are we running Windows?
      -- @class field
      -- @name path.is_windows

      --- path separator for this platform.
      -- @class field
      -- @name path.sep

      --- separator for PATH for this platform
      -- @class field
      -- @name path.dirsep

      --- given a path, return the directory part and a file part.
      -- if there's no directory part, the first value will be empty
      -- @string P A file path
      -- @return directory part
      -- @return file part
      -- @usage
      -- local dir, file = path.splitpath("some/dir/myfile.txt")
      -- assert(dir == "some/dir")
      -- assert(file == "myfile.txt")
      --
      -- local dir, file = path.splitpath("some/dir/")
      -- assert(dir == "some/dir")
      -- assert(file == "")
      --
      -- local dir, file = path.splitpath("some_dir")
      -- assert(dir == "")
      -- assert(file == "some_dir")
****0 function path.splitpath(P)
  218     assert_string(1,P)
  218     local i = #P
  218     local ch = at(P,i)
 3262     while i > 0 and ch ~= sep and ch ~= other_sep do
 3044         i = i - 1
 3044         ch = at(P,i)
          end
  218     if i == 0 then
****0         return '',P
          else
  218         return sub(P,1,i-1), sub(P,i+1)
          end
      end

      --- return an absolute path.
      -- @string P A file path
      -- @string[opt] pwd optional start path to use (default is current dir)
****0 function path.abspath(P,pwd)
****0     assert_string(1,P)
****0     if pwd then assert_string(2,pwd) end
****0     local use_pwd = pwd ~= nil
****0     if not use_pwd and not currentdir() then return P end
****0     P = P:gsub('[\\/]$','')
****0     pwd = pwd or currentdir()
****0     if not path.isabs(P) then
****0         P = path.join(pwd,P)
****0     elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
****0         P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
          end
****0     return path.normpath(P)
      end

      --- given a path, return the root part and the extension part.
      -- if there's no extension part, the second value will be empty
      -- @string P A file path
      -- @treturn string root part (everything upto the "."", maybe empty)
      -- @treturn string extension part (including the ".", maybe empty)
      -- @usage
      -- local file_path, ext = path.splitext("/bonzo/dog_stuff/cat.txt")
      -- assert(file_path == "/bonzo/dog_stuff/cat")
      -- assert(ext == ".txt")
      --
      -- local file_path, ext = path.splitext("")
      -- assert(file_path == "")
      -- assert(ext == "")
****0 function path.splitext(P)
   12     assert_string(1,P)
   12     local i = #P
   12     local ch = at(P,i)
   48     while i > 0 and ch ~= '.' do
   36         if seps[ch] then
****0             return P,''
              end
   36         i = i - 1
   36         ch = at(P,i)
          end
   12     if i == 0 then
****0         return P,''
          else
   12         return sub(P,1,i-1),sub(P,i)
          end
      end

      --- return the directory part of a path
      -- @string P A file path
      -- @treturn string everything before the last dir-separator
      -- @see splitpath
      -- @usage
      -- path.dirname("/some/path/file.txt")   -- "/some/path"
      -- path.dirname("file.txt")              -- "" (empty string)
****0 function path.dirname(P)
   86     assert_string(1,P)
   86     local p1 = path.splitpath(P)
   86     return p1
      end

      --- return the file part of a path
      -- @string P A file path
      -- @treturn string
      -- @see splitpath
      -- @usage
      -- path.basename("/some/path/file.txt")  -- "file.txt"
      -- path.basename("/some/path/file/")     -- "" (empty string)
****0 function path.basename(P)
  132     assert_string(1,P)
  132     local _,p2 = path.splitpath(P)
  132     return p2
      end

      --- get the extension part of a path.
      -- @string P A file path
      -- @treturn string
      -- @see splitext
      -- @usage
      -- path.extension("/some/path/file.txt") -- ".txt"
      -- path.extension("/some/path/file_txt") -- "" (empty string)
****0 function path.extension(P)
   12     assert_string(1,P)
   12     local _,p2 = path.splitext(P)
   12     return p2
      end

      --- is this an absolute path?
      -- @string P A file path
      -- @usage
      -- path.isabs("hello/path")    -- false
      -- path.isabs("/hello/path")   -- true
      -- -- Windows;
      -- path.isabs("hello\path")    -- false
      -- path.isabs("\hello\path")   -- true
      -- path.isabs("C:\hello\path") -- true
      -- path.isabs("C:hello\path")  -- false
****0 function path.isabs(P)
****0     assert_string(1,P)
****0     if path.is_windows and at(P,2) == ":" then
****0         return seps[at(P,3)] ~= nil
          end
****0     return seps[at(P,1)] ~= nil
      end

      --- return the path resulting from combining the individual paths.
      -- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
      -- empty elements (except the last) will be ignored.
      -- @string p1 A file path
      -- @string p2 A file path
      -- @string ... more file paths
      -- @treturn string the combined path
      -- @usage
      -- path.join("/first","second","third")   -- "/first/second/third"
      -- path.join("first","second/third")      -- "first/second/third"
      -- path.join("/first","/second","third")  -- "/second/third"
****0 function path.join(p1,p2,...)
****0     assert_string(1,p1)
****0     assert_string(2,p2)
****0     if select('#',...) > 0 then
****0         local p = path.join(p1,p2)
****0         local args = {...}
****0         for i = 1,#args do
****0             assert_string(i,args[i])
****0             p = path.join(p,args[i])
              end
****0         return p
          end
****0     if path.isabs(p2) then return p2 end
****0     local endc = at(p1,#p1)
****0     if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
****0         p1 = p1..path.sep
          end
****0     return p1..p2
      end

      --- normalize the case of a pathname. On Unix, this returns the path unchanged,
      -- for Windows it converts;
      --
      -- * the path to lowercase
      -- * forward slashes to backward slashes
      -- @string P A file path
      -- @usage path.normcase("/Some/Path/File.txt")
      -- -- Windows: "\some\path\file.txt"
      -- -- Others : "/Some/Path/File.txt"
****0 function path.normcase(P)
  264     assert_string(1,P)
  264     if path.is_windows then
****0         return P:gsub('/','\\'):lower()
          else
  264         return P
          end
      end

      --- normalize a path name.
      -- `A//B`, `A/./B`, and `A/foo/../B` all become `A/B`.
      --
      -- An empty path results in '.'.
      -- @string P a file path
****0 function path.normpath(P)
****0     assert_string(1,P)
          -- Split path into anchor and relative path.
****0     local anchor = ''
****0     if path.is_windows then
****0         if P:match '^\\\\' then -- UNC
****0             anchor = '\\\\'
****0             P = P:sub(3)
****0         elseif seps[at(P, 1)] then
****0             anchor = '\\'
****0             P = P:sub(2)
****0         elseif at(P, 2) == ':' then
****0             anchor = P:sub(1, 2)
****0             P = P:sub(3)
****0             if seps[at(P, 1)] then
****0                 anchor = anchor..'\\'
****0                 P = P:sub(2)
                  end
              end
****0         P = P:gsub('/','\\')
          else
              -- According to POSIX, in path start '//' and '/' are distinct,
              -- but '///+' is equivalent to '/'.
****0         if P:match '^//' and at(P, 3) ~= '/' then
****0             anchor = '//'
****0             P = P:sub(3)
****0         elseif at(P, 1) == '/' then
****0             anchor = '/'
****0             P = P:match '^/*(.*)$'
              end
          end
****0     local parts = {}
****0     for part in P:gmatch('[^'..sep..']+') do
****0         if part == '..' then
****0             if #parts ~= 0 and parts[#parts] ~= '..' then
****0                 remove(parts)
                  else
****0                 append(parts, part)
                  end
****0         elseif part ~= '.' then
****0             append(parts, part)
              end
          end
****0     P = anchor..concat(parts, sep)
****0     if P == '' then P = '.' end
****0     return P
      end

      --- relative path from current directory or optional start point
      -- @string P a path
      -- @string[opt] start optional start point (default current directory)
****0 function path.relpath (P,start)
****0     assert_string(1,P)
****0     if start then assert_string(2,start) end
****0     local split,min,append = utils.split, math.min, table.insert
****0     P = path.abspath(P,start)
****0     start = start or currentdir()
          local compare
****0     if path.is_windows then
****0         P = P:gsub("/","\\")
****0         start = start:gsub("/","\\")
****0         compare = function(v) return v:lower() end
          else
****0         compare = function(v) return v end
          end
****0     local startl, Pl = split(start,sep), split(P,sep)
****0     local n = min(#startl,#Pl)
****0     if path.is_windows and n > 0 and at(Pl[1],2) == ':' and Pl[1] ~= startl[1] then
****0         return P
          end
****0     local k = n+1 -- default value if this loop doesn't bail out!
****0     for i = 1,n do
****0         if compare(startl[i]) ~= compare(Pl[i]) then
****0             k = i
                  break
              end
          end
****0     local rell = {}
****0     for i = 1, #startl-k+1 do rell[i] = '..' end
****0     if k <= #Pl then
****0         for i = k,#Pl do append(rell,Pl[i]) end
          end
****0     return table.concat(rell,sep)
      end


      --- Replace a starting '~' with the user's home directory.
      -- In windows, if HOME isn't set, then USERPROFILE is used in preference to
      -- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
      -- @string P A file path
****0 function path.expanduser(P)
****0     assert_string(1,P)
****0     if at(P,1) == '~' then
****0         local home = getenv('HOME')
****0         if not home then -- has to be Windows
****0             home = getenv 'USERPROFILE' or (getenv 'HOMEDRIVE' .. getenv 'HOMEPATH')
              end
****0         return home..sub(P,2)
          else
****0         return P
          end
      end


      ---Return a suitable full path to a new temporary file name.
      -- unlike os.tmpname(), it always gives you a writeable path (uses TEMP environment variable on Windows)
****0 function path.tmpname ()
****0     local res = tmpnam()
          -- On Windows if Lua is compiled using MSVC14 os.tmpname
          -- already returns an absolute path within TEMP env variable directory,
          -- no need to prepend it.
****0     if path.is_windows and not res:find(':') then
****0         res = getenv('TEMP')..res
          end
****0     return res
      end

      --- return the largest common prefix path of two paths.
      -- @string path1 a file path
      -- @string path2 a file path
      -- @return the common prefix (Windows: separators will be normalized, casing will be original)
****0 function path.common_prefix (path1,path2)
****0     assert_string(1,path1)
****0     assert_string(2,path2)
          -- get them in order!
****0     if #path1 > #path2 then path2,path1 = path1,path2 end
          local compare
****0     if path.is_windows then
****0         path1 = path1:gsub("/", "\\")
****0         path2 = path2:gsub("/", "\\")
****0         compare = function(v) return v:lower() end
          else
****0         compare = function(v) return v end
          end
****0     for i = 1,#path1 do
****0         if compare(at(path1,i)) ~= compare(at(path2,i)) then
****0             local cp = path1:sub(1,i-1)
****0             if at(path1,i-1) ~= sep then
****0                 cp = path.dirname(cp)
                  end
****0             return cp
              end
          end
****0     if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
****0     return path1
          --return ''
      end

      --- return the full path where a particular Lua module would be found.
      -- Both package.path and package.cpath is searched, so the result may
      -- either be a Lua file or a shared library.
      -- @string mod name of the module
      -- @return on success: path of module, lua or binary
      -- @return on error: nil, error string listing paths tried
****0 function path.package_path(mod)
****0     assert_string(1,mod)
          local res, err1, err2
****0     res, err1 = package.searchpath(mod,package.path)
****0     if res then return res,true end
****0     res, err2 = package.searchpath(mod,package.cpath)
****0     if res then return res,false end
****0     return raise ('cannot find module on path\n' .. err1 .. "\n" .. err2)
      end


      ---- finis -----
****0 return path

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/pl/tablex.lua
==============================================================================
      --- Extended operations on Lua tables.
      --
      -- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
      --
      -- Dependencies: `pl.utils`, `pl.types`
      -- @module pl.tablex
****0 local utils = require ('pl.utils')
****0 local types = require ('pl.types')
****0 local getmetatable,setmetatable,require = getmetatable,setmetatable,require
****0 local tsort,append,remove = table.sort,table.insert,table.remove
****0 local min = math.min
****0 local pairs,type,unpack,select,tostring = pairs,type,utils.unpack,select,tostring
****0 local function_arg = utils.function_arg
****0 local assert_arg = utils.assert_arg

****0 local tablex = {}

      -- generally, functions that make copies of tables try to preserve the metatable.
      -- However, when the source has no obvious type, then we attach appropriate metatables
      -- like List, Map, etc to the result.
      local function setmeta (res,tbl,pl_class)
    8     local mt = getmetatable(tbl) or pl_class and require('pl.' .. pl_class)
    8     return mt and setmetatable(res, mt) or res
      end

      local function makelist(l)
****0     return setmetatable(l, require('pl.List'))
      end

      local function makemap(m)
****0     return setmetatable(m, require('pl.Map'))
      end

      local function complain (idx,msg)
****0     error(('argument %d is not %s'):format(idx,msg),3)
      end

      local function assert_arg_indexable (idx,val)
    8     if not types.is_indexable(val) then
****0         complain(idx,"indexable")
          end
      end

      local function assert_arg_iterable (idx,val)
   14     if not types.is_iterable(val) then
****0         complain(idx,"iterable")
          end
      end

      local function assert_arg_writeable (idx,val)
****0     if not types.is_writeable(val) then
****0         complain(idx,"writeable")
          end
      end

      --- copy a table into another, in-place.
      -- @within Copying
      -- @tab t1 destination table
      -- @tab t2 source (actually any iterable object)
      -- @return first table
****0 function tablex.update (t1,t2)
****0     assert_arg_writeable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     for k,v in pairs(t2) do
****0         t1[k] = v
          end
****0     return t1
      end

      --- total number of elements in this table.
      -- Note that this is distinct from `#t`, which is the number
      -- of values in the array part; this value will always
      -- be greater or equal. The difference gives the size of
      -- the hash part, for practical purposes. Works for any
      -- object with a __pairs metamethod.
      -- @tab t a table
      -- @return the size
****0 function tablex.size (t)
****0     assert_arg_iterable(1,t)
****0     local i = 0
****0     for k in pairs(t) do i = i + 1 end
****0     return i
      end

      --- make a shallow copy of a table
      -- @within Copying
      -- @tab t an iterable source
      -- @return new table
****0 function tablex.copy (t)
   14     assert_arg_iterable(1,t)
   14     local res = {}
  934     for k,v in pairs(t) do
  920         res[k] = v
          end
   14     return res
      end

      local function cycle_aware_copy(t, cache)
****0     if type(t) ~= 'table' then return t end
****0     if cache[t] then return cache[t] end
****0     assert_arg_iterable(1,t)
****0     local res = {}
****0     cache[t] = res
****0     local mt = getmetatable(t)
****0     for k,v in pairs(t) do
****0         k = cycle_aware_copy(k, cache)
****0         v = cycle_aware_copy(v, cache)
****0         res[k] = v
          end
****0     setmetatable(res,mt)
****0     return res
      end

      --- make a deep copy of a table, recursively copying all the keys and fields.
      -- This supports cycles in tables; cycles will be reproduced in the copy.
      -- This will also set the copied table's metatable to that of the original.
      -- @within Copying
      -- @tab t A table
      -- @return new table
****0 function tablex.deepcopy(t)
****0     return cycle_aware_copy(t,{})
      end

****0 local abs = math.abs

      local function cycle_aware_compare(t1,t2,ignore_mt,eps,cache)
****0     if cache[t1] and cache[t1][t2] then return true end
****0     local ty1 = type(t1)
****0     local ty2 = type(t2)
****0     if ty1 ~= ty2 then return false end
          -- non-table types can be directly compared
****0     if ty1 ~= 'table' then
****0         if ty1 == 'number' and eps then return abs(t1-t2) < eps end
****0         return t1 == t2
          end
          -- as well as tables which have the metamethod __eq
****0     local mt = getmetatable(t1)
****0     if not ignore_mt and mt and mt.__eq then return t1 == t2 end
****0     for k1 in pairs(t1) do
****0         if t2[k1]==nil then return false end
          end
****0     for k2 in pairs(t2) do
****0         if t1[k2]==nil then return false end
          end
****0     cache[t1] = cache[t1] or {}
****0     cache[t1][t2] = true
****0     for k1,v1 in pairs(t1) do
****0         local v2 = t2[k1]
****0         if not cycle_aware_compare(v1,v2,ignore_mt,eps,cache) then return false end
          end
****0     return true
      end

      --- compare two values.
      -- if they are tables, then compare their keys and fields recursively.
      -- @within Comparing
      -- @param t1 A value
      -- @param t2 A value
      -- @bool[opt] ignore_mt if true, ignore __eq metamethod (default false)
      -- @number[opt] eps if defined, then used for any number comparisons
      -- @return true or false
****0 function tablex.deepcompare(t1,t2,ignore_mt,eps)
****0     return cycle_aware_compare(t1,t2,ignore_mt,eps,{})
      end

      --- compare two arrays using a predicate.
      -- @within Comparing
      -- @array t1 an array
      -- @array t2 an array
      -- @func cmp A comparison function; `bool = cmp(t1_value, t2_value)`
      -- @return true or false
      -- @usage
      -- assert(tablex.compare({ 1, 2, 3 }, { 1, 2, 3 }, "=="))
      --
      -- assert(tablex.compare(
      --    {1,2,3, hello = "world"},  -- fields are not compared!
      --    {1,2,3}, function(v1, v2) return v1 == v2 end)
****0 function tablex.compare (t1,t2,cmp)
****0     assert_arg_indexable(1,t1)
****0     assert_arg_indexable(2,t2)
****0     if #t1 ~= #t2 then return false end
****0     cmp = function_arg(3,cmp)
****0     for k = 1,#t1 do
****0         if not cmp(t1[k],t2[k]) then return false end
          end
****0     return true
      end

      --- compare two list-like tables using an optional predicate, without regard for element order.
      -- @within Comparing
      -- @array t1 a list-like table
      -- @array t2 a list-like table
      -- @param cmp A comparison function (may be nil)
****0 function tablex.compare_no_order (t1,t2,cmp)
****0     assert_arg_indexable(1,t1)
****0     assert_arg_indexable(2,t2)
****0     if cmp then cmp = function_arg(3,cmp) end
****0     if #t1 ~= #t2 then return false end
****0     local visited = {}
****0     for i = 1,#t1 do
****0         local val = t1[i]
              local gotcha
****0         for j = 1,#t2 do
****0             if not visited[j] then
                      local match
****0                 if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
****0                 if match then
****0                     gotcha = j
                          break
                      end
                  end
              end
****0         if not gotcha then return false end
****0         visited[gotcha] = true
          end
****0     return true
      end


      --- return the index of a value in a list.
      -- Like string.find, there is an optional index to start searching,
      -- which can be negative.
      -- @within Finding
      -- @array t A list-like table
      -- @param val A value
      -- @int idx index to start; -1 means last element,etc (default 1)
      -- @return index of value or nil if not found
      -- @usage find({10,20,30},20) == 2
      -- @usage find({'a','b','a','c'},'a',2) == 3
****0 function tablex.find(t,val,idx)
****0     assert_arg_indexable(1,t)
****0     idx = idx or 1
****0     if idx < 0 then idx = #t + idx + 1 end
****0     for i = idx,#t do
****0         if t[i] == val then return i end
          end
****0     return nil
      end

      --- return the index of a value in a list, searching from the end.
      -- Like string.find, there is an optional index to start searching,
      -- which can be negative.
      -- @within Finding
      -- @array t A list-like table
      -- @param val A value
      -- @param idx index to start; -1 means last element,etc (default `#t`)
      -- @return index of value or nil if not found
      -- @usage rfind({10,10,10},10) == 3
****0 function tablex.rfind(t,val,idx)
****0     assert_arg_indexable(1,t)
****0     idx = idx or #t
****0     if idx < 0 then idx = #t + idx + 1 end
****0     for i = idx,1,-1 do
****0         if t[i] == val then return i end
          end
****0     return nil
      end


      --- return the index (or key) of a value in a table using a comparison function.
      --
      -- *NOTE*: the 2nd return value of this function, the value returned
      -- by the comparison function, has a limitation that it cannot be `false`.
      -- Because if it is, then it indicates the comparison failed, and the
      -- function will continue the search. See examples.
      -- @within Finding
      -- @tab t A table
      -- @func cmp A comparison function
      -- @param arg an optional second argument to the function
      -- @return index of value, or nil if not found
      -- @return value returned by comparison function (cannot be `false`!)
      -- @usage
      -- -- using an operator
      -- local lst = { "Rudolph", true, false, 15 }
      -- local idx, cmp_result = tablex.rfind(lst, "==", "Rudolph")
      -- assert(idx == 1)
      -- assert(cmp_result == true)
      --
      -- local idx, cmp_result = tablex.rfind(lst, "==", false)
      -- assert(idx == 3)
      -- assert(cmp_result == true)       -- looking up 'false' works!
      --
      -- -- using a function returning the value looked up
      -- local cmp = function(v1, v2) return v1 == v2 and v2 end
      -- local idx, cmp_result = tablex.rfind(lst, cmp, "Rudolph")
      -- assert(idx == 1)
      -- assert(cmp_result == "Rudolph")  -- the value is returned
      --
      -- -- NOTE: this fails, since 'false' cannot be returned!
      -- local idx, cmp_result = tablex.rfind(lst, cmp, false)
      -- assert(idx == nil)               -- looking up 'false' failed!
      -- assert(cmp_result == nil)
****0 function tablex.find_if(t,cmp,arg)
****0     assert_arg_iterable(1,t)
****0     cmp = function_arg(2,cmp)
****0     for k,v in pairs(t) do
****0         local c = cmp(v,arg)
****0         if c then return k,c end
          end
****0     return nil
      end

      --- return a list of all values in a table indexed by another list.
      -- @tab tbl a table
      -- @array idx an index table (a list of keys)
      -- @return a list-like table
      -- @usage index_by({10,20,30,40},{2,4}) == {20,40}
      -- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
****0 function tablex.index_by(tbl,idx)
****0     assert_arg_indexable(1,tbl)
****0     assert_arg_indexable(2,idx)
****0     local res = {}
****0     for i = 1,#idx do
****0         res[i] = tbl[idx[i]]
          end
****0     return setmeta(res,tbl,'List')
      end

      --- apply a function to all values of a table.
      -- This returns a table of the results.
      -- Any extra arguments are passed to the function.
      -- @within MappingAndFiltering
      -- @func fun A function that takes at least one argument
      -- @tab t A table
      -- @param ... optional arguments
      -- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
****0 function tablex.map(fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t) do
****0         res[k] = fun(v,...)
          end
****0     return setmeta(res,t)
      end

      --- apply a function to all values of a list.
      -- This returns a table of the results.
      -- Any extra arguments are passed to the function.
      -- @within MappingAndFiltering
      -- @func fun A function that takes at least one argument
      -- @array t a table (applies to array part)
      -- @param ... optional arguments
      -- @return a list-like table
      -- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
****0 function tablex.imap(fun,t,...)
****0     assert_arg_indexable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for i = 1,#t do
****0         res[i] = fun(t[i],...) or false
          end
****0     return setmeta(res,t,'List')
      end

      --- apply a named method to values from a table.
      -- @within MappingAndFiltering
      -- @string name the method name
      -- @array t a list-like table
      -- @param ... any extra arguments to the method
      -- @return a `List` with the results of the method (1st result only)
      -- @usage
      -- local Car = {}
      -- Car.__index = Car
      -- function Car.new(car)
      --   return setmetatable(car or {}, Car)
      -- end
      -- Car.speed = 0
      -- function Car:faster(increase)
      --   self.speed = self.speed + increase
      --   return self.speed
      -- end
      --
      -- local ferrari = Car.new{ name = "Ferrari" }
      -- local lamborghini = Car.new{ name = "Lamborghini", speed = 50 }
      -- local cars = { ferrari, lamborghini }
      --
      -- assert(ferrari.speed == 0)
      -- assert(lamborghini.speed == 50)
      -- tablex.map_named_method("faster", cars, 10)
      -- assert(ferrari.speed == 10)
      -- assert(lamborghini.speed == 60)
****0 function tablex.map_named_method (name,t,...)
****0     utils.assert_string(1,name)
****0     assert_arg_indexable(2,t)
****0     local res = {}
****0     for i = 1,#t do
****0         local val = t[i]
****0         local fun = val[name]
****0         res[i] = fun(val,...)
          end
****0     return setmeta(res,t,'List')
      end

      --- apply a function to all values of a table, in-place.
      -- Any extra arguments are passed to the function.
      -- @func fun A function that takes at least one argument
      -- @tab t a table
      -- @param ... extra arguments passed to `fun`
      -- @see tablex.foreach
****0 function tablex.transform (fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     for k,v in pairs(t) do
****0         t[k] = fun(v,...)
          end
      end

      --- generate a table of all numbers in a range.
      -- This is consistent with a numerical for loop.
      -- @int start  number
      -- @int finish number
      -- @int[opt=1] step  make this negative for start < finish
****0 function tablex.range (start,finish,step)
          local res
****0     step = step or 1
****0     if start == finish then
****0         res = {start}
****0     elseif (start > finish and step > 0) or (finish > start and step < 0) then
****0         res = {}
          else
****0         local k = 1
****0         res = {}
****0         for i=start,finish,step do res[k]=i; k=k+1 end
          end
****0     return makelist(res)
      end

      --- apply a function to values from two tables.
      -- @within MappingAndFiltering
      -- @func fun a function of at least two arguments
      -- @tab t1 a table
      -- @tab t2 a table
      -- @param ... extra arguments
      -- @return a table
      -- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
****0 function tablex.map2 (fun,t1,t2,...)
****0     assert_arg_iterable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t1) do
****0         res[k] = fun(v,t2[k],...)
          end
****0     return setmeta(res,t1,'List')
      end

      --- apply a function to values from two arrays.
      -- The result will be the length of the shortest array.
      -- @within MappingAndFiltering
      -- @func fun a function of at least two arguments
      -- @array t1 a list-like table
      -- @array t2 a list-like table
      -- @param ... extra arguments
      -- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
****0 function tablex.imap2 (fun,t1,t2,...)
****0     assert_arg_indexable(2,t1)
****0     assert_arg_indexable(3,t2)
****0     fun = function_arg(1,fun)
****0     local res,n = {},math.min(#t1,#t2)
****0     for i = 1,n do
****0         res[i] = fun(t1[i],t2[i],...)
          end
****0     return res
      end

      --- 'reduce' a list using a binary function.
      -- @func fun a function of two arguments
      -- @array t a list-like table
      -- @array memo optional initial memo value. Defaults to first value in table.
      -- @return the result of the function
      -- @usage reduce('+',{1,2,3,4}) == 10
****0 function tablex.reduce (fun,t,memo)
****0     assert_arg_indexable(2,t)
****0     fun = function_arg(1,fun)
****0     local n = #t
****0     if n == 0 then
****0         return memo
          end
****0     local res = memo and fun(memo, t[1]) or t[1]
****0     for i = 2,n do
****0         res = fun(res,t[i])
          end
****0     return res
      end

      --- apply a function to all elements of a table.
      -- The arguments to the function will be the value,
      -- the key and _finally_ any extra arguments passed to this function.
      -- Note that the Lua 5.0 function table.foreach passed the _key_ first.
      -- @within Iterating
      -- @tab t a table
      -- @func fun a function on the elements; `function(value, key, ...)`
      -- @param ... extra arguments passed to `fun`
      -- @see tablex.transform
****0 function tablex.foreach(t,fun,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(2,fun)
****0     for k,v in pairs(t) do
****0         fun(v,k,...)
          end
      end

      --- apply a function to all elements of a list-like table in order.
      -- The arguments to the function will be the value,
      -- the index and _finally_ any extra arguments passed to this function
      -- @within Iterating
      -- @array t a table
      -- @func fun a function with at least one argument
      -- @param ... optional arguments
****0 function tablex.foreachi(t,fun,...)
****0     assert_arg_indexable(1,t)
****0     fun = function_arg(2,fun)
****0     for i = 1,#t do
****0         fun(t[i],i,...)
          end
      end

      --- Apply a function to a number of tables.
      -- A more general version of map
      -- The result is a table containing the result of applying that function to the
      -- ith value of each table. Length of output list is the minimum length of all the lists
      -- @within MappingAndFiltering
      -- @func fun a function of n arguments
      -- @tab ... n tables
      -- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
      -- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is    {100,200,300}
      -- @param fun A function that takes as many arguments as there are tables
****0 function tablex.mapn(fun,...)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     local lists = {...}
****0     local minn = 1e40
****0     for i = 1,#lists do
****0         minn = min(minn,#(lists[i]))
          end
****0     for i = 1,minn do
****0         local args,k = {},1
****0         for j = 1,#lists do
****0             args[k] = lists[j][i]
****0             k = k + 1
              end
****0         res[#res+1] = fun(unpack(args))
          end
****0     return res
      end

      --- call the function with the key and value pairs from a table.
      -- The function can return a value and a key (note the order!). If both
      -- are not nil, then this pair is inserted into the result: if the key already exists, we convert the value for that
      -- key into a table and append into it. If only value is not nil, then it is appended to the result.
      -- @within MappingAndFiltering
      -- @func fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
      -- @tab t A table
      -- @param ... optional arguments
      -- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
      -- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
****0 function tablex.pairmap(fun,t,...)
****0     assert_arg_iterable(1,t)
****0     fun = function_arg(1,fun)
****0     local res = {}
****0     for k,v in pairs(t) do
****0         local rv,rk = fun(k,v,...)
****0         if rk then
****0             if res[rk] then
****0                 if type(res[rk]) == 'table' then
****0                     table.insert(res[rk],rv)
                      else
****0                     res[rk] = {res[rk], rv}
                      end
                  else
****0                 res[rk] = rv
                  end
              else
****0             res[#res+1] = rv
              end
          end
****0     return res
      end

****0 local function keys_op(i,v) return i end

      --- return all the keys of a table in arbitrary order.
      -- @within Extraction
      --  @tab t A table
****0 function tablex.keys(t)
****0     assert_arg_iterable(1,t)
****0     return makelist(tablex.pairmap(keys_op,t))
      end

****0 local function values_op(i,v) return v end

      --- return all the values of the table in arbitrary order
      -- @within Extraction
      --  @tab t A table
****0 function tablex.values(t)
****0     assert_arg_iterable(1,t)
****0     return makelist(tablex.pairmap(values_op,t))
      end

****0 local function index_map_op (i,v) return i,v end

      --- create an index map from a list-like table. The original values become keys,
      -- and the associated values are the indices into the original list.
      -- @array t a list-like table
      -- @return a map-like table
****0 function tablex.index_map (t)
****0     assert_arg_indexable(1,t)
****0     return makemap(tablex.pairmap(index_map_op,t))
      end

****0 local function set_op(i,v) return true,v end

      --- create a set from a list-like table. A set is a table where the original values
      -- become keys, and the associated values are all true.
      -- @array t a list-like table
      -- @return a set (a map-like table)
****0 function tablex.makeset (t)
****0     assert_arg_indexable(1,t)
****0     return setmetatable(tablex.pairmap(set_op,t),require('pl.Set'))
      end

      --- combine two tables, either as union or intersection. Corresponds to
      -- set operations for sets () but more general. Not particularly
      -- useful for list-like tables.
      -- @within Merging
      -- @tab t1 a table
      -- @tab t2 a table
      -- @bool dup true for a union, false for an intersection.
      -- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
      -- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
      -- @see tablex.index_map
****0 function tablex.merge (t1,t2,dup)
****0     assert_arg_iterable(1,t1)
****0     assert_arg_iterable(2,t2)
****0     local res = {}
****0     for k,v in pairs(t1) do
****0         if dup or t2[k] then res[k] = v end
          end
****0     if dup then
****0       for k,v in pairs(t2) do
****0         res[k] = v
            end
          end
****0     return setmeta(res,t1,'Map')
      end

      --- the union of two map-like tables.
      -- If there are duplicate keys, the second table wins.
      -- @tab t1 a table
      -- @tab t2 a table
      -- @treturn tab
      -- @see tablex.merge
****0 function tablex.union(t1, t2)
****0     return tablex.merge(t1, t2, true)
      end

      --- the intersection of two map-like tables.
      -- @tab t1 a table
      -- @tab t2 a table
      -- @treturn tab
      -- @see tablex.merge
****0 function tablex.intersection(t1, t2)
****0     return tablex.merge(t1, t2, false)
      end

      --- a new table which is the difference of two tables.
      -- With sets (where the values are all true) this is set difference and
      -- symmetric difference depending on the third parameter.
      -- @within Merging
      -- @tab s1 a map-like table or set
      -- @tab s2 a map-like table or set
      -- @bool symm symmetric difference (default false)
      -- @return a map-like table or set
****0 function tablex.difference (s1,s2,symm)
****0     assert_arg_iterable(1,s1)
****0     assert_arg_iterable(2,s2)
****0     local res = {}
****0     for k,v in pairs(s1) do
****0         if s2[k] == nil then res[k] = v end
          end
****0     if symm then
****0         for k,v in pairs(s2) do
****0             if s1[k] == nil then res[k] = v end
              end
          end
****0     return setmeta(res,s1,'Map')
      end

      --- A table where the key/values are the values and value counts of the table.
      -- @array t a list-like table
      -- @func cmp a function that defines equality (otherwise uses ==)
      -- @return a map-like table
      -- @see seq.count_map
****0 function tablex.count_map (t,cmp)
****0     assert_arg_indexable(1,t)
****0     local res,mask = {},{}
****0     cmp = function_arg(2,cmp or '==')
****0     local n = #t
****0     for i = 1,#t do
****0         local v = t[i]
****0         if not mask[v] then
****0             mask[v] = true
                  -- check this value against all other values
****0             res[v] = 1  -- there's at least one instance
****0             for j = i+1,n do
****0                 local w = t[j]
****0                 local ok = cmp(v,w)
****0                 if ok then
****0                     res[v] = res[v] + 1
****0                     mask[w] = true
                      end
                  end
              end
          end
****0     return makemap(res)
      end

      --- filter an array's values using a predicate function
      -- @within MappingAndFiltering
      -- @array t a list-like table
      -- @func pred a boolean function
      -- @param arg optional argument to be passed as second argument of the predicate
****0 function tablex.filter (t,pred,arg)
    8     assert_arg_indexable(1,t)
    8     pred = function_arg(2,pred)
    8     local res,k = {},1
  152     for i = 1,#t do
  144         local v = t[i]
  144         if pred(v,arg) then
   24             res[k] = v
   24             k = k + 1
              end
          end
    8     return setmeta(res,t,'List')
      end

      --- return a table where each element is a table of the ith values of an arbitrary
      -- number of tables. It is equivalent to a matrix transpose.
      -- @within Merging
      -- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
      -- @array ... arrays to be zipped
****0 function tablex.zip(...)
****0     return tablex.mapn(function(...) return {...} end,...)
      end

      local _copy
****0 function _copy (dest,src,idest,isrc,nsrc,clean_tail)
****0     idest = idest or 1
****0     isrc = isrc or 1
          local iend
****0     if not nsrc then
****0         nsrc = #src
****0         iend = #src
          else
****0         iend = isrc + min(nsrc-1,#src-isrc)
          end
****0     if dest == src then -- special case
****0         if idest > isrc and iend >= idest then -- overlapping ranges
****0             src = tablex.sub(src,isrc,nsrc)
****0             isrc = 1; iend = #src
              end
          end
****0     for i = isrc,iend do
****0         dest[idest] = src[i]
****0         idest = idest + 1
          end
****0     if clean_tail then
****0         tablex.clear(dest,idest)
          end
****0     return dest
      end

      --- copy an array into another one, clearing `dest` after `idest+nsrc`, if necessary.
      -- @within Copying
      -- @array dest a list-like table
      -- @array src a list-like table
      -- @int[opt=1] idest where to start copying values into destination
      -- @int[opt=1] isrc where to start copying values from source
      -- @int[opt=#src] nsrc number of elements to copy from source
****0 function tablex.icopy (dest,src,idest,isrc,nsrc)
****0     assert_arg_indexable(1,dest)
****0     assert_arg_indexable(2,src)
****0     return _copy(dest,src,idest,isrc,nsrc,true)
      end

      --- copy an array into another one.
      -- @within Copying
      -- @array dest a list-like table
      -- @array src a list-like table
      -- @int[opt=1] idest where to start copying values into destination
      -- @int[opt=1] isrc where to start copying values from source
      -- @int[opt=#src] nsrc number of elements to copy from source
****0 function tablex.move (dest,src,idest,isrc,nsrc)
****0     assert_arg_indexable(1,dest)
****0     assert_arg_indexable(2,src)
****0     return _copy(dest,src,idest,isrc,nsrc,false)
      end

****0 function tablex._normalize_slice(self,first,last)
****0   local sz = #self
****0   if not first then first=1 end
****0   if first<0 then first=sz+first+1 end
        -- make the range _inclusive_!
****0   if not last then last=sz end
****0   if last < 0 then last=sz+1+last end
****0   return first,last
      end

      --- Extract a range from a table, like  'string.sub'.
      -- If first or last are negative then they are relative to the end of the list
      -- eg. sub(t,-2) gives last 2 entries in a list, and
      -- sub(t,-4,-2) gives from -4th to -2nd
      -- @within Extraction
      -- @array t a list-like table
      -- @int first An index
      -- @int last An index
      -- @return a new List
****0 function tablex.sub(t,first,last)
****0     assert_arg_indexable(1,t)
****0     first,last = tablex._normalize_slice(t,first,last)
****0     local res={}
****0     for i=first,last do append(res,t[i]) end
****0     return setmeta(res,t,'List')
      end

      --- set an array range to a value. If it's a function we use the result
      -- of applying it to the indices.
      -- @array t a list-like table
      -- @param val a value
      -- @int[opt=1] i1 start range
      -- @int[opt=#t] i2 end range
****0 function tablex.set (t,val,i1,i2)
****0     assert_arg_indexable(1,t)
****0     i1,i2 = i1 or 1,i2 or #t
****0     if types.is_callable(val) then
****0         for i = i1,i2 do
****0             t[i] = val(i)
              end
          else
****0         for i = i1,i2 do
****0             t[i] = val
              end
          end
      end

      --- create a new array of specified size with initial value.
      -- @int n size
      -- @param val initial value (can be `nil`, but don't expect `#` to work!)
      -- @return the table
****0 function tablex.new (n,val)
****0     local res = {}
****0     tablex.set(res,val,1,n)
****0     return res
      end

      --- clear out the contents of a table.
      -- @array t a list
      -- @param istart optional start position
****0 function tablex.clear(t,istart)
****0     istart = istart or 1
****0     for i = istart,#t do remove(t) end
      end

      --- insert values into a table.
      -- similar to `table.insert` but inserts values from given table `values`,
      -- not the object itself, into table `t` at position `pos`.
      -- @within Copying
      -- @array t the list
      -- @int[opt] position (default is at end)
      -- @array values
****0 function tablex.insertvalues(t, ...)
    4     assert_arg(1,t,'table')
          local pos, values
    4     if select('#', ...) == 1 then
    4         pos,values = #t+1, ...
          else
****0         pos,values = ...
          end
    4     if #values > 0 then
    4         for i=#t,pos,-1 do
****0             t[i+#values] = t[i]
              end
    4         local offset = 1 - pos
   16         for i=pos,pos+#values-1 do
   12             t[i] = values[i + offset]
              end
          end
    4     return t
      end

      --- remove a range of values from a table.
      -- End of range may be negative.
      -- @array t a list-like table
      -- @int i1 start index
      -- @int i2 end index
      -- @return the table
****0 function tablex.removevalues (t,i1,i2)
****0     assert_arg(1,t,'table')
****0     i1,i2 = tablex._normalize_slice(t,i1,i2)
****0     for i = i1,i2 do
****0         remove(t,i1)
          end
****0     return t
      end

      local _find
      _find = function (t,value,tables)
****0     for k,v in pairs(t) do
****0         if v == value then return k end
          end
****0     for k,v in pairs(t) do
****0         if not tables[v] and type(v) == 'table' then
****0             tables[v] = true
****0             local res = _find(v,value,tables)
****0             if res then
****0                 res = tostring(res)
****0                 if type(k) ~= 'string' then
****0                     return '['..k..']'..res
                      else
****0                     return k..'.'..res
                      end
                  end
              end
          end
      end

      --- find a value in a table by recursive search.
      -- @within Finding
      -- @tab t the table
      -- @param value the value
      -- @array[opt] exclude any tables to avoid searching
      -- @return a fieldspec, e.g. 'a.b' or 'math.sin'
      -- @usage search(_G,math.sin,{package.path}) == 'math.sin'
****0 function tablex.search (t,value,exclude)
****0     assert_arg_iterable(1,t)
****0     local tables = {[t]=true}
****0     if exclude then
****0         for _,v in pairs(exclude) do tables[v] = true end
          end
****0     return _find(t,value,tables)
      end

      --- return an iterator to a table sorted by its keys
      -- @within Iterating
      -- @tab t the table
      -- @func f an optional comparison function (f(x,y) is true if x < y)
      -- @usage for k,v in tablex.sort(t) do print(k,v) end
      -- @return an iterator to traverse elements sorted by the keys
****0 function tablex.sort(t,f)
****0     local keys = {}
****0     for k in pairs(t) do keys[#keys + 1] = k end
****0     tsort(keys,f)
****0     local i = 0
          return function()
****0         i = i + 1
****0         return keys[i], t[keys[i]]
          end
      end

      --- return an iterator to a table sorted by its values
      -- @within Iterating
      -- @tab t the table
      -- @func f an optional comparison function (f(x,y) is true if x < y)
      -- @usage for k,v in tablex.sortv(t) do print(k,v) end
      -- @return an iterator to traverse elements sorted by the values
****0 function tablex.sortv(t,f)
****0     f = function_arg(2, f or '<')
****0     local keys = {}
****0     for k in pairs(t) do keys[#keys + 1] = k end
****0     tsort(keys,function(x, y) return f(t[x], t[y]) end)
****0     local i = 0
          return function()
****0         i = i + 1
****0         return keys[i], t[keys[i]]
          end
      end

      --- modifies a table to be read only.
      -- This only offers weak protection. Tables can still be modified with
      -- `table.insert` and `rawset`.
      --
      -- *NOTE*: for Lua 5.1 length, pairs and ipairs will not work, since the
      -- equivalent metamethods are only available in Lua 5.2 and newer.
      -- @tab t the table
      -- @return the table read only (a proxy).
****0 function tablex.readonly(t)
****0     local mt = {
              __index=t,
              __newindex=function(t, k, v) error("Attempt to modify read-only table", 2) end,
              __pairs=function() return pairs(t) end,
              __ipairs=function() return ipairs(t) end,
              __len=function() return #t end,
****0         __metatable=false
          }
****0     return setmetatable({}, mt)
      end

****0 return tablex

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/pl/types.lua
==============================================================================
      ---- Dealing with Detailed Type Information

      -- Dependencies `pl.utils`
      -- @module pl.types

****0 local utils = require 'pl.utils'
****0 local math_ceil = math.ceil
****0 local assert_arg = utils.assert_arg
****0 local types = {}

      --- is the object either a function or a callable object?.
      -- @param obj Object to check.
****0 function types.is_callable (obj)
****0     return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call and true
      end

      --- is the object of the specified type?.
      -- If the type is a string, then use type, otherwise compare with metatable.
      --
      -- NOTE: this function is imported from `utils.is_type`.
      -- @param obj An object to check
      -- @param tp The expected type
      -- @function is_type
      -- @see utils.is_type
****0 types.is_type = utils.is_type

****0 local fileMT = getmetatable(io.stdout)

      --- a string representation of a type.
      -- For tables and userdata with metatables, we assume that the metatable has a `_name`
      -- field. If the field is not present it will return 'unknown table' or
      -- 'unknown userdata'.
      -- Lua file objects return the type 'file'.
      -- @param obj an object
      -- @return a string like 'number', 'table', 'file' or 'List'
****0 function types.type (obj)
****0     local t = type(obj)
****0     if t == 'table' or t == 'userdata' then
****0         local mt = getmetatable(obj)
****0         if mt == fileMT then
****0             return 'file'
****0         elseif mt == nil then
****0             return t
              else
                  -- TODO: the "unknown" is weird, it should just return the type
****0             return mt._name or "unknown "..t
              end
          else
****0         return t
          end
      end

      --- is this number an integer?
      -- @param x a number
      -- @raise error if x is not a number
      -- @return boolean
****0 function types.is_integer (x)
****0     return math_ceil(x)==x
      end

      --- Check if the object is "empty".
      -- An object is considered empty if it is:
      --
      -- - `nil`
      -- - a table without any items (key-value pairs or indexes)
      -- - a string with no content ("")
      -- - not a nil/table/string
      -- @param o The object to check if it is empty.
      -- @param ignore_spaces If the object is a string and this is true the string is
      -- considered empty if it only contains spaces.
      -- @return `true` if the object is empty, otherwise a falsy value.
****0 function types.is_empty(o, ignore_spaces)
****0     if o == nil then
****0         return true
****0     elseif type(o) == "table" then
****0         return next(o) == nil
****0     elseif type(o) == "string" then
****0         return o == "" or (not not ignore_spaces and (not not o:find("^%s+$")))
          else
****0         return true
          end
      end

      local function check_meta (val)
   22     if type(val) == 'table' then return true end
****0     return getmetatable(val)
      end

      --- is an object 'array-like'?
      -- An object is array like if:
      --
      -- - it is a table, or
      -- - it has a metatable with `__len` and `__index` methods
      --
      -- NOTE: since `__len` is 5.2+, on 5.1 is usually returns `false` for userdata
      -- @param val any value.
      -- @return `true` if the object is array-like, otherwise a falsy value.
****0 function types.is_indexable (val)
    8     local mt = check_meta(val)
    8     if mt == true then return true end
****0     return mt and mt.__len and mt.__index and true
      end

      --- can an object be iterated over with `pairs`?
      -- An object is iterable if:
      --
      -- - it is a table, or
      -- - it has a metatable with a `__pairs` meta method
      --
      -- NOTE: since `__pairs` is 5.2+, on 5.1 is usually returns `false` for userdata
      -- @param val any value.
      -- @return `true` if the object is iterable, otherwise a falsy value.
****0 function types.is_iterable (val)
   14     local mt = check_meta(val)
   14     if mt == true then return true end
****0     return mt and mt.__pairs and true
      end

      --- can an object accept new key/pair values?
      -- An object is iterable if:
      --
      -- - it is a table, or
      -- - it has a metatable with a `__newindex` meta method
      --
      -- @param val any value.
      -- @return `true` if the object is writeable, otherwise a falsy value.
****0 function types.is_writeable (val)
****0     local mt = check_meta(val)
****0     if mt == true then return true end
****0     return mt and mt.__newindex and true
      end

      -- Strings that should evaluate to true.   -- TODO: add on/off ???
****0 local trues = { yes=true, y=true, ["true"]=true, t=true, ["1"]=true }
      -- Conditions types should evaluate to true.
****0 local true_types = {
          boolean=function(o, true_strs, check_objs) return o end,
          string=function(o, true_strs, check_objs)
****0         o = o:lower()
****0         if trues[o] then
****0             return true
              end
              -- Check alternative user provided strings.
****0         for _,v in ipairs(true_strs or {}) do
****0             if type(v) == "string" and o == v:lower() then
****0                 return true
                  end
              end
****0         return false
          end,
          number=function(o, true_strs, check_objs) return o ~= 0 end,
****0     table=function(o, true_strs, check_objs) if check_objs and next(o) ~= nil then return true end return false end
      }
      --- Convert to a boolean value.
      -- True values are:
      --
      -- * boolean: true.
      -- * string: 'yes', 'y', 'true', 't', '1' or additional strings specified by `true_strs`.
      -- * number: Any non-zero value.
      -- * table: Is not empty and `check_objs` is true.
      -- * everything else: Is not `nil` and `check_objs` is true.
      --
      -- @param o The object to evaluate.
      -- @param[opt] true_strs optional Additional strings that when matched should evaluate to true. Comparison is case insensitive.
      -- This should be a List of strings. E.g. "ja" to support German.
      -- @param[opt] check_objs True if objects should be evaluated.
      -- @return true if the input evaluates to true, otherwise false.
****0 function types.to_bool(o, true_strs, check_objs)
          local true_func
****0     if true_strs then
****0         assert_arg(2, true_strs, "table")
          end
****0     true_func = true_types[type(o)]
****0     if true_func then
****0         return true_func(o, true_strs, check_objs)
****0     elseif check_objs and o ~= nil then
****0         return true
          end
****0     return false
      end


****0 return types

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/pl/utils.lua
==============================================================================
      --- Generally useful routines.
      -- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
      --
      -- Dependencies: `pl.compat`, all exported fields and functions from
      -- `pl.compat` are also available in this module.
      --
      -- @module pl.utils
****0 local format = string.format
****0 local compat = require 'pl.compat'
****0 local stdout = io.stdout
****0 local append = table.insert
****0 local _unpack = table.unpack  -- always injected by 'compat'

****0 local is_windows = compat.is_windows
****0 local err_mode = 'default'
      local raise
      local operators
****0 local _function_factories = {}


****0 local utils = { _VERSION = "1.11.0" }
****0 for k, v in pairs(compat) do utils[k] = v  end

      --- Some standard patterns
      -- @table patterns
****0 utils.patterns = {
          FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*', -- floating point number
          INTEGER = '[+%-%d]%d*',                     -- integer number
          IDEN = '[%a_][%w_]*',                       -- identifier
          FILE = '[%a%.\\][:%][%w%._%-\\]*',          -- file
      }


      --- Standard meta-tables as used by other Penlight modules
      -- @table stdmt
      -- @field List the List metatable
      -- @field Map the Map metatable
      -- @field Set the Set metatable
      -- @field MultiMap the MultiMap metatable
****0 utils.stdmt = {
          List = {_name='List'},
          Map = {_name='Map'},
          Set = {_name='Set'},
          MultiMap = {_name='MultiMap'},
      }


      --- pack an argument list into a table.
      -- @param ... any arguments
      -- @return a table with field `n` set to the length
      -- @function utils.pack
      -- @see compat.pack
****0 utils.pack = table.pack  -- added here to be symmetrical with unpack

      --- unpack a table and return its contents.
      --
      -- NOTE: this implementation differs from the Lua implementation in the way
      -- that this one DOES honor the `n` field in the table `t`, such that it is 'nil-safe'.
      -- @param t table to unpack
      -- @param[opt] i index from which to start unpacking, defaults to 1
      -- @param[opt] t index of the last element to unpack, defaults to `t.n` or `#t`
      -- @return multiple return values from the table
      -- @function utils.unpack
      -- @see compat.unpack
      -- @usage
      -- local t = table.pack(nil, nil, nil, 4)
      -- local a, b, c, d = table.unpack(t)   -- this `unpack` is NOT nil-safe, so d == nil
      --
      -- local a, b, c, d = utils.unpack(t)   -- this is nil-safe, so d == 4
****0 function utils.unpack(t, i, j)
****0     return _unpack(t, i or 1, j or t.n or #t)
      end

      --- print an arbitrary number of arguments using a format.
      -- Output will be sent to `stdout`.
      -- @param fmt The format (see `string.format`)
      -- @param ... Extra arguments for format
****0 function utils.printf(fmt, ...)
****0     utils.assert_string(1, fmt)
****0     utils.fprintf(stdout, fmt, ...)
      end

      --- write an arbitrary number of arguments to a file using a format.
      -- @param f File handle to write to.
      -- @param fmt The format (see `string.format`).
      -- @param ... Extra arguments for format
****0 function utils.fprintf(f,fmt,...)
****0     utils.assert_string(2,fmt)
****0     f:write(format(fmt,...))
      end

      do
          local function import_symbol(T,k,v,libname)
****0         local key = rawget(T,k)
              -- warn about collisions!
****0         if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
****0             utils.fprintf(io.stderr,"warning: '%s.%s' will not override existing symbol\n",libname,k)
****0             return
              end
****0         rawset(T,k,v)
          end

          local function lookup_lib(T,t)
****0         for k,v in pairs(T) do
****0             if v == t then return k end
              end
****0         return '?'
          end

****0     local already_imported = {}

          --- take a table and 'inject' it into the local namespace.
          -- @param t The table (table), or module name (string), defaults to this `utils` module table
          -- @param T An optional destination table (defaults to callers environment)
****0     function utils.import(t,T)
****0         T = T or _G
****0         t = t or utils
****0         if type(t) == 'string' then
****0             t = require (t)
              end
****0         local libname = lookup_lib(T,t)
****0         if already_imported[t] then return end
****0         already_imported[t] = libname
****0         for k,v in pairs(t) do
****0             import_symbol(T,k,v,libname)
              end
          end
      end

      --- return either of two values, depending on a condition.
      -- @param cond A condition
      -- @param value1 Value returned if cond is truthy
      -- @param value2 Value returned if cond is falsy
****0 function utils.choose(cond, value1, value2)
****0     return cond and value1 or value2
      end

      --- convert an array of values to strings.
      -- @param t a list-like table
      -- @param[opt] temp (table) buffer to use, otherwise allocate
      -- @param[opt] tostr custom tostring function, called with (value,index). Defaults to `tostring`.
      -- @return the converted buffer
****0 function utils.array_tostring (t,temp,tostr)
****0     temp, tostr = temp or {}, tostr or tostring
****0     for i = 1,#t do
****0         temp[i] = tostr(t[i],i)
          end
****0     return temp
      end



      --- is the object of the specified type?
      -- If the type is a string, then use type, otherwise compare with metatable
      -- @param obj An object to check
      -- @param tp String of what type it should be
      -- @return boolean
      -- @usage utils.is_type("hello world", "string")   --> true
      -- -- or check metatable
      -- local my_mt = {}
      -- local my_obj = setmetatable(my_obj, my_mt)
      -- utils.is_type(my_obj, my_mt)  --> true
****0 function utils.is_type (obj,tp)
****0     if type(tp) == 'string' then return type(obj) == tp end
****0     local mt = getmetatable(obj)
****0     return tp == mt
      end

      --- Error handling
      -- @section Error-handling

      --- assert that the given argument is in fact of the correct type.
      -- @param n argument index
      -- @param val the value
      -- @param tp the type
      -- @param verify an optional verification function
      -- @param msg an optional custom message
      -- @param lev optional stack position for trace, default 2
      -- @return the validated value
      -- @raise if `val` is not the correct type
      -- @usage
      -- local param1 = assert_arg(1,"hello",'table')  --> error: argument 1 expected a 'table', got a 'string'
      -- local param4 = assert_arg(4,'!@#$%^&*','string',path.isdir,'not a directory')
      --      --> error: argument 4: '!@#$%^&*' not a directory
****0 function utils.assert_arg (n,val,tp,verify,msg,lev)
 1164     if type(val) ~= tp then
****0         error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
          end
 1164     if verify and not verify(val) then
****0         error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
          end
 1164     return val
      end

      --- process a function argument.
      -- This is used throughout Penlight and defines what is meant by a function:
      -- Something that is callable, or an operator string as defined by <code>pl.operator</code>,
      -- such as '>' or '#'. If a function factory has been registered for the type, it will
      -- be called to get the function.
      -- @param idx argument index
      -- @param f a function, operator string, or callable object
      -- @param msg optional error message
      -- @return a callable
      -- @raise if idx is not a number or if f is not callable
****0 function utils.function_arg (idx,f,msg)
    8     utils.assert_arg(1,idx,'number')
    8     local tp = type(f)
    8     if tp == 'function' then return f end  -- no worries!
          -- ok, a string can correspond to an operator (like '==')
****0     if tp == 'string' then
****0         if not operators then operators = require 'pl.operator'.optable end
****0         local fn = operators[f]
****0         if fn then return fn end
****0         local fn, err = utils.string_lambda(f)
****0         if not fn then error(err..': '..f) end
****0         return fn
****0     elseif tp == 'table' or tp == 'userdata' then
****0         local mt = getmetatable(f)
****0         if not mt then error('not a callable object',2) end
****0         local ff = _function_factories[mt]
****0         if not ff then
****0             if not mt.__call then error('not a callable object',2) end
****0             return f
              else
****0             return ff(f) -- we have a function factory for this type!
              end
          end
****0     if not msg then msg = " must be callable" end
****0     if idx > 0 then
****0         error("argument "..idx..": "..msg,2)
          else
****0         error(msg,2)
          end
      end


      --- assert the common case that the argument is a string.
      -- @param n argument index
      -- @param val a value that must be a string
      -- @return the validated value
      -- @raise val must be a string
      -- @usage
      -- local val = 42
      -- local param2 = utils.assert_string(2, val) --> error: argument 2 expected a 'string', got a 'number'
****0 function utils.assert_string (n, val)
 1148     return utils.assert_arg(n,val,'string',nil,nil,3)
      end

      --- control the error strategy used by Penlight.
      -- This is a global setting that controls how `utils.raise` behaves:
      --
      -- - 'default': return `nil + error` (this is the default)
      -- - 'error': throw a Lua error
      -- - 'quit': exit the program
      --
      -- @param mode either 'default', 'quit'  or 'error'
      -- @see utils.raise
****0 function utils.on_error (mode)
****0     mode = tostring(mode)
****0     if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
****0       err_mode = mode
          else
            -- fail loudly
****0       local err = "Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'"
****0       if err_mode == 'default' then
****0         error(err, 2)  -- even in 'default' mode fail loud in this case
            end
****0       raise(err)
          end
      end

      --- used by Penlight functions to return errors. Its global behaviour is controlled
      -- by `utils.on_error`.
      -- To use this function you MUST use it in conjunction with `return`, since it might
      -- return `nil + error`.
      -- @param err the error string.
      -- @see utils.on_error
      -- @usage
      -- if some_condition then
      --   return utils.raise("some condition was not met")  -- MUST use 'return'!
      -- end
****0 function utils.raise (err)
****0     if err_mode == 'default' then
****0         return nil, err
****0     elseif err_mode == 'quit' then
****0         return utils.quit(err)
          else
****0         error(err, 2)
          end
      end
****0 raise = utils.raise



      --- File handling
      -- @section files

      --- return the contents of a file as a string
      -- @param filename The file path
      -- @param is_bin open in binary mode
      -- @return file contents
****0 function utils.readfile(filename,is_bin)
****0     local mode = is_bin and 'b' or ''
****0     utils.assert_string(1,filename)
****0     local f,open_err = io.open(filename,'r'..mode)
****0     if not f then return raise (open_err) end
****0     local res,read_err = f:read('*a')
****0     f:close()
****0     if not res then
              -- Errors in io.open have "filename: " prefix,
              -- error in file:read don't, add it.
****0         return raise (filename..": "..read_err)
          end
****0     return res
      end

      --- write a string to a file
      -- @param filename The file path
      -- @param str The string
      -- @param is_bin open in binary mode
      -- @return true or nil
      -- @return error message
      -- @raise error if filename or str aren't strings
****0 function utils.writefile(filename,str,is_bin)
****0     local mode = is_bin and 'b' or ''
****0     utils.assert_string(1,filename)
****0     utils.assert_string(2,str)
****0     local f,err = io.open(filename,'w'..mode)
****0     if not f then return raise(err) end
****0     local ok, write_err = f:write(str)
****0     f:close()
****0     if not ok then
              -- Errors in io.open have "filename: " prefix,
              -- error in file:write don't, add it.
****0         return raise (filename..": "..write_err)
          end
****0     return true
      end

      --- return the contents of a file as a list of lines
      -- @param filename The file path
      -- @return file contents as a table
      -- @raise error if filename is not a string
****0 function utils.readlines(filename)
****0     utils.assert_string(1,filename)
****0     local f,err = io.open(filename,'r')
****0     if not f then return raise(err) end
****0     local res = {}
****0     for line in f:lines() do
****0         append(res,line)
          end
****0     f:close()
****0     return res
      end

      --- OS functions
      -- @section OS-functions

      --- execute a shell command and return the output.
      -- This function redirects the output to tempfiles and returns the content of those files.
      -- @param cmd a shell command
      -- @param bin boolean, if true, read output as binary file
      -- @return true if successful
      -- @return actual return code
      -- @return stdout output (string)
      -- @return errout output (string)
****0 function utils.executeex(cmd, bin)
****0     local outfile = os.tmpname()
****0     local errfile = os.tmpname()

****0     if is_windows and not outfile:find(':') then
****0         outfile = os.getenv('TEMP')..outfile
****0         errfile = os.getenv('TEMP')..errfile
          end
****0     cmd = cmd .. " > " .. utils.quote_arg(outfile) .. " 2> " .. utils.quote_arg(errfile)

****0     local success, retcode = utils.execute(cmd)
****0     local outcontent = utils.readfile(outfile, bin)
****0     local errcontent = utils.readfile(errfile, bin)
****0     os.remove(outfile)
****0     os.remove(errfile)
****0     return success, retcode, (outcontent or ""), (errcontent or "")
      end

      --- Quote and escape an argument of a command.
      -- Quotes a single (or list of) argument(s) of a command to be passed
      -- to `os.execute`, `pl.utils.execute` or `pl.utils.executeex`.
      -- @param argument (string or table/list) the argument to quote. If a list then
      -- all arguments in the list will be returned as a single string quoted.
      -- @return quoted and escaped argument.
      -- @usage
      -- local options = utils.quote_arg {
      --     "-lluacov",
      --     "-e",
      --     "utils = print(require('pl.utils')._VERSION",
      -- }
      -- -- returns: -lluacov -e 'utils = print(require('\''pl.utils'\'')._VERSION'
****0 function utils.quote_arg(argument)
****0     if type(argument) == "table" then
              -- encode an entire table
****0         local r = {}
****0         for i, arg in ipairs(argument) do
****0             r[i] = utils.quote_arg(arg)
              end

****0         return table.concat(r, " ")
          end
          -- only a single argument
****0     if is_windows then
****0         if argument == "" or argument:find('[ \f\t\v]') then
                  -- Need to quote the argument.
                  -- Quotes need to be escaped with backslashes;
                  -- additionally, backslashes before a quote, escaped or not,
                  -- need to be doubled.
                  -- See documentation for CommandLineToArgvW Windows function.
****0             argument = '"' .. argument:gsub([[(\*)"]], [[%1%1\"]]):gsub([[\+$]], "%0%0") .. '"'
              end

              -- os.execute() uses system() C function, which on Windows passes command
              -- to cmd.exe. Escape its special characters.
****0         return (argument:gsub('["^<>!|&%%]', "^%0"))
          else
****0         if argument == "" or argument:find('[^a-zA-Z0-9_@%+=:,./-]') then
                  -- To quote arguments on posix-like systems use single quotes.
                  -- To represent an embedded single quote close quoted string ('),
                  -- add escaped quote (\'), open quoted string again (').
****0             argument = "'" .. argument:gsub("'", [['\'']]) .. "'"
              end

****0         return argument
          end
      end

      --- error out of this program gracefully.
      -- @param[opt] code The exit code, defaults to -`1` if omitted
      -- @param msg The exit message will be sent to `stderr` (will be formatted with the extra parameters)
      -- @param ... extra arguments for message's format'
      -- @see utils.fprintf
      -- @usage utils.quit(-1, "Error '%s' happened", "42")
      -- -- is equivalent to
      -- utils.quit("Error '%s' happened", "42")  --> Error '42' happened
****0 function utils.quit(code, msg, ...)
****0     if type(code) == 'string' then
****0         utils.fprintf(io.stderr, code, msg, ...)
****0         io.stderr:write('\n')
****0         code = -1 -- TODO: this is odd, see the test. Which returns 255 as exit code
****0     elseif msg then
****0         utils.fprintf(io.stderr, msg, ...)
****0         io.stderr:write('\n')
          end
****0     os.exit(code, true)
      end


      --- String functions
      -- @section string-functions

      --- escape any Lua 'magic' characters in a string
      -- @param s The input string
****0 function utils.escape(s)
  132     utils.assert_string(1,s)
  132     return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
      end

      --- split a string into a list of strings separated by a delimiter.
      -- @param s The input string
      -- @param re optional A Lua string pattern; defaults to '%s+'
      -- @param plain optional If truthy don't use Lua patterns
      -- @param n optional maximum number of elements (if there are more, the last will remian un-split)
      -- @return a list-like table
      -- @raise error if s is not a string
      -- @see splitv
****0 function utils.split(s,re,plain,n)
****0     utils.assert_string(1,s)
****0     local find,sub,append = string.find, string.sub, table.insert
****0     local i1,ls = 1,{}
****0     if not re then re = '%s+' end
****0     if re == '' then return {s} end
          while true do
****0         local i2,i3 = find(s,re,i1,plain)
****0         if not i2 then
****0             local last = sub(s,i1)
****0             if last ~= '' then append(ls,last) end
****0             if #ls == 1 and ls[1] == '' then
****0                 return {}
                  else
****0                 return ls
                  end
              end
****0         append(ls,sub(s,i1,i2-1))
****0         if n and #ls == n then
****0             ls[#ls] = sub(s,i1)
****0             return ls
              end
****0         i1 = i3+1
          end
      end

      --- split a string into a number of return values.
      -- Identical to `split` but returns multiple sub-strings instead of
      -- a single list of sub-strings.
      -- @param s the string
      -- @param re A Lua string pattern; defaults to '%s+'
      -- @param plain don't use Lua patterns
      -- @param n optional maximum number of splits
      -- @return n values
      -- @usage first,next = splitv('user=jane=doe','=', false, 2)
      -- assert(first == "user")
      -- assert(next == "jane=doe")
      -- @see split
****0 function utils.splitv (s,re, plain, n)
****0     return _unpack(utils.split(s,re, plain, n))
      end


      --- Functional
      -- @section functional


      --- 'memoize' a function (cache returned value for next call).
      -- This is useful if you have a function which is relatively expensive,
      -- but you don't know in advance what values will be required, so
      -- building a table upfront is wasteful/impossible.
      -- @param func a function of at least one argument
      -- @return a function with at least one argument, which is used as the key.
****0 function utils.memoize(func)
****0     local cache = {}
          return function(k)
****0         local res = cache[k]
****0         if res == nil then
****0             res = func(k)
****0             cache[k] = res
              end
****0         return res
          end
      end


      --- associate a function factory with a type.
      -- A function factory takes an object of the given type and
      -- returns a function for evaluating it
      -- @tab mt metatable
      -- @func fun a callable that returns a function
****0 function utils.add_function_factory (mt,fun)
****0     _function_factories[mt] = fun
      end

      local function _string_lambda(f)
****0     if f:find '^|' or f:find '_' then
****0         local args,body = f:match '|([^|]*)|(.+)'
****0         if f:find '_' then
****0             args = '_'
****0             body = f
              else
****0             if not args then return raise 'bad string lambda' end
              end
****0         local fstr = 'return function('..args..') return '..body..' end'
****0         local fn,err = utils.load(fstr)
****0         if not fn then return raise(err) end
****0         fn = fn()
****0         return fn
          else
****0         return raise 'not a string lambda'
          end
      end


      --- an anonymous function as a string. This string is either of the form
      -- '|args| expression' or is a function of one argument, '_'
      -- @param lf function as a string
      -- @return a function
      -- @function utils.string_lambda
      -- @usage
      -- string_lambda '|x|x+1' (2) == 3
      -- string_lambda '_+1' (2) == 3
****0 utils.string_lambda = utils.memoize(_string_lambda)


      --- bind the first argument of the function to a value.
      -- @param fn a function of at least two values (may be an operator string)
      -- @param p a value
      -- @return a function such that f(x) is fn(p,x)
      -- @raise same as @{function_arg}
      -- @see func.bind1
      -- @usage local function f(msg, name)
      --   print(msg .. " " .. name)
      -- end
      --
      -- local hello = utils.bind1(f, "Hello")
      --
      -- print(hello("world"))     --> "Hello world"
      -- print(hello("sunshine"))  --> "Hello sunshine"
****0 function utils.bind1 (fn,p)
****0     fn = utils.function_arg(1,fn)
****0     return function(...) return fn(p,...) end
      end


      --- bind the second argument of the function to a value.
      -- @param fn a function of at least two values (may be an operator string)
      -- @param p a value
      -- @return a function such that f(x) is fn(x,p)
      -- @raise same as @{function_arg}
      -- @usage local function f(a, b, c)
      --   print(a .. " " .. b .. " " .. c)
      -- end
      --
      -- local hello = utils.bind1(f, "world")
      --
      -- print(hello("Hello", "!"))  --> "Hello world !"
      -- print(hello("Bye", "?"))    --> "Bye world ?"
****0 function utils.bind2 (fn,p)
****0     fn = utils.function_arg(1,fn)
****0     return function(x,...) return fn(x,p,...) end
      end




      --- Deprecation
      -- @section deprecation

      do
        -- the default implementation
        local deprecation_func = function(msg, trace)
****0     if trace then
****0       warn(msg, "\n", trace)  -- luacheck: ignore
          else
****0       warn(msg)  -- luacheck: ignore
          end
        end

        --- Sets a deprecation warning function.
        -- An application can override this function to support proper output of
        -- deprecation warnings. The warnings can be generated from libraries or
        -- functions by calling `utils.raise_deprecation`. The default function
        -- will write to the 'warn' system (introduced in Lua 5.4, or the compatibility
        -- function from the `compat` module for earlier versions).
        --
        -- Note: only applications should set/change this function, libraries should not.
        -- @param func a callback with signature: `function(msg, trace)` both arguments are strings, the latter being optional.
        -- @see utils.raise_deprecation
        -- @usage
        -- -- write to the Nginx logs with OpenResty
        -- utils.set_deprecation_func(function(msg, trace)
        --   ngx.log(ngx.WARN, msg, (trace and (" " .. trace) or nil))
        -- end)
        --
        -- -- disable deprecation warnings
        -- utils.set_deprecation_func()
****0   function utils.set_deprecation_func(func)
****0     if func == nil then
****0       deprecation_func = function() end
          else
****0       utils.assert_arg(1, func, "function")
****0       deprecation_func = func
          end
        end

        --- raises a deprecation warning.
        -- For options see the usage example below.
        --
        -- Note: the `opts.deprecated_after` field is the last version in which
        -- a feature or option was NOT YET deprecated! Because when writing the code it
        -- is quite often not known in what version the code will land. But the last
        -- released version is usually known.
        -- @param opts options table
        -- @see utils.set_deprecation_func
        -- @usage
        -- warn("@on")   -- enable Lua warnings, they are usually off by default
        --
        -- function stringx.islower(str)
        --   raise_deprecation {
        --     source = "Penlight " .. utils._VERSION,                   -- optional
        --     message = "function 'islower' was renamed to 'is_lower'", -- required
        --     version_removed = "2.0.0",                                -- optional
        --     deprecated_after = "1.2.3",                               -- optional
        --     no_trace = true,                                          -- optional
        --   }
        --   return stringx.is_lower(str)
        -- end
        -- -- output: "[Penlight 1.9.2] function 'islower' was renamed to 'is_lower' (deprecated after 1.2.3, scheduled for removal in 2.0.0)"
****0   function utils.raise_deprecation(opts)
****0     utils.assert_arg(1, opts, "table")
****0     if type(opts.message) ~= "string" then
****0       error("field 'message' of the options table must be a string", 2)
          end
          local trace
****0     if not opts.no_trace then
****0       trace = debug.traceback("", 2):match("[\n%s]*(.-)$")
          end
          local msg
****0     if opts.deprecated_after and opts.version_removed then
****0       msg = (" (deprecated after %s, scheduled for removal in %s)"):format(
****0         tostring(opts.deprecated_after), tostring(opts.version_removed))
****0     elseif opts.deprecated_after then
****0       msg = (" (deprecated after %s)"):format(tostring(opts.deprecated_after))
****0     elseif opts.version_removed then
****0       msg = (" (scheduled for removal in %s)"):format(tostring(opts.version_removed))
          else
****0       msg = ""
          end

****0     msg = opts.message .. msg

****0     if opts.source then
****0       msg = "[" .. opts.source .."] " .. msg
          else
****0       if msg:sub(1,1) == "@" then
              -- in Lua 5.4 "@" prefixed messages are control messages to the warn system
****0         error("message cannot start with '@'", 2)
            end
          end

****0     deprecation_func(msg, trace)
        end

      end


****0 return utils



==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/say/init.lua
==============================================================================
****0 local unpack = table.unpack or unpack

****0 local registry = { }
      local current_namespace
      local fallback_namespace

****0 local s = {

        _COPYRIGHT   = "Copyright (c) 2012 Olivine Labs, LLC.",
        _DESCRIPTION = "A simple string key/value store for i18n or any other case where you want namespaced strings.",
        _VERSION     = "Say 1.2",

        set_namespace = function(self, namespace)
    4     current_namespace = namespace
    4     if not registry[current_namespace] then
****0       registry[current_namespace] = {}
          end
        end,

        set_fallback = function(self, namespace)
****0     fallback_namespace = namespace
****0     if not registry[fallback_namespace] then
****0       registry[fallback_namespace] = {}
          end
        end,

        set = function(self, key, value)
   76     registry[current_namespace][key] = value
        end
      }

****0 local __meta = {
        __call = function(self, key, vars)
   54     vars = vars or {}

   54     local str = registry[current_namespace][key] or registry[fallback_namespace][key]

   54     if str == nil then
****0       return nil
          end
   54     str = tostring(str)
   54     local strings = {}

  100     for i,v in ipairs(vars) do
   46       table.insert(strings, tostring(v))
          end

   54     return #strings > 0 and str:format(unpack(strings)) or str
        end,

        __index = function(self, key)
****0     return registry[key]
        end
      }

****0 s:set_fallback('en')
****0 s:set_namespace('en')

****0 s._registry = registry

****0 return setmetatable(s, __meta)

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/sncl/globals.lua
==============================================================================
    6 local globals = {
    6    input_file = nil,
    6    has_error = false,
    6    parser_line = 0,
    6    erros = "",
    6    _DEBUG_PEG = false,
      }

    6 return globals

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/sncl/utils.lua
==============================================================================
    6 local colors = require('ansicolors')
    6 local lpeg = require('lpeg')

    6 local gbl = require('sncl.globals')

    6 local R, P = lpeg.R, lpeg.P

    6 local utils = {}

    6 utils.checks = {
    6   buttons = R'09'+R'AZ'+P'*'+P'#'+P'MENU'+P'INFO'+P'GUIDE'+P'CURSOR_DOWN'
    6     +P'CURSOR_LEFT'+P'CURSOR_RIGHT'+P'CURSOR_UP'+P'CHANNEL_DOWN'+P'CHANNEL_UP'
    6     +P'VOLUME_DOWN'+P'VOLUME_UP'+P'ENTER'+P'RED'+P'GREEN'+P'YELLOW'+P'BLUE'
    6     +P'BLACK'+P'EXIT'+P'POWER'+P'REWIND'+P'STOP'+P'EJECT'+P'PLAY'+P'RECORD'+P'PAUSE',
    6   types = P'context'+P'media'+P'area'+P'region'+P'macro'
    6 }

    6 function utils.createSymbolTable()
    6   return {
    6     presentation = {},
    6     head = {},
    6     link = {},
    6     macro = {},
    6     macroCall = {},
    6     template = {},
    6     padding = {},
    6   }
      end

    6 function utils.containsValue(tbl, value)
****0   for _, val in pairs(tbl) do
****0     if val == value then
****0       return true
          end
        end
****0   return false
      end

    6 function utils.getIndex(tbl, value)
****0   for pos, val in pairs(tbl) do
****0     if val == value then
****0       return pos
          end
        end
****0   return nil
      end

    6 function utils.getElementsWithClass(elements, class)
****0   local tbl = {}
****0   for pos, val in pairs(elements) do
          -- When the elements from the yaml are parsed,
          -- they come without the id
****0     if not val.id then
****0       val.id = pos
          end
****0     if val.class == class then
****0       table.insert(tbl, val)
          end

        end
****0   return tbl
      end

    6 function utils.printErro(errString, line)
****0   line = line or gbl.parserLine
****0   local file = gbl.inputFile or ''
****0   io.write(colors('%{bright}'..file..':'..line..': %{red}erro:%{reset} '..errString..'\n'))
****0   gbl.hasError = true
      end


    6 function utils:addProperty(element, name, value)
    8   if element.properties == nil then
    2     element.properties = {}
        end
    8   if name ~= '_type' then
    4     if element.properties[name] then
****0       self.printErro(string.format('Property %s already declared'))
****0       return nil
          else
    4       if name == 'src' then
    2         element.src = value
    2       elseif name == 'type' then
****0         element.type = value
            else
    2         element.properties[name] = value
            end
          end
        end
      end

    6 function utils:isIdUsed(id, symbolsTable)
    4   if symbolsTable.presentation[id] or symbolsTable.macro[id] or symbolsTable.head[id] then
****0     self.printError(string.format('Id %s already declared', id))
****0     return true
        end
    4   return false
      end

    6 function utils:isMacroSon(element)
****0   if element._type == 'macro' then
****0     return true
        else
****0     if element.father then
****0       return self:isMacroSon(element.father)
          end
        end
****0   return false
      end

    6 function utils:getNumberOfParents(element, numFathers)
****0   if element.father then
****0     numFathers = self:getNumberOfParents(element.father, numFathers+1)
        end
****0   return numFathers
      end

    6 function utils:readFile(file)
****0   file = io.open(file, 'r')
****0   if not file then
****0     self.printErro('Error opening input file')
****0     return nil
        end
****0   local fileContent = file:read('*a')
****0   if not fileContent then
****0     self.printError('Error reading input')
****0     return nil
        end
****0   return fileContent
      end

    6 function utils:writeFile(file, content)
****0   file = io.open(file, "w")
****0   if not file then
****0     self.printErro('Error creating output file')
****0     return nil
        end
****0   io.output(file)
****0   io.write(content)
****0   io.close(file)
      end

    6 return utils

==============================================================================
/home/lucastercas/.luarocks/share/lua/5.4/term/colors.lua
==============================================================================
      -- Copyright (c) 2009 Rob Hoelz <rob@hoelzro.net>
      --
      -- Permission is hereby granted, free of charge, to any person obtaining a copy
      -- of this software and associated documentation files (the "Software"), to deal
      -- in the Software without restriction, including without limitation the rights
      -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      -- copies of the Software, and to permit persons to whom the Software is
      -- furnished to do so, subject to the following conditions:
      --
      -- The above copyright notice and this permission notice shall be included in
      -- all copies or substantial portions of the Software.
      --
      -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
      -- THE SOFTWARE.

****0 local pairs = pairs
****0 local tostring = tostring
****0 local setmetatable = setmetatable
****0 local schar = string.char

****0 local colors = {}

****0 local colormt = {}

****0 function colormt:__tostring()
  104     return self.value
      end

****0 function colormt:__concat(other)
  104     return tostring(self) .. tostring(other)
      end

****0 function colormt:__call(s)
   52     return self .. s .. colors.reset
      end

      local function makecolor(value)
****0     return setmetatable({ value = schar(27) .. '[' .. tostring(value) .. 'm' }, colormt)
      end

****0 local colorvalues = {
          -- attributes
          reset      = 0,
          clear      = 0,
          default    = 0,
          bright     = 1,
          dim        = 2,
          underscore = 4,
          blink      = 5,
          reverse    = 7,
          hidden     = 8,

          -- foreground
          black   = 30,
          red     = 31,
          green   = 32,
          yellow  = 33,
          blue    = 34,
          magenta = 35,
          cyan    = 36,
          white   = 37,

          -- background
          onblack   = 40,
          onred     = 41,
          ongreen   = 42,
          onyellow  = 43,
          onblue    = 44,
          onmagenta = 45,
          oncyan    = 46,
          onwhite   = 47,
      }

****0 for c, v in pairs(colorvalues) do
****0     colors[c] = makecolor(v)
      end

****0 return colors

==============================================================================
/usr/share/lua/5.4/luarocks/core/dir.lua
==============================================================================

****0 local dir = {}

      local require = nil
      --------------------------------------------------------------------------------

      local function unquote(c)
 1152    local first, last = c:sub(1,1), c:sub(-1)
 1152    if (first == '"' and last == '"') or
 1152       (first == "'" and last == "'") then
****0       return c:sub(2,-2)
         end
 1152    return c
      end

      --- Describe a path in a cross-platform way.
      -- Use this function to avoid platform-specific directory
      -- separators in other modules. Removes trailing slashes from
      -- each component given, to avoid repeated separators.
      -- Separators inside strings are kept, to handle URLs containing
      -- protocols.
      -- @param ... strings representing directories
      -- @return string: a string with a platform-specific representation
      -- of the path.
****0 function dir.path(...)
  288    local t = {...}
  288    while t[1] == "" do
****0       table.remove(t, 1)
         end
  864    for i, c in ipairs(t) do
  576       t[i] = unquote(c)
         end
  288    return (table.concat(t, "/"):gsub("([^:])/+", "%1/"):gsub("^/+", "/"):gsub("/*$", ""))
      end

      --- Split protocol and path from an URL or local pathname.
      -- URLs should be in the "protocol://path" format.
      -- For local pathnames, "file" is returned as the protocol.
      -- @param url string: an URL or a local pathname.
      -- @return string, string: the protocol, and the pathname without the protocol.
****0 function dir.split_url(url)
  576    assert(type(url) == "string")

  576    url = unquote(url)
  576    local protocol, pathname = url:match("^([^:]*)://(.*)")
  576    if not protocol then
  576       protocol = "file"
  576       pathname = url
         end
  576    return protocol, pathname
      end

      --- Normalize a url or local path.
      -- URLs should be in the "protocol://path" format. System independent
      -- forward slashes are used, removing trailing and double slashes
      -- @param url string: an URL or a local pathname.
      -- @return string: Normalized result.
****0 function dir.normalize(name)
  576    local protocol, pathname = dir.split_url(name)
  576    pathname = pathname:gsub("\\", "/"):gsub("(.)/*$", "%1"):gsub("//", "/")
  576    local pieces = {}
  576    local drive = ""
  576    if pathname:match("^.:") then
****0       drive, pathname = pathname:match("^(.:)(.*)$")
         end
 2016    for piece in pathname:gmatch("(.-)/") do
 1440       if piece == ".." then
****0          local prev = pieces[#pieces]
****0          if not prev or prev == ".." then
****0             table.insert(pieces, "..")
****0          elseif prev ~= "" then
****0             table.remove(pieces)
               end
 1440       elseif piece ~= "." then
 1440          table.insert(pieces, piece)
            end
         end
  576    local basename = pathname:match("[^/]+$")
  576    if basename then
  576       table.insert(pieces, basename)
         end
  576    pathname = drive .. table.concat(pieces, "/")
  576    if protocol ~= "file" then pathname = protocol .."://"..pathname end
  576    return pathname
      end

****0 return dir


==============================================================================
/usr/share/lua/5.4/luarocks/core/manif.lua
==============================================================================

      --- Core functions for querying manifest files.
****0 local manif = {}

****0 local persist = require("luarocks.core.persist")
****0 local cfg = require("luarocks.core.cfg")
****0 local dir = require("luarocks.core.dir")
****0 local util = require("luarocks.core.util")
****0 local vers = require("luarocks.core.vers")
****0 local path = require("luarocks.core.path")
      local require = nil
      --------------------------------------------------------------------------------

      -- Table with repository identifiers as keys and tables mapping
      -- Lua versions to cached loaded manifests as values.
****0 local manifest_cache = {}

      --- Cache a loaded manifest.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @param manifest table: the manifest to be cached.
****0 function manif.cache_manifest(repo_url, lua_version, manifest)
****0    lua_version = lua_version or cfg.lua_version
****0    manifest_cache[repo_url] = manifest_cache[repo_url] or {}
****0    manifest_cache[repo_url][lua_version] = manifest
      end

      --- Attempt to get cached loaded manifest.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @return table or nil: loaded manifest or nil if cache is empty.
****0 function manif.get_cached_manifest(repo_url, lua_version)
  288    lua_version = lua_version or cfg.lua_version
  288    return manifest_cache[repo_url] and manifest_cache[repo_url][lua_version]
      end

      --- Back-end function that actually loads the manifest
      -- and stores it in the manifest cache.
      -- @param file string: The local filename of the manifest file.
      -- @param repo_url string: The repository identifier.
      -- @param lua_version string: Lua version in "5.x" format, defaults to installed version.
      -- @return table or (nil, string, string): the manifest or nil,
      -- error message and error code ("open", "load", "run").
****0 function manif.manifest_loader(file, repo_url, lua_version)
****0    local manifest, err, errcode = persist.load_into_table(file)
****0    if not manifest then
****0       return nil, "Failed loading manifest for "..repo_url..": "..err, errcode
         end
****0    manif.cache_manifest(repo_url, lua_version, manifest)
****0    return manifest, err, errcode
      end

      --- Load a local manifest describing a repository.
      -- This is used by the luarocks.loader only.
      -- @param repo_url string: URL or pathname for the repository.
      -- @return table or (nil, string, string): A table representing the manifest,
      -- or nil followed by an error message and an error code, see manifest_loader.
****0 function manif.fast_load_local_manifest(repo_url)
  288    assert(type(repo_url) == "string")

  288    local cached_manifest = manif.get_cached_manifest(repo_url)
  288    if cached_manifest then
  288       return cached_manifest
         end

****0    local pathname = dir.path(repo_url, "manifest")
****0    return manif.manifest_loader(pathname, repo_url, nil, true)
      end

****0 function manif.load_rocks_tree_manifests(deps_mode)
  144    local trees = {}
  288    path.map_trees(deps_mode, function(tree)
  288       local manifest, err = manif.fast_load_local_manifest(path.rocks_dir(tree))
  288       if manifest then
  288          table.insert(trees, {tree=tree, manifest=manifest})
            end
         end)
  144    return trees
      end

****0 function manif.scan_dependencies(name, version, tree_manifests, dest)
   90    if dest[name] then
   70       return
         end
   20    dest[name] = version

   20    for _, tree in ipairs(tree_manifests) do
   20       local manifest = tree.manifest

            local pkgdeps
   20       if manifest.dependencies and manifest.dependencies[name] then
   20          pkgdeps = manifest.dependencies[name][version]
            end
   20       if pkgdeps then
   60          for _, dep in ipairs(pkgdeps) do
   40             local pkg, constraints = dep.name, dep.constraints

  120             for _, t in ipairs(tree_manifests) do
   80                local entries = t.manifest.repository[pkg]
   80                if entries then
   40                   for ver, _ in util.sortedpairs(entries, vers.compare_versions) do
   20                      if (not constraints) or vers.match_constraints(vers.parse_version(ver), constraints) then
   20                         manif.scan_dependencies(pkg, ver, tree_manifests, dest)
                           end
                        end
                     end
                  end
               end
   20          return
            end
         end
      end

****0 return manif

==============================================================================
/usr/share/lua/5.4/luarocks/core/path.lua
==============================================================================

      --- Core LuaRocks-specific path handling functions.
****0 local path = {}

****0 local cfg = require("luarocks.core.cfg")
****0 local dir = require("luarocks.core.dir")
      local require = nil
      --------------------------------------------------------------------------------

****0 function path.rocks_dir(tree)
  288    if tree == nil then
****0       tree = cfg.root_dir
         end
  288    if type(tree) == "string" then
****0       return dir.path(tree, cfg.rocks_subdir)
         end
  288    assert(type(tree) == "table")
  288    return tree.rocks_dir or dir.path(tree.root, cfg.rocks_subdir)
      end

      --- Produce a versioned version of a filename.
      -- @param file string: filename (must start with prefix)
      -- @param prefix string: Path prefix for file
      -- @param name string: Rock name
      -- @param version string: Rock version
      -- @return string: a pathname with the same directory parts and a versioned basename.
****0 function path.versioned_name(file, prefix, name, version)
****0    assert(type(file) == "string")
****0    assert(type(name) == "string" and not name:match("/"))
****0    assert(type(version) == "string")

****0    local rest = file:sub(#prefix+1):gsub("^/*", "")
****0    local name_version = (name.."_"..version):gsub("%-", "_"):gsub("%.", "_")
****0    return dir.path(prefix, name_version.."-"..rest)
      end

      --- Convert a pathname to a module identifier.
      -- In Unix, for example, a path "foo/bar/baz.lua" is converted to
      -- "foo.bar.baz"; "bla/init.lua" returns "bla.init"; "foo.so" returns "foo".
      -- @param file string: Pathname of module
      -- @return string: The module identifier, or nil if given path is
      -- not a conformant module path (the function does not check if the
      -- path actually exists).
****0 function path.path_to_module(file)
   70    assert(type(file) == "string")

   70    local name = file:match("(.*)%."..cfg.lua_extension.."$")
   70    if name then
   64       name = name:gsub("/", ".")
         else
    6       name = file:match("(.*)%."..cfg.lib_extension.."$")
    6       if name then
    6          name = name:gsub("/", ".")
            --[[ TODO disable static libs until we fix the conflict in the manifest, which will take extending the manifest format.
            else
               name = file:match("(.*)%."..cfg.static_lib_extension.."$")
               if name then
                  name = name:gsub("/", ".")
               end
            ]]
            end
         end
   70    if not name then name = file end
   70    name = name:gsub("^%.+", ""):gsub("%.+$", "")
   70    return name
      end

****0 function path.deploy_lua_dir(tree)
****0    if type(tree) == "string" then
****0       return dir.path(tree, cfg.lua_modules_path)
         else
****0       assert(type(tree) == "table")
****0       return tree.lua_dir or dir.path(tree.root, cfg.lua_modules_path)
         end
      end

****0 function path.deploy_lib_dir(tree)
****0    if type(tree) == "string" then
****0       return dir.path(tree, cfg.lib_modules_path)
         else
****0       assert(type(tree) == "table")
****0       return tree.lib_dir or dir.path(tree.root, cfg.lib_modules_path)
         end
      end

****0 local is_src_extension = { [".lua"] = true, [".tl"] = true, [".tld"] = true, [".moon"] = true }

      --- Return the pathname of the file that would be loaded for a module, indexed.
      -- @param file_name string: module file name as in manifest (eg. "socket/core.so")
      -- @param name string: name of the package (eg. "luasocket")
      -- @param version string: version number (eg. "2.0.2-1")
      -- @param tree string: repository path (eg. "/usr/local")
      -- @param i number: the index, 1 if version is the current default, > 1 otherwise.
      -- This is done this way for use by select_module in luarocks.loader.
      -- @return string: filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so")
****0 function path.which_i(file_name, name, version, tree, i)
         local deploy_dir
****0    local extension = file_name:match("%.[a-z]+$")
****0    if is_src_extension[extension] then
****0       deploy_dir = path.deploy_lua_dir(tree)
****0       file_name = dir.path(deploy_dir, file_name)
         else
****0       deploy_dir = path.deploy_lib_dir(tree)
****0       file_name = dir.path(deploy_dir, file_name)
         end
****0    if i > 1 then
****0       file_name = path.versioned_name(file_name, deploy_dir, name, version)
         end
****0    return file_name
      end

****0 function path.rocks_tree_to_string(tree)
  576    if type(tree) == "string" then
****0       return tree
         else
  576       assert(type(tree) == "table")
  576       return tree.root
         end
      end

      --- Apply a given function to the active rocks trees based on chosen dependency mode.
      -- @param deps_mode string: Dependency mode: "one" for the current default tree,
      -- "all" for all trees, "order" for all trees with priority >= the current default,
      -- "none" for no trees (this function becomes a nop).
      -- @param fn function: function to be applied, with the tree dir (string) as the first
      -- argument and the remaining varargs of map_trees as the following arguments.
      -- @return a table with all results of invocations of fn collected.
****0 function path.map_trees(deps_mode, fn, ...)
  144    local result = {}
  144    local current = cfg.root_dir or cfg.rocks_trees[1]
  144    if deps_mode == "one" then
****0       table.insert(result, (fn(current, ...)) or 0)
         else
  144       local use = false
  144       if deps_mode == "all" then
****0          use = true
            end
  432       for _, tree in ipairs(cfg.rocks_trees or {}) do
  288          if dir.normalize(path.rocks_tree_to_string(tree)) == dir.normalize(path.rocks_tree_to_string(current)) then
  144             use = true
               end
  288          if use then
  288             table.insert(result, (fn(tree, ...)) or 0)
               end
            end
         end
  144    return result
      end

****0 return path

==============================================================================
/usr/share/lua/5.4/luarocks/core/util.lua
==============================================================================

****0 local util = {}

      local require = nil
      --------------------------------------------------------------------------------

      --- Run a process and read a its output.
      -- Equivalent to io.popen(cmd):read("*l"), except that it
      -- closes the fd right away.
      -- @param cmd string: The command to execute
      -- @param spec string: "*l" by default, to read a single line.
      -- May be used to read more, passing, for instance, "*a".
      -- @return string: the output of the program.
****0 function util.popen_read(cmd, spec)
****0    local dir_sep = package.config:sub(1, 1)
****0    local tmpfile = (dir_sep == "\\")
****0                    and (os.getenv("TMP") .. "/luarocks-" .. tostring(math.floor(math.random() * 10000)))
****0                    or os.tmpname()
****0    os.execute(cmd .. " > " .. tmpfile)
****0    local fd = io.open(tmpfile, "rb")
****0    if not fd then
****0       os.remove(tmpfile)
****0       return ""
         end
****0    local out = fd:read(spec or "*l")
****0    fd:close()
****0    os.remove(tmpfile)
****0    return out or ""
      end

      --- Create a new shallow copy of a table: a new table with
      -- the same keys and values. Keys point to the same objects as
      -- the original table (ie, does not copy recursively).
      -- @param tbl table: the input table
      -- @return table: a new table with the same contents.
****0 function util.make_shallow_copy(tbl)
****0    local copy = {}
****0    for k,v in pairs(tbl) do
****0       copy[k] = v
         end
****0    return copy
      end

      ---
      -- Formats tables with cycles recursively to any depth.
      -- References to other tables are shown as values.
      -- Self references are indicated.
      -- The string returned is "Lua code", which can be processed
      -- (in the case in which indent is composed by spaces or "--").
      -- Userdata and function keys and values are shown as strings,
      -- which logically are exactly not equivalent to the original code.
      -- This routine can serve for pretty formating tables with
      -- proper indentations, apart from printing them:
      -- io.write(table.show(t, "t"))   -- a typical use
      -- Written by Julio Manuel Fernandez-Diaz,
      -- Heavily based on "Saving tables with cycles", PIL2, p. 113.
      -- @param t table: is the table.
      -- @param tname string: is the name of the table (optional)
      -- @param top_indent string: is a first indentation (optional).
      -- @return string: the pretty-printed table
****0 function util.show_table(t, tname, top_indent)
         local cart     -- a container
         local autoref  -- for self references

****0    local function is_empty_table(tbl) return next(tbl) == nil end

         local function basic_serialize(o)
****0       local so = tostring(o)
****0       if type(o) == "function" then
****0          local info = debug and debug.getinfo(o, "S")
****0          if not info then
****0             return ("%q"):format(so)
               end
               -- info.name is nil because o is not a calling level
****0          if info.what == "C" then
****0             return ("%q"):format(so .. ", C function")
               else
                  -- the information is defined through lines
****0             return ("%q"):format(so .. ", defined in (" .. info.linedefined .. "-" .. info.lastlinedefined .. ")" .. info.source)
               end
****0       elseif type(o) == "number" then
****0          return so
            else
****0          return ("%q"):format(so)
            end
         end

         local function add_to_cart(value, name, indent, saved, field)
****0       indent = indent or ""
****0       saved = saved or {}
****0       field = field or name

****0       cart = cart .. indent .. field

****0       if type(value) ~= "table" then
****0          cart = cart .. " = " .. basic_serialize(value) .. ";\n"
            else
****0          if saved[value] then
****0             cart = cart .. " = {}; -- " .. saved[value] .. " (self reference)\n"
****0             autoref = autoref ..  name .. " = " .. saved[value] .. ";\n"
               else
****0             saved[value] = name
****0             if is_empty_table(value) then
****0                cart = cart .. " = {};\n"
                  else
****0                cart = cart .. " = {\n"
****0                for k, v in pairs(value) do
****0                   k = basic_serialize(k)
****0                   local fname = ("%s[%s]"):format(name, k)
****0                   field = ("[%s]"):format(k)
                        -- three spaces between levels
****0                   add_to_cart(v, fname, indent .. "   ", saved, field)
                     end
****0                cart = cart .. indent .. "};\n"
                  end
               end
            end
         end

****0    tname = tname or "__unnamed__"
****0    if type(t) ~= "table" then
****0       return tname .. " = " .. basic_serialize(t)
         end
****0    cart, autoref = "", ""
****0    add_to_cart(t, tname, top_indent)
****0    return cart .. autoref
      end

      --- Merges contents of src on top of dst's contents
      -- (i.e. if an key from src already exists in dst, replace it).
      -- @param dst Destination table, which will receive src's contents.
      -- @param src Table which provides new contents to dst.
****0 function util.deep_merge(dst, src)
****0    for k, v in pairs(src) do
****0       if type(v) == "table" then
****0          if dst[k] == nil then
****0             dst[k] = {}
               end
****0          if type(dst[k]) == "table" then
****0             util.deep_merge(dst[k], v)
               else
****0             dst[k] = v
               end
            else
****0          dst[k] = v
            end
         end
      end

      --- Merges contents of src below those of dst's contents
      -- (i.e. if an key from src already exists in dst, do not replace it).
      -- @param dst Destination table, which will receive src's contents.
      -- @param src Table which provides new contents to dst.
****0 function util.deep_merge_under(dst, src)
****0    for k, v in pairs(src) do
****0       if type(v) == "table" then
****0          if dst[k] == nil then
****0             dst[k] = {}
               end
****0          if type(dst[k]) == "table" then
****0             util.deep_merge_under(dst[k], v)
               end
****0       elseif dst[k] == nil then
****0          dst[k] = v
            end
         end
      end

      --- Clean up a path-style string ($PATH, $LUA_PATH/package.path, etc.),
      -- removing repeated entries and making sure only the relevant
      -- Lua version is used.
      -- Example: given ("a;b;c;a;b;d", ";"), returns "a;b;c;d".
      -- @param list string: A path string (from $PATH or package.path)
      -- @param sep string: The separator
      -- @param lua_version (optional) string: The Lua version to use.
      -- @param keep_first (optional) if true, keep first occurrence in case
      -- of duplicates; otherwise keep last occurrence. The default is false.
****0 function util.cleanup_path(list, sep, lua_version, keep_first)
****0    assert(type(list) == "string")
****0    assert(type(sep) == "string")
****0    local parts = util.split_string(list, sep)
****0    local final, entries = {}, {}
         local start, stop, step

****0    if keep_first then
****0       start, stop, step = 1, #parts, 1
         else
****0       start, stop, step = #parts, 1, -1
         end

****0    for i = start, stop, step do
****0       local part = parts[i]:gsub("//", "/")
****0       if lua_version then
****0          part = part:gsub("/lua/([%d.]+)/", function(part_version)
****0             if part_version:sub(1, #lua_version) ~= lua_version then
****0                return "/lua/"..lua_version.."/"
                  end
               end)
            end
****0       if not entries[part] then
****0          local at = keep_first and #final+1 or 1
****0          table.insert(final, at, part)
****0          entries[part] = true
            end
         end

****0    return table.concat(final, sep)
      end

      -- from http://lua-users.org/wiki/SplitJoin
      -- by Philippe Lhoste
****0 function util.split_string(str, delim, maxNb)
         -- Eliminate bad cases...
****0    if string.find(str, delim) == nil then
****0       return { str }
         end
****0    if maxNb == nil or maxNb < 1 then
****0       maxNb = 0    -- No limit
         end
****0    local result = {}
****0    local pat = "(.-)" .. delim .. "()"
****0    local nb = 0
         local lastPos
****0    for part, pos in string.gmatch(str, pat) do
****0       nb = nb + 1
****0       result[nb] = part
****0       lastPos = pos
****0       if nb == maxNb then break end
         end
         -- Handle the last field
****0    if nb ~= maxNb then
****0       result[nb + 1] = string.sub(str, lastPos)
         end
****0    return result
      end

      --- Return an array of keys of a table.
      -- @param tbl table: The input table.
      -- @return table: The array of keys.
****0 function util.keys(tbl)
   20    local ks = {}
   40    for k,_ in pairs(tbl) do
   20       table.insert(ks, k)
         end
   20    return ks
      end

      --- Print a line to standard error
****0 function util.printerr(...)
****0    io.stderr:write(table.concat({...},"\t"))
****0    io.stderr:write("\n")
      end

      --- Display a warning message.
      -- @param msg string: the warning message
****0 function util.warning(msg)
****0    util.printerr("Warning: "..msg)
      end

      --- Simple sort function used as a default for util.sortedpairs.
      local function default_sort(a, b)
****0    local ta = type(a)
****0    local tb = type(b)
****0    if ta == "number" and tb == "number" then
****0       return a < b
****0    elseif ta == "number" then
****0       return true
****0    elseif tb == "number" then
****0       return false
         else
****0       return tostring(a) < tostring(b)
         end
      end

      --- A table iterator generator that returns elements sorted by key,
      -- to be used in "for" loops.
      -- @param tbl table: The table to be iterated.
      -- @param sort_function function or table or nil: An optional comparison function
      -- to be used by table.sort when sorting keys, or an array listing an explicit order
      -- for keys. If a value itself is an array, it is taken so that the first element
      -- is a string representing the field name, and the second element is a priority table
      -- for that key, which is returned by the iterator as the third value after the key
      -- and the value.
      -- @return function: the iterator function.
****0 function util.sortedpairs(tbl, sort_function)
   20    sort_function = sort_function or default_sort
   20    local keys = util.keys(tbl)
   20    local sub_orders = {}

   20    if type(sort_function) == "function" then
   20       table.sort(keys, sort_function)
         else
****0       local order = sort_function
****0       local ordered_keys = {}
****0       local all_keys = keys
****0       keys = {}

****0       for _, order_entry in ipairs(order) do
               local key, sub_order
****0          if type(order_entry) == "table" then
****0             key = order_entry[1]
****0             sub_order = order_entry[2]
               else
****0             key = order_entry
               end

****0          if tbl[key] then
****0             ordered_keys[key] = true
****0             sub_orders[key] = sub_order
****0             table.insert(keys, key)
               end
            end

****0       table.sort(all_keys, default_sort)
****0       for _, key in ipairs(all_keys) do
****0          if not ordered_keys[key] then
****0             table.insert(keys, key)
               end
            end
         end

   20    local i = 1
         return function()
   40       local key = keys[i]
   40       i = i + 1
   40       return key, tbl[key], sub_orders[key]
         end
      end

****0 return util


==============================================================================
/usr/share/lua/5.4/luarocks/core/vers.lua
==============================================================================

****0 local vers = {}

****0 local util = require("luarocks.core.util")
      local require = nil
      --------------------------------------------------------------------------------

****0 local deltas = {
         dev =    120000000,
         scm =    110000000,
         cvs =    100000000,
         rc =    -1000,
         pre =   -10000,
         beta =  -100000,
****0    alpha = -1000000
      }

****0 local version_mt = {
         --- Equality comparison for versions.
         -- All version numbers must be equal.
         -- If both versions have revision numbers, they must be equal;
         -- otherwise the revision number is ignored.
         -- @param v1 table: version table to compare.
         -- @param v2 table: version table to compare.
         -- @return boolean: true if they are considered equivalent.
         __eq = function(v1, v2)
****0       if #v1 ~= #v2 then
****0          return false
            end
****0       for i = 1, #v1 do
****0          if v1[i] ~= v2[i] then
****0             return false
               end
            end
****0       if v1.revision and v2.revision then
****0          return (v1.revision == v2.revision)
            end
****0       return true
         end,
         --- Size comparison for versions.
         -- All version numbers are compared.
         -- If both versions have revision numbers, they are compared;
         -- otherwise the revision number is ignored.
         -- @param v1 table: version table to compare.
         -- @param v2 table: version table to compare.
         -- @return boolean: true if v1 is considered lower than v2.
         __lt = function(v1, v2)
****0       for i = 1, math.max(#v1, #v2) do
****0          local v1i, v2i = v1[i] or 0, v2[i] or 0
****0          if v1i ~= v2i then
****0             return (v1i < v2i)
               end
            end
****0       if v1.revision and v2.revision then
****0          return (v1.revision < v2.revision)
            end
****0       return false
         end,
         -- @param v1 table: version table to compare.
         -- @param v2 table: version table to compare.
         -- @return boolean: true if v1 is considered lower than or equal to v2.
         __le = function(v1, v2)
****0        return not (v2 < v1)
         end,
         --- Return version as a string.
         -- @param v The version table.
         -- @return The string representation.
         __tostring = function(v)
****0       return v.string
         end,
      }

****0 local version_cache = {}
****0 setmetatable(version_cache, {
****0    __mode = "kv"
      })

      --- Parse a version string, converting to table format.
      -- A version table contains all components of the version string
      -- converted to numeric format, stored in the array part of the table.
      -- If the version contains a revision, it is stored numerically
      -- in the 'revision' field. The original string representation of
      -- the string is preserved in the 'string' field.
      -- Returned version tables use a metatable
      -- allowing later comparison through relational operators.
      -- @param vstring string: A version number in string format.
      -- @return table or nil: A version table or nil
      -- if the input string contains invalid characters.
****0 function vers.parse_version(vstring)
   24    if not vstring then return nil end
   24    assert(type(vstring) == "string")

   24    local cached = version_cache[vstring]
   24    if cached then
****0       return cached
         end

   24    local version = {}
   24    local i = 1

         local function add_token(number)
   68       version[i] = version[i] and version[i] + number/100000 or number
   68       i = i + 1
         end

         -- trim leading and trailing spaces
   24    local v = vstring:match("^%s*(.*)%s*$")
   24    version.string = v
         -- store revision separately if any
   24    local main, revision = v:match("(.*)%-(%d+)$")
   24    if revision then
   24       v = main
   24       version.revision = tonumber(revision)
         end
   92    while #v > 0 do
            -- extract a number
   68       local token, rest = v:match("^(%d+)[%.%-%_]*(.*)")
   68       if token then
   68          add_token(tonumber(token))
            else
               -- extract a word
****0          token, rest = v:match("^(%a+)[%.%-%_]*(.*)")
****0          if not token then
****0             util.warning("version number '"..v.."' could not be parsed.")
****0             version[i] = 0
                  break
               end
****0          version[i] = deltas[token] or (token:byte() / 1000)
            end
   68       v = rest
         end
   24    setmetatable(version, version_mt)
   24    version_cache[vstring] = version
   24    return version
      end

      --- Utility function to compare version numbers given as strings.
      -- @param a string: one version.
      -- @param b string: another version.
      -- @return boolean: True if a > b.
****0 function vers.compare_versions(a, b)
****0    if a == b then
****0       return false
         end
****0    return vers.parse_version(a) > vers.parse_version(b)
      end

      --- A more lenient check for equivalence between versions.
      -- This returns true if the requested components of a version
      -- match and ignore the ones that were not given. For example,
      -- when requesting "2", then "2", "2.1", "2.3.5-9"... all match.
      -- When requesting "2.1", then "2.1", "2.1.3" match, but "2.2"
      -- doesn't.
      -- @param version string or table: Version to be tested; may be
      -- in string format or already parsed into a table.
      -- @param requested string or table: Version requested; may be
      -- in string format or already parsed into a table.
      -- @return boolean: True if the tested version matches the requested
      -- version, false otherwise.
      local function partial_match(version, requested)
****0    assert(type(version) == "string" or type(version) == "table")
****0    assert(type(requested) == "string" or type(version) == "table")

****0    if type(version) ~= "table" then version = vers.parse_version(version) end
****0    if type(requested) ~= "table" then requested = vers.parse_version(requested) end
****0    if not version or not requested then return false end

****0    for i, ri in ipairs(requested) do
****0       local vi = version[i] or 0
****0       if ri ~= vi then return false end
         end
****0    if requested.revision then
****0       return requested.revision == version.revision
         end
****0    return true
      end

      --- Check if a version satisfies a set of constraints.
      -- @param version table: A version in table format
      -- @param constraints table: An array of constraints in table format.
      -- @return boolean: True if version satisfies all constraints,
      -- false otherwise.
****0 function vers.match_constraints(version, constraints)
   20    assert(type(version) == "table")
   20    assert(type(constraints) == "table")
   20    local ok = true
   20    setmetatable(version, version_mt)
   20    for _, constr in pairs(constraints) do
****0       if type(constr.version) == "string" then
****0          constr.version = vers.parse_version(constr.version)
            end
****0       local constr_version, constr_op = constr.version, constr.op
****0       setmetatable(constr_version, version_mt)
****0       if     constr_op == "==" then ok = version == constr_version
****0       elseif constr_op == "~=" then ok = version ~= constr_version
****0       elseif constr_op == ">"  then ok = version >  constr_version
****0       elseif constr_op == "<"  then ok = version <  constr_version
****0       elseif constr_op == ">=" then ok = version >= constr_version
****0       elseif constr_op == "<=" then ok = version <= constr_version
****0       elseif constr_op == "~>" then ok = partial_match(version, constr_version)
            end
****0       if not ok then break end
         end
   20    return ok
      end

****0 return vers

==============================================================================
/usr/share/lua/5.4/luarocks/loader.lua
==============================================================================
      --- A module which installs a Lua package loader that is LuaRocks-aware.
      -- This loader uses dependency information from the LuaRocks tree to load
      -- correct versions of modules. It does this by constructing a "context"
      -- table in the environment, which records which versions of packages were
      -- used to load previous modules, so that the loader chooses versions
      -- that are declared to be compatible with the ones loaded earlier.

      -- luacheck: globals luarocks

****0 local loaders = package.loaders or package.searchers
      local require, ipairs, table, type, next, tostring, error =
****0       require, ipairs, table, type, next, tostring, error
****0 local unpack = unpack or table.unpack

****0 local loader = {}

****0 local is_clean = not package.loaded["luarocks.core.cfg"]

      -- This loader module depends only on core modules.
****0 local cfg = require("luarocks.core.cfg")
****0 local cfg_ok, err = cfg.init()
****0 if cfg_ok then
****0    cfg.init_package_paths()
      end

****0 local path = require("luarocks.core.path")
****0 local manif = require("luarocks.core.manif")
****0 local vers = require("luarocks.core.vers")
      local require = nil  -- luacheck: ignore 411
      --------------------------------------------------------------------------------

      -- Workaround for wrappers produced by older versions of LuaRocks
****0 local temporary_global = false
****0 local status, luarocks_value = pcall(function() return luarocks end)
****0 if status and luarocks_value then
         -- The site_config.lua file generated by old versions uses module(),
         -- so it produces a global `luarocks` table. Since we have the table,
         -- add the `loader` field to make the old wrappers happy.
****0    luarocks.loader = loader
      else
         -- When a new version is installed on top of an old version,
         -- site_config.lua may be replaced, and then it no longer creates
         -- a global.
         -- Detect when being called via -lluarocks.loader; this is
         -- most likely a wrapper.
****0    local info = debug and debug.getinfo(2, "nS")
****0    if info and info.what == "C" and not info.name then
****0       luarocks = { loader = loader }
****0       temporary_global = true
            -- For the other half of this hack,
            -- see the next use of `temporary_global` below.
         end
      end

****0 loader.context = {}

      --- Process the dependencies of a package to determine its dependency
      -- chain for loading modules.
      -- @param name string: The name of an installed rock.
      -- @param version string: The version of the rock, in string format
****0 function loader.add_context(name, version)
         -- assert(type(name) == "string")
         -- assert(type(version) == "string")

   70    if temporary_global then
            -- The first thing a wrapper does is to call add_context.
            -- From here on, it's safe to clean the global environment.
****0       luarocks = nil
****0       temporary_global = false
         end

   70    local tree_manifests = manif.load_rocks_tree_manifests()
   70    if not tree_manifests then
****0       return nil
         end

   70    return manif.scan_dependencies(name, version, tree_manifests, loader.context)
      end

      --- Internal sorting function.
      -- @param a table: A provider table.
      -- @param b table: Another provider table.
      -- @return boolean: True if the version of a is greater than that of b.
      local function sort_versions(a,b)
****0    return a.version > b.version
      end

      --- Request module to be loaded through other loaders,
      -- once the proper name of the module has been determined.
      -- For example, in case the module "socket.core" has been requested
      -- to the LuaRocks loader and it determined based on context that
      -- the version 2.0.2 needs to be loaded and it is not the current
      -- version, the module requested for the other loaders will be
      -- "socket.core_2_0_2".
      -- @param module The module name requested by the user, such as "socket.core"
      -- @param name The rock name, such as "luasocket"
      -- @param version The rock version, such as "2.0.2-1"
      -- @param module_name The actual module name, such as "socket.core" or "socket.core_2_0_2".
      -- @return table or (nil, string): The module table as returned by some other loader,
      -- or nil followed by an error message if no other loader managed to load the module.
      local function call_other_loaders(module, name, version, module_name)
  216    for _, a_loader in ipairs(loaders) do
  216       if a_loader ~= loader.luarocks_loader then
  146          local results = { a_loader(module_name) }
  146          if type(results[1]) == "function" then
   70             return unpack(results)
               end
            end
         end
****0    return "Failed loading module "..module.." in LuaRocks rock "..name.." "..version
      end

      local function add_providers(providers, entries, tree, module, filter_file_name)
   74    for i, entry in ipairs(entries) do
   70       local name, version = entry:match("^([^/]*)/(.*)$")
   70       local file_name = tree.manifest.repository[name][version][1].modules[module]
   70       if type(file_name) ~= "string" then
****0          error("Invalid data in manifest file for module "..tostring(module).." (invalid data for "..tostring(name).." "..tostring(version)..")")
            end
   70       file_name = filter_file_name(file_name, name, version, tree.tree, i)
   70       if loader.context[name] == version then
   66          return name, version, file_name
            end
    4       version = vers.parse_version(version)
    4       table.insert(providers, {name = name, version = version, module_name = file_name, tree = tree})
         end
      end

      --- Search for a module in the rocks trees
      -- @param module string: module name (eg. "socket.core")
      -- @param filter_file_name function(string, string, string, string, number):
      -- a function that takes the module file name (eg "socket/core.so"), the rock name
      -- (eg "luasocket"), the version (eg "2.0.2-1"), the path of the rocks tree
      -- (eg "/usr/local"), and the numeric index of the matching entry, so the
      -- filter function can know if the matching module was the first entry or not.
      -- @return string, string, string, (string or table):
      -- * name of the rock containing the module (eg. "luasocket")
      -- * version of the rock (eg. "2.0.2-1")
      -- * return value of filter_file_name
      -- * tree of the module (string or table in `tree_manifests` format)
      local function select_module(module, filter_file_name)
         --assert(type(module) == "string")
         --assert(type(filter_module_name) == "function")

   74    local tree_manifests = manif.load_rocks_tree_manifests()
   74    if not tree_manifests then
****0       return nil
         end

   74    local providers = {}
         local initmodule
   90    for _, tree in ipairs(tree_manifests) do
   82       local entries = tree.manifest.modules[module]
   82       if entries then
   70          local n, v, f = add_providers(providers, entries, tree, module, filter_file_name)
   70          if n then
   66             return n, v, f
               end
            else
   12          initmodule = initmodule or module .. ".init"
   12          entries = tree.manifest.modules[initmodule]
   12          if entries then
****0             local n, v, f = add_providers(providers, entries, tree, initmodule, filter_file_name)
****0             if n then
****0                return n, v, f
                  end
               end
            end
         end

    8    if next(providers) then
    4       table.sort(providers, sort_versions)
    4       local first = providers[1]
    4       return first.name, first.version.string, first.module_name, first.tree
         end
      end

      --- Search for a module
      -- @param module string: module name (eg. "socket.core")
      -- @return string, string, string, (string or table):
      -- * name of the rock containing the module (eg. "luasocket")
      -- * version of the rock (eg. "2.0.2-1")
      -- * name of the module (eg. "socket.core", or "socket.core_2_0_2" if file is stored versioned).
      -- * tree of the module (string or table in `tree_manifests` format)
      local function pick_module(module)
****0    return
  148       select_module(module, function(file_name, name, version, tree, i)
   70          if i > 1 then
****0             file_name = path.versioned_name(file_name, "", name, version)
               end
   70          return path.path_to_module(file_name)
            end)
      end

      --- Return the pathname of the file that would be loaded for a module.
      -- @param module string: module name (eg. "socket.core")
      -- @return filename of the module (eg. "/usr/local/lib/lua/5.1/socket/core.so"),
      -- the rock name and the rock version.
****0 function loader.which(module)
****0    local rock_name, rock_version, file_name = select_module(module, path.which_i)
****0    return file_name, rock_name, rock_version
      end

      --- Package loader for LuaRocks support.
      -- A module is searched in installed rocks that match the
      -- current LuaRocks context. If module is not part of the
      -- context, or if a context has not yet been set, the module
      -- in the package with the highest version is used.
      -- @param module string: The module name, like in plain require().
      -- @return table: The module table (typically), like in plain
      -- require(). See <a href="http://www.lua.org/manual/5.1/manual.html#pdf-require">require()</a>
      -- in the Lua reference manual for details.
****0 function loader.luarocks_loader(module)
   74    local name, version, module_name = pick_module(module)
   74    if not name then
    4       return "No LuaRocks module found for "..module
         else
   70       loader.add_context(name, version)
   70       return call_other_loaders(module, name, version, module_name)
         end
      end

****0 table.insert(loaders, 1, loader.luarocks_loader)

****0 if is_clean then
****0    for modname, _ in pairs(package.loaded) do
****0       if modname:match("^luarocks%.") then
****0          package.loaded[modname] = nil
            end
         end
      end

****0 return loader

==============================================================================
spec/generation_spec.lua
==============================================================================
    4 local nclGen = require('sncl.generation')

    8 describe("NCL #generation", function()

    8   describe("#head Elements", function()
        end)

    8   describe("#body Elements", function()

    8     describe("#media element", function()
    8       it("Should generate a #media with attributes", function()
    4         local mockMediaTable = {
    4           _type = "media",
    4           id = "testMedia",
    4           src = "testImage.png",
              }
    4         local expectedMockMediaNCL = '<media id="testMedia" src="testImage.png"></media>'
    4         local result = nclGen:presentation(mockMediaTable, {}, "")
    4         assert.are.equal(expectedMockMediaNCL, result)
            end)
    8       it("Should generate a #media with properties", function()
    4         local mockMedia = {
    4           _type = "media",
    4           id = "testMedia",
    4           properties = { left = "10%" }
              }
    4         local expectedMockMediaNCL = '<media id="testMedia">   <property name="left" value="10%" /></media>'
    4         local result = nclGen:presentation(mockMedia, {}, "")
    4         assert.are.equal(expectedMockMediaNCL, result)
            end)
          end)

        end)

      end)

==============================================================================
spec/grammar_spec.lua
==============================================================================
    2 local grammar = require('sncl.grammar')

    4 describe("#grammar", function()

    4   it("Should correctly generate a empty symbol table when passing empty string", function()
    2     local expected = {
    2       head = {},
    2       link = {},
    2       macro = {},
    2       macroCall = {},
    2       padding = {},
    2       presentation = {},
    2       template = {}
          }
    2     local snclString = ""
    2     local result = grammar.lpegMatch(snclString)
    2     assert.are.same(expected, result)
        end)

    4   it("Should parse a empty #media", function()
    2     local expected = {
    2       presentation = {
    2         testMedia = {
    2           _type = "media",
    2           id = "testMedia",
    2           hasEnd = true,
    2         }
    2       }
          }
    2     local snclString = "media testMedia end"
    2     local result = grammar.lpegMatch(snclString)
    2     assert.are.same(expected.presentation, result.presentation)
        end)

    4   it("Should parse a #media with attributes", function()
    2     local expected = {
    2       presentation = {
    2         testMedia = {
    2           _type = "media",
    2           id = "testMedia",
    2           hasEnd = true,
    2           properties = {
    2             descriptor = "testDescriptor"
    2           },
    2           src = '../images/testImage.png'
    2         }
    2       }
          }
          local snclString = [[
          media testMedia
            descriptor: testDescriptor
            src: "../images/testImage.png"
          end
    2   ]]
    2     local result = grammar.lpegMatch(snclString)
    2     assert.are.same(expected.presentation, result.presentation)
        end)

      end)


==============================================================================
spec/test_spec.lua
==============================================================================
    8 describe("Test", function()
    8   it("Should work", function()
    4     assert.True(1 == 1)
        end)
      end)


==============================================================================
src/sncl/generation.lua
==============================================================================
    4 local utils = require("sncl.utils")
      --local ins = require("sncl.inspect")

    4 local nclGeneration = {}

    4 function nclGeneration:conditions(conditions, indent, properties)
****0    local result = ''
****0    for pos, val in pairs(conditions) do
****0       result = result..string.format('%s   <simpleCondition role="%s"', indent, pos)
****0       if val > 1 then
****0          result = result..(' max="unbounded" qualifier="and"')
            end
****0       if utils.containValue(properties, '__keyValue') and pos == 'onSelection' then
****0          result = result..' key="$__keyValue"'
            end
****0       result = result..string.format('>%s   </simpleCondition>', indent)
         end
****0    return result
      end

    4 function nclGeneration:actions(actions, indent)
****0    local result = ''
****0    for pos, val in pairs(actions) do
****0       result = result..string.format('%s   <simpleAction role="%s"', indent, pos)
****0       if val > 1 then
****0          result = result..' max="unbounded" qualifier="par"'
            end
****0       if pos == 'set' then
****0          result = result..' value="$setValue"'
            end
****0       result = result..string.format('>%s   </simpleAction>', indent)
         end
****0    return result
      end

    4 function nclGeneration:xconnector(xconnector, indent)
****0    local result = string.format('%s<causalConnector id="%s" >', indent, xconnector.id)

****0    local nConds = 0
****0    for _, _ in pairs(xconnector.condition) do
****0       nConds = nConds + 1
         end
****0    if nConds > 1 then
****0       result = result..string.format('%s   <compoundCondition operator="and" >', indent)
****0       result = result..self.conditions(xconnector.condition, indent, xconnector.properties)
****0       result = result..string.format('%s   </compoundCondition>', indent)
         else
****0       result = result..self.genConditions(xconnector.condition, indent, xconnector.properties)
         end

****0    local nActs = 0
****0    for _, _ in pairs(xconnector.action) do
****0       nActs = nActs + 1
         end
****0    if nActs > 1 then
****0       result = result..string.format('%s   <compoundAction operator="par" >', indent)
****0       result = result..self.genActions(xconnector.action, indent)
****0       result = result..string.format('%s   </compoundAction>', indent)
         else
****0       result = result..self.genActions(xconnector.action, indent)
         end
****0    for _, value in pairs(xconnector.properties) do
****0       result = result..string.format('%s   <connectorParam name="%s" />', indent, value)
         end
****0    result = result..string.format('%s</causalConnector>', indent)

****0    return result
      end

    4 function nclGeneration.region(region, indent)
****0    local result = string.format('%s <region id="%s"', indent, region.id)
****0    if region.properties then
****0       for name, value in pairs(region.properties) do
****0          result = result..string.format(' %s="%s"', name, value)
            end
         end
****0    result = result..'/>'
****0    return result
      end

    4 function nclGeneration:descriptor(descriptor, indent)
****0    local result = string.format('%s<descriptor id="%s" region="%s" />', indent, descriptor.id, descriptor.region)
****0    return result
      end

    4 function nclGeneration:head(indent, symbolsTable)
****0    local result = ""
****0    local has_conn, has_rg, has_desc = false, false, false

****0    local connector_base = '<connectorBase>'
****0    local region_base = '<regionBase>'
****0    local descriptor_base = '<descriptorBase>'

****0    for _, val in pairs(symbolsTable.head) do
****0       if val._type == "xconnector"then
****0          has_conn = true
****0          connector_base = connector_base..self:xconnector(val, indent.."   ")
****0       elseif val._type == "region" then
****0          has_rg = true
****0          region_base = region_base..self.genRegion(val, indent.."   ")
****0       elseif val._type == "descriptor" then
****0          has_desc = true
****0          descriptor_base = descriptor_base..self.genDesc(val, indent.."   ")
            end
         end
****0    if has_conn then
****0       result = string.format('%s%s%s%s</connectorBase>', indent, result, connector_base, indent)
         end
****0    if has_rg then
****0       result = string.format('%s%s%s%s</regionBase>', indent, result, region_base, indent)
         end
****0    if has_desc then
****0       result = string.format('%s%s%s%s</descriptorBase>', indent, result, descriptor_base, indent)
         end
****0    return result
      end

    4 function nclGeneration.bind(element, symbolsTable, indent)
****0    local result = ""
****0    local link = element.father

****0    local hasComp = false
         -- If the link is inside of a context
****0    if link.father then
            -- If the father of the link has a children that is the component of the Link
****0       for _, val in pairs(link.father.children) do
****0          if element.component == val.id then
****0             hasComp = true
               end
            end
****0       if not hasComp then
****0          utils.printError(string.format('Component %s not in scope', element.component), element.line)
****0          return result
            end
         else
****0       if symbolsTable.presentation[element.component].father then
****0          utils.printError(string.format('Component %s not in scope', element.component), element.line)
****0          return result
            end
         end

****0    if not symbolsTable.presentation[element.component] then
****0       utils.printError(string.format('No element %s declared', element.component))
****0       return ""
         end
****0    result = result..string.format('%s<bind role="%s" component="%s"', indent, element.role, element.component)
****0    if element.interface then
****0       result = result..string.format(' interface="%s"', element.interface)
         end
****0    result = result..'>'
****0    if element.properties then
****0       for name, value in pairs(element.properties) do
****0          result = result..string.format('%s   <bindParam name="%s" value="%s" >', indent, name, value)
            end
         end
****0    result = result..string.format('%s</bind>', indent)

****0    return result
      end

    4 function nclGeneration:link(element, symbolsTable, indent)
****0    local result = string.format('%s<link xconnector="%s" >', indent, element.xconnector)

****0    for _, act in pairs(element.actions) do
****0       result = result..self.bind(act,indent..'   ', symbolsTable)
         end
****0    for _, cond in pairs(element.conditions) do
****0       result = result..self.bind(cond, indent..'   ', symbolsTable)
         end
****0    if element.properties then
****0       for name, value in pairs(element.properties) do
****0          result = result..string.format('%s   <linkParam name="%s" value="%s" />', indent, name, value)
            end
         end
****0    result = result..string.format('%s</link>', indent)

****0    return result
      end

    4 function nclGeneration:presentation(element, symbolsTable, indent)
    8    if element._type == 'macro-call' or element._type == 'for' then
****0       return ''
         end

         -- Check if the refered region is decladed
    8    if element.region then
****0       if not symbolsTable.head[element.region] then
****0          utils.printError(string.format('Region %s not declared', element.region))
****0          return ''
            end
         end

    8    local result = string.format('%s<%s id="%s"', indent, element._type, element.id)

    8    if element.component then
****0       result = result..string.format(' component="%s"', element.component)
         end
    8    if element.interface then
****0       result = result..string.format(' interface="%s"', element.interface)
         end
    8    if element.src then
    4       result = result..string.format(' src="%s"', element.src)
         end
    8    if element.descriptor then
****0       result = result..string.format(' descriptor="%s"', element.descriptor)
         end
    8    if element.type then
****0       result = result..string.format(' type="%s"', element.type)
         end
    8    result = result..'>'
    8    if element.properties then
    8       for name, value in pairs(element.properties) do
              -- TODO: Check if the property is valid
    4          result = result..string.format('%s   <property name="%s" value="%s" />', indent, name, value)
            end
         end
         -- TODO: Check if the son type is valid
    8    if element.children then
****0       for _, son in pairs(element.children) do
****0          if son._type == 'link' then
****0             result = result..self:genLink(son, indent..'   ', symbolsTable)
               else
****0             result = result..self:genPresentation(son, indent..'   ', symbolsTable)
               end
            end
         end
    8    result = result..string.format('%s</%s>', indent, element._type)

    8    return result
      end

    4 function nclGeneration:body(symbolsTable, indent)
****0    local result = ''

****0    for _, ele in pairs(symbolsTable.presentation) do
****0       if ele._type and not ele.father then
****0          if ele._type == 'link' then
****0             result = result..self:genLink(ele, indent, symbolsTable)
               else
****0             result = result..self:genPresentation(ele, indent, symbolsTable)
               end
            end
         end

****0    for _, ele in pairs(symbolsTable.link) do
****0       if not ele.father then
****0          result = result..self:genLink(ele, indent, symbolsTable)
            end
         end

****0    return result
      end

    4 function nclGeneration:genNCL(symbolsymbolsTableable)
****0    local indent = '\n   '
         local result = [[<?xml version="1.0" encoding="ISO-8859-1"?>
****0 <ncl id="main" xmlns="http://www.ncl.org.br/NCL3.0/EDTVProfile">]]
****0    result = result..indent..'<head>'
****0    result = result..self:head(indent..'   ', symbolsymbolsTableable)
****0    result = result..indent..'</head>'
****0    result = result..indent..'<body>'
****0    result = result..self:body(indent..'   ', symbolsymbolsTableable)
****0    result = result..indent..'</body>\n</result>'
****0    return result
      end

    4 return nclGeneration

==============================================================================
src/sncl/grammar.lua
==============================================================================
    2 local lpeg = require('lpeg')

    2 local parseTree = require('sncl.parsetree')
    2 local gbl = require('sncl.globals') local utils = require('sncl.utils')

    2 lpeg.locale(lpeg)

      -- TODO: macro m1(,,,,,) <- Isso √© pra da erro

    2 local V, P, R, S = lpeg.V, lpeg.P, lpeg.R, lpeg.S
    2 local C, Ct, Cg = lpeg.C, lpeg.Ct, lpeg.Cg

    2 local grammar = {
        lpegMatch = function(snclString)
    6     local symbolsTable = utils.createSymbolTable()
    6     local lpegGrammar = {
    6       'START';
    6       Any = P(1),
    6       EOS = -V'Any',
****0       Spc = lpeg.space
   12         /function(st)
   62           if st == '\n' then
    8             gbl.parser_line = gbl.parser_line+1
                end
              end,
    6       Digit = lpeg.digit,
    6       Lower = R'az',
    6       Upper = R'AZ',
    6       Letter = V'Lower' + V'Upper',
    6       Alnum = R('az', 'AZ', '09', '__'),
    6       Num = P('0x') * R('09', 'af', 'AF')^1 * (S('uU')^-1 * S('lL')^2)^-1
    6         + R('09')^1 * (S('uU')^-1 * S('lL')^2)
    6         + (R('09')^1 * (P('.') * R('09')^1)^-1 + P('.') * R('09')^1) * (S('eE') * P('-')^-1 * R('09')^1)^-1,
    6       Symbols = S'%./-\\',

    6       End = P'end',
    6       Type = P'media'+'context'+'area'+'region'+'macro',
    6       ReservedCondition = P'onBegin'+'onEnd'+'onSelection',
    6       ReservedAction = P'start'+'stop'+'set',
    6       Reserved = V'Type'+V'ReservedAction'+V'ReservedCondition'+P'do',
    6       Id = R('az', 'AZ', '__') * V'Alnum'^0,
    6       PropertyValue = (V'Letter'+V'Num'+V'Symbols')^0,
   18       Property = parseTree.makeProperty( (C(V'Id') *V'Spc'^0* P':' *V'Spc'^0*
   18         C(P'"'*V'PropertyValue'*P'"' + V'PropertyValue') * V'Spc'^0)),

    6       Port = V'Spc'^0*parseTree.makePort(P'port'* V'Spc'^1 * C(V'Id') * V'Spc'^1 * C(V'Id')*(P'.'*C(V'Id'))^-1, symbolsTable, false),

   12       PresentationElement = V'Spc'^0* parseTree.makePresentationElement(C(V'Reserved') *V'Spc'^1 * C(V'Id') *V'Spc'^1
   12         *(V'PresentationElement'+V'Port'+V'Property'+V'Link'+V'MacroCall'+V'Template'+V'Spc')^0 *C(V'End'), symbolsTable, false),

   12       Link = V'Spc'^0*
   12         parseTree.makeLink((V'Condition' *V'Spc'^1* ((V'Property'+V'Action')-V'End')^0 *C(V'End')*V'Spc'^0), symbolsTable, false),
    6       Condition = parseTree.makeBind(V'ConditionId' *V'Spc'^1* (V'RepeatCondition'+V'Spc')^0 *P'do','condition'),
    6       ConditionId = parseTree.makeRelationship(C(V'Reserved') *V'Spc'^1* (C(V'Id')*(P'.'*C(V'Id'))^-1)),
    6       RepeatCondition = P'and' *V'Spc'^1* V'ConditionId',
   18       Action = parseTree.makeBind(V'ActionId' *V'Spc'^1* (V'RepeatAction'+V'Spc')^0*
   18         (V'Property')^0* C(V'End') *V'Spc'^0, 'action'),
    6       ActionId = parseTree.makeRelationship(C(V'Reserved') *V'Spc'^1* (C(V'Id')*(P'.'*C(V'Id'))^-1)),
    6       RepeatAction = P'and' *V'Spc'^1*V'ActionId',

    6       MacroPort = V'Spc'^0*parseTree.makePort(P'port'* V'Spc'^1 * C(V'Id') * V'Spc'^1 * C(V'Id')*(P'.'*C(V'Id'))^-1, symbolsTable, true),
   12       MacroPresentationElement = V'Spc'^0* parseTree.makePresentationElement(C(V'Reserved') *V'Spc'^1 * C(V'Id') *V'Spc'^1
   12         *(V'MacroPresentationElement'+V'MacroPort'+V'Property'+V'MacroLink'+V'Template'+V'MacroCall'+V'Spc')^0 *C(V'End'), symbolsTable, true),
   12       MacroLink = (V'Spc'^0*
   12         parseTree.makeLink((V'Condition' *V'Spc'^1* ((V'Property'+V'Action')-V'End')^0 *C(V'End')*V'Spc'^0), symbolsTable, true)),
   12       Macro = V'Spc'^0* parseTree.makeMacro(P'macro' *V'Spc'^1* C(V'Id') *V'Spc'^0* V'Parameters'
   12         *V'Spc'^1* V'MacroBody'^-1 *V'Spc'^0* C(V'End'), symbolsTable),
    6       Parameters = P'('*  Ct(Cg( Ct(V'FieldParameters'^-1 * (',' * V'FieldParameters')^0),'parameters')) * P')',
    6       FieldParameters = V'Spc'^0*C(V'Id')*V'Spc'^0,
            --Field = ''' * Cs(((P(1) - ''') + P'''' / ''')^0) * ''' + C((1 - S',\n)'')^0),
    6       MacroBody = (V'MacroPresentationElement'+V'MacroLink'+V'Template')^0,

    6       MacroCall = V'Spc'^0*parseTree.makeMacroCall(C(V'Id') * V'Arguments', symbolsTable),
    6       Arguments = P'('*  Ct(( (V'FieldArgument'^-1 * (',' * V'FieldArgument')^0)) ) * P')',
            --FieldArguments = V'Spc'^0*P'''*C((V'Letter'+V'Digit'+V'Symbols'+S'[]')^0)*P'''*V'Spc'^0,
    6       FieldArgument = V'Spc'^0 * C(V'Reference'+V'Passed') * V'Spc'^0,
    6       Passed = P'"'*V'Reference'* P'"',
    6       Reference = (V'Alnum'+P'/'+P'%'+P'@')^1,
            -- TODO: Can accept more things other than Id

    6       Template = V'Spc'^0*parseTree.makeTemplate(V'For'*V'Spc'^1*V'MacroCall'^0*V'Spc'^0* C(V'End'), symbolsTable),
    6       For = (P'for' *V'Spc'^1* C(V'Lower'^1) *V'Spc'^0* P'='* V'Spc'^0*C(V'Digit'^1)*V'Spc'^0*P','*V'Spc'^0* P'#'*C((V'Lower'+V'Digit')^1) *V'Spc'^1* P'do'),

    6       START = ((V'Spc'^0
    6         *Ct((V'Template'+V'Port'+V'Macro'+V'PresentationElement'+V'Link'+V'MacroCall')^0) * V'Spc'^0)
    6         *V'EOS')
    6         /function()
    6           return symbolsTable
              end,
    6     }

    6     if gbl._DEBUG_PEG then
****0       symbolsTable = lpeg.match(require('pegdebug').trace(lpegGrammar), snclString)
          else
    6       symbolsTable = lpeg.match(lpegGrammar, snclString)
          end
    6     if not symbolsTable then
****0       error("Error generating symbol table")
          end

    6     return symbolsTable
        end
      }

    2 return grammar


==============================================================================
src/sncl/parsetree.lua
==============================================================================
    2 local lpeg = require('lpeg')

      -- local ins = require('sncl.inspect')
    2 local utils = require('sncl.utils')
    2 local gbl = require('sncl.globals')
    2 local rS = require('sncl.resolve')

      -- TODO: Make it conform with the other modules
    2 local parsingTable = {
        --- Generate a better formated table for the Port element
        -- Receives what the lpeg returns when it parses the port,
        -- then creates a better formated table
        -- then inserts it in the symbol table
        -- @param str The return of lpeg
        -- @param sT The symbol table
        -- @return The generated table
        makePort = function(str, symbolsTable, isMacroSon)
   12     return str / function(id, comp, iface)
****0       local element = {
              _type = 'port',
              id = id,
              component = comp,
              interface = iface,
****0         line = gbl.parserLine
            }
****0       if utils:isIdUsed(element.id, symbolsTable) then
****0         return nil
            end

****0       if not isMacroSon then
****0         symbolsTable.presentation[id] = element
            end
****0       return element
          end
        end,

        --- Generate a better formated table for the Property element
        -- @param str The return of lpeg
        -- @return The generated table
        makeProperty = function(str)
    6     return str / function(name, value)
    4       return {
    4         _type = 'property',
    4         [name] = value,
    4         line = gbl.parseLine
    4       }
          end
        end,

        --- Generate a better formated table for the presentation elements
        -- The inicial table has an 'end' value, indicating that it has an end,
        -- and other tables as children, those can be a property of
        -- the element, or another element, that is nested inside it.
        -- Then this table is processed to generated a better formated table, that is
        -- inserted in the symbol table
        -- @param str The return of lpeg
        -- @param sT The symbol table
        -- @param isMacroSon A boolean, indicating if the sncl element is inside of a macro
        -- @return The generated table
        makePresentationElement = function(str, symbolsTable, isMacroSon)
   12     return str / function(_type, id, ...)
    4       local tbl = {...}
    4       local element = {
    4         _type = _type,
    4         id = id,
    4         properties = nil,
    4         children = nil,
    4         hasEnd = false,
    4         line = gbl.parserLine
            }
    4       if utils:isIdUsed(element.id, symbolsTable) then
****0         return nil
            end

    4       if element._type == 'region' then
****0         symbolsTable.head[element.id] = element
    4       elseif not isMacroSon then
              -- If the element is a son of a macro, then it must not be inserted in the symbol table
    4         symbolsTable.presentation[element.id] = element
            end
   12       for _, val in pairs(tbl) do
    8         if type(val) == 'table' then
    4           if val._type == 'property' then
   12             for name, value in pairs(val) do
                    -- TODO: dont add "line"
    8               if isMacroSon then
****0                 if not element.properties then
****0                   element.properties = {}
                      end
                    else
    8                 if name == 'rg' then
****0                   if element.region then
****0                     utils.printErro(string.format('Region %s already declared', element.region), element.line)
****0                     return nil
                        end
****0                   element.region = value
****0                   element.descriptor = rS.makeDesc(value, symbolsTable)
                      else
                        -- TODO: This should not be in utils
    8                   utils:addProperty(element, name, value)
                      end
                    end
                  end
                else
****0             table.insert(element.children, val)
****0             val.father = element
                end
    4         elseif val == 'end' then
    4           element.hasEnd = true
              end
            end

    4       return element
          end
        end,

        --- Parse the each condition and action
        -- @param str The return of lpeg
        -- @return The generated table
        makeRelationship = function(str)
   12     return str / function(rl, cp, iface)
****0       local element = {
              role = rl,
              component = cp,
              interface = iface,
****0         line = gbl.parserLine
            }
****0       return element
          end
        end,

        --- Join the conditions and actions that are linked by "and"
        -- @param str The return of lpeg
        -- @param _type The type of the bind, can be an action or a condition
        -- @return The generated table
        makeBind = function(str, _type)
   12     return str / function(...)
****0       local tbl = {...}
****0       local element = {
              _type = _type,
              properties = nil,
              line = gbl.parserLine,
****0         hasEnd = false
            }

****0       for _, val in pairs(tbl) do
****0         if type(val) == 'table' then
****0           if val._type == 'property' then
****0             for name, value in pairs(val) do
****0               utils:addProperty(element, name, value)
                  end
                else
****0             element.role = val.role
****0             element.component = val.component
****0             if val.interface then
****0               if lpeg.match(utils.checks.buttons, val.interface) and val._type == 'condition' then
****0                 element.properties.__keyValue = val.interface
                    else
****0                 element.interface = val.interface
                    end
                  end
                end
****0         elseif val == 'end' then
****0           element.hasEnd = true
              end
            end

****0       return element
          end
        end,

        --- Generate a better formated table for the Link element
        -- @param str
        -- @param sT
        -- @return
        makeLink = function(str, sT, isMacroSon)
   12     return str / function(...)
****0       local tbl = {...}
****0       local element = {
              _type = 'link',
              conditions = {},
              actions = {},
              properties = {},
              line = gbl.parserLine,
****0         hasEnd = false
            }
****0       for _, val in pairs(tbl) do
****0         if type(val) == 'table' then
****0           if val._type == 'action' then
****0             table.insert(element.actions, val)
****0             val.father = element
****0           elseif val._type == 'condition' then
****0             val.father = element
****0             table.insert(element.conditions, val)
                else
****0             for name, value in pairs(val) do
****0               utils:addProperty(element, name, value)
                  end
                end
****0         elseif val == 'end' then
****0           element.hasEnd = true
              end
            end

****0       if not isMacroSon then
****0         table.insert(sT.presentation, element)
            end
****0       element.xconnector = rS:makeConn(element, sT)
****0       return element
          end
        end,

        -- TODO: Propriedades de uma macro devem ser propriedades
        -- do elemento em q a macro foi chamada

        --- Generates a better formated table for the Macro element
        -- @param str
        -- @param sT
        -- @return
        makeMacro = function(str, sT)
    6     return str / function(id, ...)
****0       local tbl = {...}
****0       local element = {
              _type = 'macro',
              id = id,
              properties = {},
              children = {},
              parameters = {},
              hasEnd = false,
****0         line = gbl.parserLine
            }

****0       if utils:isIdUsed(element.id, sT) then
****0         return nil
            end

****0       sT.macro[element.id] = element

****0       for _, val in pairs(tbl) do
****0         if type(val) == 'table' then
****0           if val.parameters then -- If val is the parameter table
****0             element.parameters = val.parameters
                else -- If val is the children
****0             table.insert(element.children, val)
****0             val.father = element
                end
****0         elseif val == 'end' then
****0           element.hasEnd = true
              end
            end

****0       return element
          end
        end,

        --- Generate a better formated table for the Macro Call element
        -- @param str
        -- @param sT
        -- @return
        makeMacroCall = function(str, sT)
    6     return str / function(mc, args)
****0       local element = {
              _type = 'macro-call',
              macro = mc,
              arguments = args,
****0         line = gbl.parserLine
            }
****0       table.insert(sT.macroCall, element)
****0       return element
          end
        end,

        --- Generate a better formated table for the Template element
        -- @param str
        -- @param sT
        -- @return
        makeTemplate = function(str, sT)
    6     return str / function(iterator, start, class, ...)
****0       local tbl = {...}
****0       local element = {
              _type = 'for',
              iterator = iterator,
              start = start,
              class = class,
              children = {},
****0         line = gbl.parserLine-1
            }

****0       for _, val in pairs(tbl) do
****0         if val._type == 'macro-call' then
****0           val.father = element
****0           table.insert(element.children, val)
              end
            end

****0       table.insert(sT.template, element)
****0       return element
          end
        end
      }

    2 return parsingTable

==============================================================================
src/sncl/resolve.lua
==============================================================================
    2 local resolve = {
         ---
         -- @param region
         -- @param sT
         -- @return
         makeDesc = function(region, sT)
****0       local newDesc = {
               _type = "descriptor",
               region = region,
****0          id = '__desc'..region
            }
****0       sT.head[newDesc.id] = newDesc
****0       return newDesc.id
         end
      }



      ---
      -- @param xconn
      -- @param bin
    2 function resolve.makeConnBind(xconn, bind)
****0    if xconn[bind._type][bind.role] then
****0       xconn[bind._type][bind.role] = xconn[bind._type][bind.role]+1
         else
****0       xconn[bind._type][bind.role] = 1
         end
****0    if xconn.id:find(bind.role:gsub('^%l', string.upper)) then
****0       xconn.id = xconn.id..'N'
         else
****0       xconn.id = xconn.id..bind.role:gsub('^%l', string.upper)
         end
****0    if bind.properties then
****0       for name, _ in pairs(bind.properties) do
****0          table.insert(xconn.properties, name)
            end
         end
      end

      --- Makes a the connector element table from a link table
      -- @param link
      -- @param sT
      -- @return
    2 function resolve:makeConn(link, sT)
****0    local newConn = {
            _type = 'xconnector',
            id = '',
            condition = {},
            action = {},
****0       properties = {}
         }

****0    for _, cond in pairs(link.conditions) do
****0       self.makeConnBind(newConn, cond)
         end
****0    for _, act in pairs(link.actions) do
****0       self.makeConnBind(newConn, act)
         end
****0    if link.properties then
****0       for name, _ in pairs(link.properties) do
****0          table.insert(newConn.properties, name)
            end
         end

         -- TODO: Has to do all above to check if another equal
         -- connect is already created, wasting time. How to fix?

****0    if not sT.head[newConn.id] then
****0       sT.head[newConn.id] = newConn
         end

****0    return newConn.id
      end

    2 return resolve

==============================================================================
Summary
==============================================================================

File                                                                               Hits Missed Coverage
-------------------------------------------------------------------------------------------------------
/home/lucastercas/.luarocks/share/lua/5.4/ansicolors.lua                           29   12     70.73%
/home/lucastercas/.luarocks/share/lua/5.4/busted/block.lua                         64   31     67.37%
/home/lucastercas/.luarocks/share/lua/5.4/busted/compatibility.lua                 20   14     58.82%
/home/lucastercas/.luarocks/share/lua/5.4/busted/context.lua                       37   42     46.84%
/home/lucastercas/.luarocks/share/lua/5.4/busted/core.lua                          104  91     53.33%
/home/lucastercas/.luarocks/share/lua/5.4/busted/environment.lua                   6    15     28.57%
/home/lucastercas/.luarocks/share/lua/5.4/busted/execute.lua                       19   21     47.50%
/home/lucastercas/.luarocks/share/lua/5.4/busted/init.lua                          23   56     29.11%
/home/lucastercas/.luarocks/share/lua/5.4/busted/languages/en.lua                  38   0      100.00%
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/files/lua.lua             11   0      100.00%
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/files/moonscript.lua      6    46     11.54%
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/filter_loader.lua         29   40     42.03%
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/output_handler_loader.lua 9    10     47.37%
/home/lucastercas/.luarocks/share/lua/5.4/busted/modules/test_file_loader.lua      44   10     81.48%
/home/lucastercas/.luarocks/share/lua/5.4/busted/outputHandlers/base.lua           77   25     75.49%
/home/lucastercas/.luarocks/share/lua/5.4/busted/outputHandlers/utfTerminal.lua    90   23     79.65%
/home/lucastercas/.luarocks/share/lua/5.4/busted/runner.lua                        63   59     51.64%
/home/lucastercas/.luarocks/share/lua/5.4/busted/status.lua                        21   2      91.30%
/home/lucastercas/.luarocks/share/lua/5.4/busted/utils.lua                         13   8      61.90%
/home/lucastercas/.luarocks/share/lua/5.4/luassert/assert.lua                      39   44     46.99%
/home/lucastercas/.luarocks/share/lua/5.4/luassert/assertions.lua                  22   192    10.28%
/home/lucastercas/.luarocks/share/lua/5.4/luassert/formatters/init.lua             52   59     46.85%
/home/lucastercas/.luarocks/share/lua/5.4/luassert/modifiers.lua                   1    10     9.09%
/home/lucastercas/.luarocks/share/lua/5.4/luassert/state.lua                       9    43     17.31%
/home/lucastercas/.luarocks/share/lua/5.4/luassert/util.lua                        75   77     49.34%
/home/lucastercas/.luarocks/share/lua/5.4/mediator.lua                             41   26     61.19%
/home/lucastercas/.luarocks/share/lua/5.4/pl/List.lua                              62   156    28.44%
/home/lucastercas/.luarocks/share/lua/5.4/pl/class.lua                             20   82     19.61%
/home/lucastercas/.luarocks/share/lua/5.4/pl/dir.lua                               65   185    26.00%
/home/lucastercas/.luarocks/share/lua/5.4/pl/path.lua                              37   215    14.68%
/home/lucastercas/.luarocks/share/lua/5.4/pl/tablex.lua                            27   377    6.68%
/home/lucastercas/.luarocks/share/lua/5.4/pl/types.lua                             5    57     8.06%
/home/lucastercas/.luarocks/share/lua/5.4/pl/utils.lua                             9    233    3.72%
/home/lucastercas/.luarocks/share/lua/5.4/say/init.lua                             11   14     44.00%
/home/lucastercas/.luarocks/share/lua/5.4/sncl/globals.lua                         7    0      100.00%
/home/lucastercas/.luarocks/share/lua/5.4/sncl/utils.lua                           43   48     47.25%
/home/lucastercas/.luarocks/share/lua/5.4/term/colors.lua                          3    14     17.65%
/usr/share/lua/5.4/luarocks/core/dir.lua                                           31   13     70.45%
/usr/share/lua/5.4/luarocks/core/manif.lua                                         29   25     53.70%
/usr/share/lua/5.4/luarocks/core/path.lua                                          28   41     40.58%
/usr/share/lua/5.4/luarocks/core/util.lua                                          13   145    8.23%
/usr/share/lua/5.4/luarocks/core/vers.lua                                          28   61     31.46%
/usr/share/lua/5.4/luarocks/loader.lua                                             42   44     48.84%
spec/generation_spec.lua                                                           21   0      100.00%
spec/grammar_spec.lua                                                              42   0      100.00%
spec/test_spec.lua                                                                 3    0      100.00%
src/sncl/generation.lua                                                            30   135    18.18%
src/sncl/grammar.lua                                                               73   3      96.05%
src/sncl/parsetree.lua                                                             42   85     33.07%
src/sncl/resolve.lua                                                               4    25     13.79%
-------------------------------------------------------------------------------------------------------
Total                                                                              1617 2914   35.69%
