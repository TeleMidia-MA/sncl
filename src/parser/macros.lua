local ins = require"inspect"
local utils = require"utils"
local pT = require("parse-tree")

local resolveMacros = {
   --- Resolve the call, generating an element
   -- @param call The call element itself
   -- @param stack The stack of calls
   -- @param sT The symbol table
   resolveCall = function(call, stack, sT)
      local macro = sT.macro[call.macro]
      local abv = stack[#stack]

      --[[ If the called macro is not declared ]]
      if not macro then 
         utils:printErro("Macro ", call.macro, "not declared", call.line)
         return nil
      end

      --[[ Check if the call has the same number of arguments as
      specified in the called macro --]]
      if #macro.parameters ~= #call.arguments then
         if call.father then
            --[[ But if the call is inside a template, then the element in the
            padding document must have the same number of properties as the number
            of arguments of the macro --]]
            if call.father._type ~= "for" then 
               utils:printErro("Wrong number of arguments", call.line)
               return nil
            end
         else
            utils:printErro("Wrong number of arguments", call.line)
            return nil
         end
      end

      --[[If the argument has "", then it is being by the call
      else, then the call is inside a macro, and the argument of the call is
      a parameter of the macro]]
      for p, val in pairs(call.arguments) do
         if val:match("\"*\"") then
            call.arguments[p] = val:gsub("\"", "")
            -- TODO: Remover aspas
         else
            if abv then
               --[[ Check if the macro really has the argument as a parameter
               If it does, then the call must pass the value of the argument is what is
               being passed to the macro that the call is inside]]
               if utils.containValue(sT.macro[abv.macro].parameters, val) then
                  print(abv.arguments[utils.getIndex(sT.macro[abv.macro].parameters, val)])
                  call.arguments[p] = abv.arguments[utils.getIndex(sT.macro[abv.macro].parameters, val)]
               else
                  utils:printErro("Argument",val,"is not a parameter of a macro", call.line)
                  return nil
               end
            else
               utils:printErro("Argument",val,"invalid", call.line)
               return nil
            end
         end
      end

      table.insert(stack, call)
      for _, son in pairs(macro.sons) do
         if son._type == "context" or son._type == "media" then
            resolvePresentationMacro(son, call, stack, sT)
         end
      end
      table.remove(stack)
   end,

   --- Generate the elements of the macro that are presentation ones
   -- Receives the presentation element that is inside the macro
   -- and the call, and then makes the generates presentation
   -- @param ele The element that is inside the macro
   -- @param call The call to the macro
   -- @param stack The stack of calls
   -- @param sT The symbol table
   resolvePresentationMacro = function(ele, call, stack, sT)
      local newEle = {
         id = ele.id, 
         _type = ele._type,
         properties = {}, sons = ele.sons,
      }
      local parameters = ele.father.parameters

      --[[ If the id is a property ]]
      if utils.containValue(parameters, ele.id) then
         local newId = call.arguments[utils.getIndex(parameters, ele.id)]
         if sT.presentation[newId] then
            utils:printErro("Id", newId,"already declared", call.line)
            return nil
         end
         newEle.id = newId
      end

      if ele.properties then
         resolveElementProperties(ele, newEle, call)
      end

      sT.presentation[newEle.id] = newEle

      if call.father then
         if call.father._type == "for" then
            newEle.father = call.father.father
         else
            newEle.father = call.father
         end
         if newEle.father then
            newEle.father.sons[newEle.id] = newEle
         end
      end

      for _, son in pairs(ele.sons) do
         if son._type == "macro-call" then
            resolveCall(son, stack)
         end
      end
      --return newEle
   end,

   --- Resolve the properties of an element that is being generated by a macro
   -- Check if the property is a parameter, if it is then the value of the
   -- property is the value that is being passed by the call. If it is not, then
   -- the value is the value that is in the macro
   -- @param ele The macro-son element
   -- @param newEle The element that is being generated
   -- @param call The call
   resolveElementProperties = function(ele, newEle, call)
      for name, value in pairs(ele.properties) do
         --[[ If the property is a parameter ]]
         if utils.containValue(ele.father.parameters, value) then
            utils.addProperty(newEle, name, call.arguments[utils.getIndex(ele.father.parameters, value)])
         else
            utils.addProperty(newEle, name, value)
         end
      end
   end

}
return resolveMacros
