local utils = require("utils")
local ins = require('inspect')

local resolveMacros = {

   --- Resolve the properties of an element that is being generated by a macro
   -- Check if the property is a parameter, if it is then the value of the
   -- property is the value that is being passed by the call. If it is not,
   -- then the value is the value that is in the macro
   -- @param ele The macro-son element
   -- @param newEle The element that is being generated
   -- @param call The call
   resolveElementProperties = function(ele, newEle, call, sT)
      for name, value in pairs(ele.properties) do
         --[[ If the property is a parameter ]]
         local parameters = sT.macro[call.macro].parameters
         if utils.containValue(parameters, value) then
            local index = utils.getIndex(parameters, value)
            utils:addProperty(newEle, name, call.arguments[index])
         else
            utils:addProperty(newEle, name, value)
         end
      end
   end

}

--- Generate the elements of the macro that are presentation ones
-- Receives the presentation element that is inside the macro
-- and the call, and then makes the generates presentation
-- @param ele The element that is inside the macro
-- @param call The call to the macro
-- @param stack The stack of calls
-- @param sT The symbol table
function resolveMacros:resolvePresentation(ele, call, stack, sT)
   local newEle = {
      id = ele.id,
      _type = ele._type,
      properties = {},
      sons = {},
   }
   local parameters = sT.macro[call.macro].parameters

   --[[ If the id is a property ]]
   if utils.containValue(parameters, ele.id) then
      local newId = call.arguments[utils.getIndex(parameters, ele.id)]
      if sT.presentation[newId] then
         utils:printErro(string.format('Id %s already declared.', newId), call.line)
         return nil
      end
      newId = newId:gsub('"', '')
      newEle.id = newId
   end


   if ele.properties then
      self.resolveElementProperties(ele, newEle, call, sT)
   end

   sT.presentation[newEle.id] = newEle

   if ele.sons then
      for _, son in pairs(ele.sons) do
         if son._type == 'link' then
         elseif son._type == 'macro-call' then
            self:resolveCall(son, stack, sT)
         else
            local newSon = self:resolvePresentation(son, call, stack, sT)
            newEle.sons[newSon.id] = newSon
            newSon.father = newEle
         end
      end
   end

   if call.father then
      if call.father._type == 'for' then
         newEle.father = call.father.father
      else
         newEle.father = call.father
      end
      if newEle.father then
         newEle.father.sons[newEle.id] = newEle
      end
   end

   return newEle
end

--- Resolve the call, generating an element
-- @param call The call element itself
-- @param stack The stack of calls
-- @param sT The symbol table
function resolveMacros:resolveCall(call, stack, sT)
   local macro = sT.macro[call.macro]
   local abv = stack[#stack]

   --[[ If the called macro is not declared ]]
   if not macro then
      utils:printErro(string.format("Macro %s not declared.", call.macro), call.line)
      return nil
   end

   --[[ Check if the call has the same number of arguments as
      specified in the called macro --]]
   if #macro.parameters ~= #call.arguments then
      if call.father then
         --[[ But if the call is inside a template, then the element in
            the padding document must have the same number of properties as
            the number of arguments of the macro --]]
         if call.father._type ~= 'for' then
            utils:printErro('Wrong number of arguments.', call.line)
            return nil
         end
      else
         utils:printErro('Wrong number of arguments.', call.line)
         return nil
      end
   end

   --[[If the argument has "", then it is being passed by the call
      else, then the call is inside a macro, and the argument of the call is
      a parameter of the macro]]
   for p, val in pairs(call.arguments) do
      if val:match("\"*\"") then
         call.arguments[p] = val
      else
         if abv then
            --[[ Check if the macro really has the argument as a parameter
               If it does, then the call must pass the value of the argument
               is what is being passed to the macro that the call is inside]]
            if utils.containValue(sT.macro[abv.macro].parameters, val) then
               local index = utils.getIndex(sT.macro[abv.macro].parameters, val)
               call.arguments[p] = abv.arguments[index]
            else
               utils:printErro(string.format('Argument %s is not a parameter of a macro.',
                  val), call.line)
               return nil
            end
         else
            utils:printErro(string.format('Argument %s invalid.', val), call.line)
            return nil
         end
      end
   end

   table.insert(stack, call)
   for _, son in pairs(macro.sons) do
      if son._type == 'link' then
         -- resolveLinkMacro
      else
         self:resolvePresentation(son, call, stack, sT)
      end
   end
   table.remove(stack)
end

return resolveMacros
